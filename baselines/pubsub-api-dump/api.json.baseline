{
  "packageName": "google.pubsub.v1",
  "publishName": "pubsub",
  "naming": {
    "name": "Pubsub",
    "productName": "Pubsub",
    "namespace": [
      "google"
    ],
    "version": "v1",
    "protoPackage": "google.pubsub.v1"
  },
  "hostname": "pubsub.googleapis.com",
  "port": "443",
  "services": [
    {
      "method": [
        {
          "inputInterface": ".google.pubsub.v1.Topic",
          "outputInterface": ".google.pubsub.v1.Topic",
          "comments": [
            " Creates the given topic with the given name. See the [resource name rules]",
            " (https://cloud.google.com/pubsub/docs/admin#resource_names).",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "CreateTopic",
          "inputType": ".google.pubsub.v1.Topic",
          "outputType": ".google.pubsub.v1.Topic",
          "options": {
            ".google.api.methodSignature": [
              "name"
            ],
            ".google.api.http": {
              "put": "/v1/{name=projects/*/topics/*}",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "name",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the topic. It must have the format",
                " `\"projects/{project}/topics/{topic}\"`. `{topic}` must start with a letter,",
                " and contain only letters (`[A-Za-z]`), numbers (`[0-9]`), dashes (`-`),",
                " underscores (`_`), periods (`.`), tildes (`~`), plus (`+`) or percent",
                " signs (`%`). It must be between 3 and 255 characters in length, and it",
                " must not start with `\"goog\"`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "labels",
              "paramType": "TYPE_MESSAGE[]",
              "comments": [
                " See [Creating and managing labels]",
                " (https://cloud.google.com/pubsub/docs/labels)."
              ]
            },
            {
              "paramName": "message_storage_policy",
              "paramType": ".google.pubsub.v1.MessageStoragePolicy",
              "comments": [
                " Policy constraining the set of Google Cloud Platform regions where messages",
                " published to the topic may be stored. If not present, then no constraints",
                " are in effect."
              ]
            },
            {
              "paramName": "kms_key_name",
              "paramType": "TYPE_STRING",
              "comments": [
                " The resource name of the Cloud KMS CryptoKey to be used to protect access",
                " to messages published on this topic.",
                "",
                " The expected format is `projects/*/locations/*/keyRings/*/cryptoKeys/*`."
              ]
            },
            {
              "paramName": "schema_settings",
              "paramType": ".google.pubsub.v1.SchemaSettings",
              "comments": [
                " Settings for validating messages published against a schema."
              ]
            },
            {
              "paramName": "satisfies_pzs",
              "paramType": "TYPE_BOOL",
              "comments": [
                " Reserved for future use. This field is set only in responses from the",
                " server; it is ignored if it is set in any requests."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "name"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.UpdateTopicRequest",
          "outputInterface": ".google.pubsub.v1.Topic",
          "comments": [
            " Updates an existing topic. Note that certain properties of a",
            " topic are not modifiable.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "UpdateTopic",
          "inputType": ".google.pubsub.v1.UpdateTopicRequest",
          "outputType": ".google.pubsub.v1.Topic",
          "options": {
            ".google.api.http": {
              "patch": "/v1/{topic.name=projects/*/topics/*}",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "topic",
              "paramType": ".google.pubsub.v1.Topic",
              "comments": [
                " Required. The updated topic object."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "update_mask",
              "paramType": ".google.protobuf.FieldMask",
              "comments": [
                " Required. Indicates which fields in the provided topic to update. Must be",
                " specified and non-empty. Note that if `update_mask` contains",
                " \"message_storage_policy\" but the `message_storage_policy` is not set in",
                " the `topic` provided above, then the updated value is determined by the",
                " policy configured at the project or organization level."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "topic",
              "name"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.PublishRequest",
          "outputInterface": ".google.pubsub.v1.PublishResponse",
          "comments": [
            " Adds one or more messages to the topic. Returns `NOT_FOUND` if the topic",
            " does not exist.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "Publish",
          "inputType": ".google.pubsub.v1.PublishRequest",
          "outputType": ".google.pubsub.v1.PublishResponse",
          "options": {
            ".google.api.methodSignature": [
              "topic,messages"
            ],
            ".google.api.http": {
              "post": "/v1/{topic=projects/*/topics/*}:publish",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "topic",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The messages in the request will be published on this topic.",
                " Format is `projects/{project}/topics/{topic}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "messages",
              "paramType": "TYPE_MESSAGE[]",
              "comments": [
                " Required. The messages to publish."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "topic"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.GetTopicRequest",
          "outputInterface": ".google.pubsub.v1.Topic",
          "comments": [
            " Gets the configuration of a topic.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "GetTopic",
          "inputType": ".google.pubsub.v1.GetTopicRequest",
          "outputType": ".google.pubsub.v1.Topic",
          "options": {
            ".google.api.methodSignature": [
              "topic"
            ],
            ".google.api.http": {
              "get": "/v1/{topic=projects/*/topics/*}"
            }
          },
          "paramComment": [
            {
              "paramName": "topic",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the topic to get.",
                " Format is `projects/{project}/topics/{topic}`."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "topic"
            ]
          ]
        },
        {
          "pagingFieldName": "topics",
          "pagingResponseType": ".google.pubsub.v1.Topic",
          "ignoreMapPagingMethod": false,
          "inputInterface": ".google.pubsub.v1.ListTopicsRequest",
          "outputInterface": ".google.pubsub.v1.ListTopicsResponse",
          "comments": [
            " Lists matching topics.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ListTopics",
          "inputType": ".google.pubsub.v1.ListTopicsRequest",
          "outputType": ".google.pubsub.v1.ListTopicsResponse",
          "options": {
            ".google.api.methodSignature": [
              "project"
            ],
            ".google.api.http": {
              "get": "/v1/{project=projects/*}/topics"
            }
          },
          "paramComment": [
            {
              "paramName": "project",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the project in which to list topics.",
                " Format is `projects/{project-id}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "page_size",
              "paramType": "TYPE_INT32",
              "comments": [
                " Maximum number of topics to return."
              ]
            },
            {
              "paramName": "page_token",
              "paramType": "TYPE_STRING",
              "comments": [
                " The value returned by the last `ListTopicsResponse`; indicates that this is",
                " a continuation of a prior `ListTopics` call, and that the system should",
                " return the next page of data."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "project"
            ]
          ]
        },
        {
          "pagingFieldName": "subscriptions",
          "pagingResponseType": ".google.protobuf.FieldDescriptorProto.Type.TYPE_STRING",
          "ignoreMapPagingMethod": false,
          "inputInterface": ".google.pubsub.v1.ListTopicSubscriptionsRequest",
          "outputInterface": ".google.pubsub.v1.ListTopicSubscriptionsResponse",
          "comments": [
            " Lists the names of the attached subscriptions on this topic.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ListTopicSubscriptions",
          "inputType": ".google.pubsub.v1.ListTopicSubscriptionsRequest",
          "outputType": ".google.pubsub.v1.ListTopicSubscriptionsResponse",
          "options": {
            ".google.api.methodSignature": [
              "topic"
            ],
            ".google.api.http": {
              "get": "/v1/{topic=projects/*/topics/*}/subscriptions"
            }
          },
          "paramComment": [
            {
              "paramName": "topic",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the topic that subscriptions are attached to.",
                " Format is `projects/{project}/topics/{topic}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "page_size",
              "paramType": "TYPE_INT32",
              "comments": [
                " Maximum number of subscription names to return."
              ]
            },
            {
              "paramName": "page_token",
              "paramType": "TYPE_STRING",
              "comments": [
                " The value returned by the last `ListTopicSubscriptionsResponse`; indicates",
                " that this is a continuation of a prior `ListTopicSubscriptions` call, and",
                " that the system should return the next page of data."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "topic"
            ]
          ]
        },
        {
          "pagingFieldName": "snapshots",
          "pagingResponseType": ".google.protobuf.FieldDescriptorProto.Type.TYPE_STRING",
          "ignoreMapPagingMethod": false,
          "inputInterface": ".google.pubsub.v1.ListTopicSnapshotsRequest",
          "outputInterface": ".google.pubsub.v1.ListTopicSnapshotsResponse",
          "comments": [
            " Lists the names of the snapshots on this topic. Snapshots are used in",
            " [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,",
            " which allow you to manage message acknowledgments in bulk. That is, you can",
            " set the acknowledgment state of messages in an existing subscription to the",
            " state captured by a snapshot.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ListTopicSnapshots",
          "inputType": ".google.pubsub.v1.ListTopicSnapshotsRequest",
          "outputType": ".google.pubsub.v1.ListTopicSnapshotsResponse",
          "options": {
            ".google.api.methodSignature": [
              "topic"
            ],
            ".google.api.http": {
              "get": "/v1/{topic=projects/*/topics/*}/snapshots"
            }
          },
          "paramComment": [
            {
              "paramName": "topic",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the topic that snapshots are attached to.",
                " Format is `projects/{project}/topics/{topic}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "page_size",
              "paramType": "TYPE_INT32",
              "comments": [
                " Maximum number of snapshot names to return."
              ]
            },
            {
              "paramName": "page_token",
              "paramType": "TYPE_STRING",
              "comments": [
                " The value returned by the last `ListTopicSnapshotsResponse`; indicates",
                " that this is a continuation of a prior `ListTopicSnapshots` call, and",
                " that the system should return the next page of data."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "topic"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.DeleteTopicRequest",
          "outputInterface": ".google.protobuf.Empty",
          "comments": [
            " Deletes the topic with the given name. Returns `NOT_FOUND` if the topic",
            " does not exist. After a topic is deleted, a new topic may be created with",
            " the same name; this is an entirely new topic with none of the old",
            " configuration or subscriptions. Existing subscriptions to this topic are",
            " not deleted, but their `topic` field is set to `_deleted-topic_`.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "DeleteTopic",
          "inputType": ".google.pubsub.v1.DeleteTopicRequest",
          "outputType": ".google.protobuf.Empty",
          "options": {
            ".google.api.methodSignature": [
              "topic"
            ],
            ".google.api.http": {
              "delete": "/v1/{topic=projects/*/topics/*}"
            }
          },
          "paramComment": [
            {
              "paramName": "topic",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. Name of the topic to delete.",
                " Format is `projects/{project}/topics/{topic}`."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "topic"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.DetachSubscriptionRequest",
          "outputInterface": ".google.pubsub.v1.DetachSubscriptionResponse",
          "comments": [
            " Detaches a subscription from this topic. All messages retained in the",
            " subscription are dropped. Subsequent `Pull` and `StreamingPull` requests",
            " will return FAILED_PRECONDITION. If the subscription is a push",
            " subscription, pushes to the endpoint will stop.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "DetachSubscription",
          "inputType": ".google.pubsub.v1.DetachSubscriptionRequest",
          "outputType": ".google.pubsub.v1.DetachSubscriptionResponse",
          "options": {
            ".google.api.http": {
              "post": "/v1/{subscription=projects/*/subscriptions/*}:detach"
            }
          },
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The subscription to detach.",
                " Format is `projects/{project}/subscriptions/{subscription}`."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "subscription"
            ]
          ]
        }
      ],
      "name": "Publisher",
      "options": {
        ".google.api.defaultHost": "pubsub.googleapis.com",
        ".google.api.oauthScopes": "https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/pubsub"
      },
      "packageName": "google.pubsub.v1",
      "protoFile": "google/pubsub/v1/pubsub.proto",
      "comments": [
        " The service that an application uses to manipulate topics, and to send",
        " messages to a topic."
      ],
      "commentsMap": {
        "comments": {
          "Http:rules": {
            "paramName": "rules",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " A list of HTTP configuration rules that apply to individual API methods.",
              "",
              " **NOTE:** All service configuration rules follow \"last one wins\" order."
            ]
          },
          "Http:fully_decode_reserved_expansion": {
            "paramName": "fully_decode_reserved_expansion",
            "paramType": "TYPE_BOOL",
            "comments": [
              " When set to true, URL path parameters will be fully URI-decoded except in",
              " cases of single segment matches in reserved expansion, where \"%2F\" will be",
              " left encoded.",
              "",
              " The default behavior is to not decode RFC 6570 reserved characters in multi",
              " segment matches."
            ]
          },
          "HttpRule:selector": {
            "paramName": "selector",
            "paramType": "TYPE_STRING",
            "comments": [
              " Selects a method to which this rule applies.",
              "",
              " Refer to [selector][google.api.DocumentationRule.selector] for syntax details."
            ]
          },
          "HttpRule:get": {
            "paramName": "get",
            "paramType": "TYPE_STRING",
            "comments": [
              " Maps to HTTP GET. Used for listing and getting information about",
              " resources."
            ]
          },
          "HttpRule:put": {
            "paramName": "put",
            "paramType": "TYPE_STRING",
            "comments": [
              " Maps to HTTP PUT. Used for replacing a resource."
            ]
          },
          "HttpRule:post": {
            "paramName": "post",
            "paramType": "TYPE_STRING",
            "comments": [
              " Maps to HTTP POST. Used for creating a resource or performing an action."
            ]
          },
          "HttpRule:delete": {
            "paramName": "delete",
            "paramType": "TYPE_STRING",
            "comments": [
              " Maps to HTTP DELETE. Used for deleting a resource."
            ]
          },
          "HttpRule:patch": {
            "paramName": "patch",
            "paramType": "TYPE_STRING",
            "comments": [
              " Maps to HTTP PATCH. Used for updating a resource."
            ]
          },
          "HttpRule:custom": {
            "paramName": "custom",
            "paramType": ".google.api.CustomHttpPattern",
            "comments": [
              " The custom pattern is used for specifying an HTTP method that is not",
              " included in the `pattern` field, such as HEAD, or \"*\" to leave the",
              " HTTP method unspecified for this rule. The wild-card rule is useful",
              " for services that provide content to Web (HTML) clients."
            ]
          },
          "HttpRule:body": {
            "paramName": "body",
            "paramType": "TYPE_STRING",
            "comments": [
              " The name of the request field whose value is mapped to the HTTP request",
              " body, or `*` for mapping all request fields not captured by the path",
              " pattern to the HTTP body, or omitted for not having any HTTP request body.",
              "",
              " NOTE: the referred field must be present at the top-level of the request",
              " message type."
            ]
          },
          "HttpRule:response_body": {
            "paramName": "response_body",
            "paramType": "TYPE_STRING",
            "comments": [
              " Optional. The name of the response field whose value is mapped to the HTTP",
              " response body. When omitted, the entire response message will be used",
              " as the HTTP response body.",
              "",
              " NOTE: The referred field must be present at the top-level of the response",
              " message type."
            ]
          },
          "HttpRule:additional_bindings": {
            "paramName": "additional_bindings",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Additional HTTP bindings for the selector. Nested bindings must",
              " not contain an `additional_bindings` field themselves (that is,",
              " the nesting may only be one level deep)."
            ]
          },
          "CustomHttpPattern:kind": {
            "paramName": "kind",
            "paramType": "TYPE_STRING",
            "comments": [
              " The name of this custom HTTP verb."
            ]
          },
          "CustomHttpPattern:path": {
            "paramName": "path",
            "paramType": "TYPE_STRING",
            "comments": [
              " The path matched by this custom verb."
            ]
          },
          "FileDescriptorSet:file": {
            "paramName": "file",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "FileDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "FileDescriptorProto:package": {
            "paramName": "package",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "FileDescriptorProto:dependency": {
            "paramName": "dependency",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Names of files imported by this file."
            ]
          },
          "FileDescriptorProto:public_dependency": {
            "paramName": "public_dependency",
            "paramType": "TYPE_INT32[]",
            "comments": [
              " Indexes of the public imported files in the dependency list above."
            ]
          },
          "FileDescriptorProto:weak_dependency": {
            "paramName": "weak_dependency",
            "paramType": "TYPE_INT32[]",
            "comments": [
              " Indexes of the weak imported files in the dependency list.",
              " For Google-internal migration only. Do not use."
            ]
          },
          "FileDescriptorProto:message_type": {
            "paramName": "message_type",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " All top-level definitions in this file."
            ]
          },
          "FileDescriptorProto:enum_type": {
            "paramName": "enum_type",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "FileDescriptorProto:service": {
            "paramName": "service",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "FileDescriptorProto:extension": {
            "paramName": "extension",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "FileDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.FileOptions",
            "comments": []
          },
          "FileDescriptorProto:source_code_info": {
            "paramName": "source_code_info",
            "paramType": ".google.protobuf.SourceCodeInfo",
            "comments": [
              " This field contains optional information about the original source code.",
              " You may safely remove this entire field without harming runtime",
              " functionality of the descriptors -- the information is needed only by",
              " development tools."
            ]
          },
          "FileDescriptorProto:syntax": {
            "paramName": "syntax",
            "paramType": "TYPE_STRING",
            "comments": [
              " The syntax of the proto file.",
              " The supported values are \"proto2\" and \"proto3\"."
            ]
          },
          "DescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "DescriptorProto:field": {
            "paramName": "field",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:extension": {
            "paramName": "extension",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:nested_type": {
            "paramName": "nested_type",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:enum_type": {
            "paramName": "enum_type",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:extension_range": {
            "paramName": "extension_range",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:oneof_decl": {
            "paramName": "oneof_decl",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.MessageOptions",
            "comments": []
          },
          "DescriptorProto:reserved_range": {
            "paramName": "reserved_range",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:reserved_name": {
            "paramName": "reserved_name",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Reserved field names, which may not be used by fields in the same message.",
              " A given name may only be reserved once."
            ]
          },
          "ExtensionRangeOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "FieldDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "FieldDescriptorProto:number": {
            "paramName": "number",
            "paramType": "TYPE_INT32",
            "comments": []
          },
          "FieldDescriptorProto:label": {
            "paramName": "label",
            "paramType": ".google.protobuf.FieldDescriptorProto.Label",
            "comments": []
          },
          "FieldDescriptorProto:type": {
            "paramName": "type",
            "paramType": ".google.protobuf.FieldDescriptorProto.Type",
            "comments": [
              " If type_name is set, this need not be set.  If both this and type_name",
              " are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP."
            ]
          },
          "FieldDescriptorProto:type_name": {
            "paramName": "type_name",
            "paramType": "TYPE_STRING",
            "comments": [
              " For message and enum types, this is the name of the type.  If the name",
              " starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping",
              " rules are used to find the type (i.e. first the nested types within this",
              " message are searched, then within the parent, on up to the root",
              " namespace)."
            ]
          },
          "FieldDescriptorProto:extendee": {
            "paramName": "extendee",
            "paramType": "TYPE_STRING",
            "comments": [
              " For extensions, this is the name of the type being extended.  It is",
              " resolved in the same manner as type_name."
            ]
          },
          "FieldDescriptorProto:default_value": {
            "paramName": "default_value",
            "paramType": "TYPE_STRING",
            "comments": [
              " For numeric types, contains the original text representation of the value.",
              " For booleans, \"true\" or \"false\".",
              " For strings, contains the default text contents (not escaped in any way).",
              " For bytes, contains the C escaped value.  All bytes >= 128 are escaped."
            ]
          },
          "FieldDescriptorProto:oneof_index": {
            "paramName": "oneof_index",
            "paramType": "TYPE_INT32",
            "comments": [
              " If set, gives the index of a oneof in the containing type's oneof_decl",
              " list.  This field is a member of that oneof."
            ]
          },
          "FieldDescriptorProto:json_name": {
            "paramName": "json_name",
            "paramType": "TYPE_STRING",
            "comments": [
              " JSON name of this field. The value is set by protocol compiler. If the",
              " user has set a \"json_name\" option on this field, that option's value",
              " will be used. Otherwise, it's deduced from the field's name by converting",
              " it to camelCase."
            ]
          },
          "FieldDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.FieldOptions",
            "comments": []
          },
          "FieldDescriptorProto:proto3_optional": {
            "paramName": "proto3_optional",
            "paramType": "TYPE_BOOL",
            "comments": [
              " If true, this is a proto3 \"optional\". When a proto3 field is optional, it",
              " tracks presence regardless of field type.",
              "",
              " When proto3_optional is true, this field must be belong to a oneof to",
              " signal to old proto3 clients that presence is tracked for this field. This",
              " oneof is known as a \"synthetic\" oneof, and this field must be its sole",
              " member (each proto3 optional field gets its own synthetic oneof). Synthetic",
              " oneofs exist in the descriptor only, and do not generate any API. Synthetic",
              " oneofs must be ordered after all \"real\" oneofs.",
              "",
              " For message fields, proto3_optional doesn't create any semantic change,",
              " since non-repeated message fields always track presence. However it still",
              " indicates the semantic detail of whether the user wrote \"optional\" or not.",
              " This can be useful for round-tripping the .proto file. For consistency we",
              " give message fields a synthetic oneof also, even though it is not required",
              " to track presence. This is especially important because the parser can't",
              " tell if a field is a message or an enum, so it must always create a",
              " synthetic oneof.",
              "",
              " Proto2 optional fields do not set this flag, because they already indicate",
              " optional with `LABEL_OPTIONAL`."
            ]
          },
          "OneofDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "OneofDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.OneofOptions",
            "comments": []
          },
          "EnumDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "EnumDescriptorProto:value": {
            "paramName": "value",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "EnumDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.EnumOptions",
            "comments": []
          },
          "EnumDescriptorProto:reserved_range": {
            "paramName": "reserved_range",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Range of reserved numeric values. Reserved numeric values may not be used",
              " by enum values in the same enum declaration. Reserved ranges may not",
              " overlap."
            ]
          },
          "EnumDescriptorProto:reserved_name": {
            "paramName": "reserved_name",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Reserved enum value names, which may not be reused. A given name may only",
              " be reserved once."
            ]
          },
          "EnumValueDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "EnumValueDescriptorProto:number": {
            "paramName": "number",
            "paramType": "TYPE_INT32",
            "comments": []
          },
          "EnumValueDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.EnumValueOptions",
            "comments": []
          },
          "ServiceDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "ServiceDescriptorProto:method": {
            "paramName": "method",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "ServiceDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.ServiceOptions",
            "comments": []
          },
          "MethodDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "MethodDescriptorProto:input_type": {
            "paramName": "input_type",
            "paramType": "TYPE_STRING",
            "comments": [
              " Input and output type names.  These are resolved in the same way as",
              " FieldDescriptorProto.type_name, but must refer to a message type."
            ]
          },
          "MethodDescriptorProto:output_type": {
            "paramName": "output_type",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "MethodDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.MethodOptions",
            "comments": []
          },
          "MethodDescriptorProto:client_streaming": {
            "paramName": "client_streaming",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Identifies if client streams multiple client messages"
            ]
          },
          "MethodDescriptorProto:server_streaming": {
            "paramName": "server_streaming",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Identifies if server streams multiple server messages"
            ]
          },
          "FileOptions:java_package": {
            "paramName": "java_package",
            "paramType": "TYPE_STRING",
            "comments": [
              " Sets the Java package where classes generated from this .proto will be",
              " placed.  By default, the proto package is used, but this is often",
              " inappropriate because proto packages do not normally start with backwards",
              " domain names."
            ]
          },
          "FileOptions:java_outer_classname": {
            "paramName": "java_outer_classname",
            "paramType": "TYPE_STRING",
            "comments": [
              " Controls the name of the wrapper Java class generated for the .proto file.",
              " That class will always contain the .proto file's getDescriptor() method as",
              " well as any top-level extensions defined in the .proto file.",
              " If java_multiple_files is disabled, then all the other classes from the",
              " .proto file will be nested inside the single wrapper outer class."
            ]
          },
          "FileOptions:java_multiple_files": {
            "paramName": "java_multiple_files",
            "paramType": "TYPE_BOOL",
            "comments": [
              " If enabled, then the Java code generator will generate a separate .java",
              " file for each top-level message, enum, and service defined in the .proto",
              " file.  Thus, these types will *not* be nested inside the wrapper class",
              " named by java_outer_classname.  However, the wrapper class will still be",
              " generated to contain the file's getDescriptor() method as well as any",
              " top-level extensions defined in the file."
            ]
          },
          "FileOptions:java_generate_equals_and_hash": {
            "paramName": "java_generate_equals_and_hash",
            "paramType": "TYPE_BOOL",
            "comments": [
              " This option does nothing."
            ]
          },
          "FileOptions:java_string_check_utf8": {
            "paramName": "java_string_check_utf8",
            "paramType": "TYPE_BOOL",
            "comments": [
              " If set true, then the Java2 code generator will generate code that",
              " throws an exception whenever an attempt is made to assign a non-UTF-8",
              " byte sequence to a string field.",
              " Message reflection will do the same.",
              " However, an extension field still accepts non-UTF-8 byte sequences.",
              " This option has no effect on when used with the lite runtime."
            ]
          },
          "FileOptions:optimize_for": {
            "paramName": "optimize_for",
            "paramType": ".google.protobuf.FileOptions.OptimizeMode",
            "comments": []
          },
          "FileOptions:go_package": {
            "paramName": "go_package",
            "paramType": "TYPE_STRING",
            "comments": [
              " Sets the Go package where structs generated from this .proto will be",
              " placed. If omitted, the Go package will be derived from the following:",
              "   - The basename of the package import path, if provided.",
              "   - Otherwise, the package statement in the .proto file, if present.",
              "   - Otherwise, the basename of the .proto file, without extension."
            ]
          },
          "FileOptions:cc_generic_services": {
            "paramName": "cc_generic_services",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Should generic services be generated in each language?  \"Generic\" services",
              " are not specific to any particular RPC system.  They are generated by the",
              " main code generators in each language (without additional plugins).",
              " Generic services were the only kind of service generation supported by",
              " early versions of google.protobuf.",
              "",
              " Generic services are now considered deprecated in favor of using plugins",
              " that generate code specific to your particular RPC system.  Therefore,",
              " these default to false.  Old code which depends on generic services should",
              " explicitly set them to true."
            ]
          },
          "FileOptions:java_generic_services": {
            "paramName": "java_generic_services",
            "paramType": "TYPE_BOOL",
            "comments": []
          },
          "FileOptions:py_generic_services": {
            "paramName": "py_generic_services",
            "paramType": "TYPE_BOOL",
            "comments": []
          },
          "FileOptions:php_generic_services": {
            "paramName": "php_generic_services",
            "paramType": "TYPE_BOOL",
            "comments": []
          },
          "FileOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this file deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for everything in the file, or it will be completely ignored; in the very",
              " least, this is a formalization for deprecating files."
            ]
          },
          "FileOptions:cc_enable_arenas": {
            "paramName": "cc_enable_arenas",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Enables the use of arenas for the proto messages in this file. This applies",
              " only to generated classes for C++."
            ]
          },
          "FileOptions:objc_class_prefix": {
            "paramName": "objc_class_prefix",
            "paramType": "TYPE_STRING",
            "comments": [
              " Sets the objective c class prefix which is prepended to all objective c",
              " generated classes from this .proto. There is no default."
            ]
          },
          "FileOptions:csharp_namespace": {
            "paramName": "csharp_namespace",
            "paramType": "TYPE_STRING",
            "comments": [
              " Namespace for generated classes; defaults to the package."
            ]
          },
          "FileOptions:swift_prefix": {
            "paramName": "swift_prefix",
            "paramType": "TYPE_STRING",
            "comments": [
              " By default Swift generators will take the proto package and CamelCase it",
              " replacing '.' with underscore and use that to prefix the types/symbols",
              " defined. When this options is provided, they will use this value instead",
              " to prefix the types/symbols defined."
            ]
          },
          "FileOptions:php_class_prefix": {
            "paramName": "php_class_prefix",
            "paramType": "TYPE_STRING",
            "comments": [
              " Sets the php class prefix which is prepended to all php generated classes",
              " from this .proto. Default is empty."
            ]
          },
          "FileOptions:php_namespace": {
            "paramName": "php_namespace",
            "paramType": "TYPE_STRING",
            "comments": [
              " Use this option to change the namespace of php generated classes. Default",
              " is empty. When this option is empty, the package name will be used for",
              " determining the namespace."
            ]
          },
          "FileOptions:php_metadata_namespace": {
            "paramName": "php_metadata_namespace",
            "paramType": "TYPE_STRING",
            "comments": [
              " Use this option to change the namespace of php generated metadata classes.",
              " Default is empty. When this option is empty, the proto file name will be",
              " used for determining the namespace."
            ]
          },
          "FileOptions:ruby_package": {
            "paramName": "ruby_package",
            "paramType": "TYPE_STRING",
            "comments": [
              " Use this option to change the package of ruby generated classes. Default",
              " is empty. When this option is not set, the package name will be used for",
              " determining the ruby package."
            ]
          },
          "FileOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here.",
              " See the documentation for the \"Options\" section above."
            ]
          },
          "MessageOptions:message_set_wire_format": {
            "paramName": "message_set_wire_format",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Set true to use the old proto1 MessageSet wire format for extensions.",
              " This is provided for backwards-compatibility with the MessageSet wire",
              " format.  You should not use this for any other reason:  It's less",
              " efficient, has fewer features, and is more complicated.",
              "",
              " The message must be defined exactly as follows:",
              "   message Foo {",
              "     option message_set_wire_format = true;",
              "     extensions 4 to max;",
              "   }",
              " Note that the message cannot have any defined fields; MessageSets only",
              " have extensions.",
              "",
              " All extensions of your type must be singular messages; e.g. they cannot",
              " be int32s, enums, or repeated messages.",
              "",
              " Because this is an option, the above two restrictions are not enforced by",
              " the protocol compiler."
            ]
          },
          "MessageOptions:no_standard_descriptor_accessor": {
            "paramName": "no_standard_descriptor_accessor",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Disables the generation of the standard \"descriptor()\" accessor, which can",
              " conflict with a field of the same name.  This is meant to make migration",
              " from proto1 easier; new code should avoid fields named \"descriptor\"."
            ]
          },
          "MessageOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this message deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for the message, or it will be completely ignored; in the very least,",
              " this is a formalization for deprecating messages."
            ]
          },
          "MessageOptions:map_entry": {
            "paramName": "map_entry",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Whether the message is an automatically generated map entry type for the",
              " maps field.",
              "",
              " For maps fields:",
              "     map<KeyType, ValueType> map_field = 1;",
              " The parsed descriptor looks like:",
              "     message MapFieldEntry {",
              "         option map_entry = true;",
              "         optional KeyType key = 1;",
              "         optional ValueType value = 2;",
              "     }",
              "     repeated MapFieldEntry map_field = 1;",
              "",
              " Implementations may choose not to generate the map_entry=true message, but",
              " use a native map in the target language to hold the keys and values.",
              " The reflection APIs in such implementations still need to work as",
              " if the field is a repeated message field.",
              "",
              " NOTE: Do not set the option in .proto files. Always use the maps syntax",
              " instead. The option should only be implicitly set by the proto compiler",
              " parser."
            ]
          },
          "MessageOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "FieldOptions:ctype": {
            "paramName": "ctype",
            "paramType": ".google.protobuf.FieldOptions.CType",
            "comments": [
              " The ctype option instructs the C++ code generator to use a different",
              " representation of the field than it normally would.  See the specific",
              " options below.  This option is not yet implemented in the open source",
              " release -- sorry, we'll try to include it in a future version!"
            ]
          },
          "FieldOptions:packed": {
            "paramName": "packed",
            "paramType": "TYPE_BOOL",
            "comments": [
              " The packed option can be enabled for repeated primitive fields to enable",
              " a more efficient representation on the wire. Rather than repeatedly",
              " writing the tag and type for each element, the entire array is encoded as",
              " a single length-delimited blob. In proto3, only explicit setting it to",
              " false will avoid using packed encoding."
            ]
          },
          "FieldOptions:jstype": {
            "paramName": "jstype",
            "paramType": ".google.protobuf.FieldOptions.JSType",
            "comments": [
              " The jstype option determines the JavaScript type used for values of the",
              " field.  The option is permitted only for 64 bit integral and fixed types",
              " (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING",
              " is represented as JavaScript string, which avoids loss of precision that",
              " can happen when a large value is converted to a floating point JavaScript.",
              " Specifying JS_NUMBER for the jstype causes the generated JavaScript code to",
              " use the JavaScript \"number\" type.  The behavior of the default option",
              " JS_NORMAL is implementation dependent.",
              "",
              " This option is an enum to permit additional types to be added, e.g.",
              " goog.math.Integer."
            ]
          },
          "FieldOptions:lazy": {
            "paramName": "lazy",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Should this field be parsed lazily?  Lazy applies only to message-type",
              " fields.  It means that when the outer message is initially parsed, the",
              " inner message's contents will not be parsed but instead stored in encoded",
              " form.  The inner message will actually be parsed when it is first accessed.",
              "",
              " This is only a hint.  Implementations are free to choose whether to use",
              " eager or lazy parsing regardless of the value of this option.  However,",
              " setting this option true suggests that the protocol author believes that",
              " using lazy parsing on this field is worth the additional bookkeeping",
              " overhead typically needed to implement it.",
              "",
              " This option does not affect the public interface of any generated code;",
              " all method signatures remain the same.  Furthermore, thread-safety of the",
              " interface is not affected by this option; const methods remain safe to",
              " call from multiple threads concurrently, while non-const methods continue",
              " to require exclusive access.",
              "",
              "",
              " Note that implementations may choose not to check required fields within",
              " a lazy sub-message.  That is, calling IsInitialized() on the outer message",
              " may return true even if the inner message has missing required fields.",
              " This is necessary because otherwise the inner message would have to be",
              " parsed in order to perform the check, defeating the purpose of lazy",
              " parsing.  An implementation which chooses not to check required fields",
              " must be consistent about it.  That is, for any particular sub-message, the",
              " implementation must either *always* check its required fields, or *never*",
              " check its required fields, regardless of whether or not the message has",
              " been parsed.",
              "",
              " As of 2021, lazy does no correctness checks on the byte stream during",
              " parsing.  This may lead to crashes if and when an invalid byte stream is",
              " finally parsed upon access.",
              "",
              " TODO(b/211906113):  Enable validation on lazy fields."
            ]
          },
          "FieldOptions:unverified_lazy": {
            "paramName": "unverified_lazy",
            "paramType": "TYPE_BOOL",
            "comments": [
              " unverified_lazy does no correctness checks on the byte stream. This should",
              " only be used where lazy with verification is prohibitive for performance",
              " reasons."
            ]
          },
          "FieldOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this field deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for accessors, or it will be completely ignored; in the very least, this",
              " is a formalization for deprecating fields."
            ]
          },
          "FieldOptions:weak": {
            "paramName": "weak",
            "paramType": "TYPE_BOOL",
            "comments": [
              " For Google-internal migration only. Do not use."
            ]
          },
          "FieldOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "OneofOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "EnumOptions:allow_alias": {
            "paramName": "allow_alias",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Set this option to true to allow mapping different tag names to the same",
              " value."
            ]
          },
          "EnumOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this enum deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for the enum, or it will be completely ignored; in the very least, this",
              " is a formalization for deprecating enums."
            ]
          },
          "EnumOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "EnumValueOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this enum value deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for the enum value, or it will be completely ignored; in the very least,",
              " this is a formalization for deprecating enum values."
            ]
          },
          "EnumValueOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "ServiceOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this service deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for the service, or it will be completely ignored; in the very least,",
              " this is a formalization for deprecating services."
            ]
          },
          "ServiceOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "MethodOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this method deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for the method, or it will be completely ignored; in the very least,",
              " this is a formalization for deprecating methods."
            ]
          },
          "MethodOptions:idempotency_level": {
            "paramName": "idempotency_level",
            "paramType": ".google.protobuf.MethodOptions.IdempotencyLevel",
            "comments": []
          },
          "MethodOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "UninterpretedOption:name": {
            "paramName": "name",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "UninterpretedOption:identifier_value": {
            "paramName": "identifier_value",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value of the uninterpreted option, in whatever type the tokenizer",
              " identified it as during parsing. Exactly one of these should be set."
            ]
          },
          "UninterpretedOption:positive_int_value": {
            "paramName": "positive_int_value",
            "paramType": "TYPE_UINT64",
            "comments": []
          },
          "UninterpretedOption:negative_int_value": {
            "paramName": "negative_int_value",
            "paramType": "TYPE_INT64",
            "comments": []
          },
          "UninterpretedOption:double_value": {
            "paramName": "double_value",
            "paramType": "TYPE_DOUBLE",
            "comments": []
          },
          "UninterpretedOption:string_value": {
            "paramName": "string_value",
            "paramType": "TYPE_BYTES",
            "comments": []
          },
          "UninterpretedOption:aggregate_value": {
            "paramName": "aggregate_value",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "SourceCodeInfo:location": {
            "paramName": "location",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " A Location identifies a piece of source code in a .proto file which",
              " corresponds to a particular definition.  This information is intended",
              " to be useful to IDEs, code indexers, documentation generators, and similar",
              " tools.",
              "",
              " For example, say we have a file like:",
              "   message Foo {",
              "     optional string foo = 1;",
              "   }",
              " Let's look at just the field definition:",
              "   optional string foo = 1;",
              "   ^       ^^     ^^  ^  ^^^",
              "   a       bc     de  f  ghi",
              " We have the following locations:",
              "   span   path               represents",
              "   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.",
              "   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).",
              "   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).",
              "   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).",
              "   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).",
              "",
              " Notes:",
              " - A location may refer to a repeated field itself (i.e. not to any",
              "   particular index within it).  This is used whenever a set of elements are",
              "   logically enclosed in a single code segment.  For example, an entire",
              "   extend block (possibly containing multiple extension definitions) will",
              "   have an outer location whose path refers to the \"extensions\" repeated",
              "   field without an index.",
              " - Multiple locations may have the same path.  This happens when a single",
              "   logical declaration is spread out across multiple places.  The most",
              "   obvious example is the \"extend\" block again -- there may be multiple",
              "   extend blocks in the same scope, each of which will have the same path.",
              " - A location's span is not always a subset of its parent's span.  For",
              "   example, the \"extendee\" of an extension declaration appears at the",
              "   beginning of the \"extend\" block and is shared by all extensions within",
              "   the block.",
              " - Just because a location's span is a subset of some other location's span",
              "   does not mean that it is a descendant.  For example, a \"group\" defines",
              "   both a type and a field in a single declaration.  Thus, the locations",
              "   corresponding to the type and field and their components will overlap.",
              " - Code which tries to interpret locations should probably be designed to",
              "   ignore those that it doesn't understand, as more types of locations could",
              "   be recorded in the future."
            ]
          },
          "GeneratedCodeInfo:annotation": {
            "paramName": "annotation",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " An Annotation connects some span of text in generated code to an element",
              " of its generating .proto file."
            ]
          },
          "ResourceDescriptor:type": {
            "paramName": "type",
            "paramType": "TYPE_STRING",
            "comments": [
              " The resource type. It must be in the format of",
              " {service_name}/{resource_type_kind}. The `resource_type_kind` must be",
              " singular and must not include version numbers.",
              "",
              " Example: `storage.googleapis.com/Bucket`",
              "",
              " The value of the resource_type_kind must follow the regular expression",
              " /[A-Za-z][a-zA-Z0-9]+/. It should start with an upper case character and",
              " should use PascalCase (UpperCamelCase). The maximum number of",
              " characters allowed for the `resource_type_kind` is 100."
            ]
          },
          "ResourceDescriptor:pattern": {
            "paramName": "pattern",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Optional. The relative resource name pattern associated with this resource",
              " type. The DNS prefix of the full resource name shouldn't be specified here.",
              "",
              " The path pattern must follow the syntax, which aligns with HTTP binding",
              " syntax:",
              "",
              "     Template = Segment { \"/\" Segment } ;",
              "     Segment = LITERAL | Variable ;",
              "     Variable = \"{\" LITERAL \"}\" ;",
              "",
              " Examples:",
              "",
              "     - \"projects/{project}/topics/{topic}\"",
              "     - \"projects/{project}/knowledgeBases/{knowledge_base}\"",
              "",
              " The components in braces correspond to the IDs for each resource in the",
              " hierarchy. It is expected that, if multiple patterns are provided,",
              " the same component name (e.g. \"project\") refers to IDs of the same",
              " type of resource."
            ]
          },
          "ResourceDescriptor:name_field": {
            "paramName": "name_field",
            "paramType": "TYPE_STRING",
            "comments": [
              " Optional. The field on the resource that designates the resource name",
              " field. If omitted, this is assumed to be \"name\"."
            ]
          },
          "ResourceDescriptor:history": {
            "paramName": "history",
            "paramType": ".google.api.ResourceDescriptor.History",
            "comments": [
              " Optional. The historical or future-looking state of the resource pattern.",
              "",
              " Example:",
              "",
              "     // The InspectTemplate message originally only supported resource",
              "     // names with organization, and project was added later.",
              "     message InspectTemplate {",
              "       option (google.api.resource) = {",
              "         type: \"dlp.googleapis.com/InspectTemplate\"",
              "         pattern:",
              "         \"organizations/{organization}/inspectTemplates/{inspect_template}\"",
              "         pattern: \"projects/{project}/inspectTemplates/{inspect_template}\"",
              "         history: ORIGINALLY_SINGLE_PATTERN",
              "       };",
              "     }"
            ]
          },
          "ResourceDescriptor:plural": {
            "paramName": "plural",
            "paramType": "TYPE_STRING",
            "comments": [
              " The plural name used in the resource name and permission names, such as",
              " 'projects' for the resource name of 'projects/{project}' and the permission",
              " name of 'cloudresourcemanager.googleapis.com/projects.get'. It is the same",
              " concept of the `plural` field in k8s CRD spec",
              " https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/",
              "",
              " Note: The plural form is required even for singleton resources. See",
              " https://aip.dev/156"
            ]
          },
          "ResourceDescriptor:singular": {
            "paramName": "singular",
            "paramType": "TYPE_STRING",
            "comments": [
              " The same concept of the `singular` field in k8s CRD spec",
              " https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/",
              " Such as \"project\" for the `resourcemanager.googleapis.com/Project` type."
            ]
          },
          "ResourceDescriptor:style": {
            "paramName": "style",
            "paramType": "TYPE_ENUM[]",
            "comments": [
              " Style flag(s) for this resource.",
              " These indicate that a resource is expected to conform to a given",
              " style. See the specific style flags for additional information."
            ]
          },
          "ResourceReference:type": {
            "paramName": "type",
            "paramType": "TYPE_STRING",
            "comments": [
              " The resource type that the annotated field references.",
              "",
              " Example:",
              "",
              "     message Subscription {",
              "       string topic = 2 [(google.api.resource_reference) = {",
              "         type: \"pubsub.googleapis.com/Topic\"",
              "       }];",
              "     }",
              "",
              " Occasionally, a field may reference an arbitrary resource. In this case,",
              " APIs use the special value * in their resource reference.",
              "",
              " Example:",
              "",
              "     message GetIamPolicyRequest {",
              "       string resource = 2 [(google.api.resource_reference) = {",
              "         type: \"*\"",
              "       }];",
              "     }"
            ]
          },
          "ResourceReference:child_type": {
            "paramName": "child_type",
            "paramType": "TYPE_STRING",
            "comments": [
              " The resource type of a child collection that the annotated field",
              " references. This is useful for annotating the `parent` field that",
              " doesn't have a fixed resource type.",
              "",
              " Example:",
              "",
              "     message ListLogEntriesRequest {",
              "       string parent = 1 [(google.api.resource_reference) = {",
              "         child_type: \"logging.googleapis.com/LogEntry\"",
              "       };",
              "     }"
            ]
          },
          "Duration:seconds": {
            "paramName": "seconds",
            "paramType": "TYPE_INT64",
            "comments": [
              " Signed seconds of the span of time. Must be from -315,576,000,000",
              " to +315,576,000,000 inclusive. Note: these bounds are computed from:",
              " 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
            ]
          },
          "Duration:nanos": {
            "paramName": "nanos",
            "paramType": "TYPE_INT32",
            "comments": [
              " Signed fractions of a second at nanosecond resolution of the span",
              " of time. Durations less than one second are represented with a 0",
              " `seconds` field and a positive or negative `nanos` field. For durations",
              " of one second or more, a non-zero value for the `nanos` field must be",
              " of the same sign as the `seconds` field. Must be from -999,999,999",
              " to +999,999,999 inclusive."
            ]
          },
          "FieldMask:paths": {
            "paramName": "paths",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " The set of field mask paths."
            ]
          },
          "Timestamp:seconds": {
            "paramName": "seconds",
            "paramType": "TYPE_INT64",
            "comments": [
              " Represents seconds of UTC time since Unix epoch",
              " 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to",
              " 9999-12-31T23:59:59Z inclusive."
            ]
          },
          "Timestamp:nanos": {
            "paramName": "nanos",
            "paramType": "TYPE_INT32",
            "comments": [
              " Non-negative fractions of a second at nanosecond resolution. Negative",
              " second values with fractions must still have non-negative nanos values",
              " that count forward in time. Must be from 0 to 999,999,999",
              " inclusive."
            ]
          },
          "SchemaService": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Service for doing schema-related operations."
            ]
          },
          "SchemaService:CreateSchema": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Creates a schema.",
              ""
            ]
          },
          "SchemaService:GetSchema": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Gets a schema.",
              ""
            ]
          },
          "SchemaService:ListSchemas": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Lists schemas in a project.",
              ""
            ]
          },
          "SchemaService:DeleteSchema": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Deletes a schema.",
              ""
            ]
          },
          "SchemaService:ValidateSchema": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Validates a schema.",
              ""
            ]
          },
          "SchemaService:ValidateMessage": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Validates a message against a schema.",
              ""
            ]
          },
          "Schema:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. Name of the schema.",
              " Format is `projects/{project}/schemas/{schema}`."
            ],
            "fieldBehavior": 2
          },
          "Schema:type": {
            "paramName": "type",
            "paramType": ".google.pubsub.v1.Schema.Type",
            "comments": [
              " The type of the schema definition."
            ]
          },
          "Schema:definition": {
            "paramName": "definition",
            "paramType": "TYPE_STRING",
            "comments": [
              " The definition of the schema. This should contain a string representing",
              " the full definition of the schema that is a valid schema definition of",
              " the type specified in `type`."
            ]
          },
          "CreateSchemaRequest:parent": {
            "paramName": "parent",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to create the schema.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "CreateSchemaRequest:schema": {
            "paramName": "schema",
            "paramType": ".google.pubsub.v1.Schema",
            "comments": [
              " Required. The schema object to create.",
              "",
              " This schema's `name` parameter is ignored. The schema object returned",
              " by CreateSchema will have a `name` made using the given `parent` and",
              " `schema_id`."
            ],
            "fieldBehavior": 2
          },
          "CreateSchemaRequest:schema_id": {
            "paramName": "schema_id",
            "paramType": "TYPE_STRING",
            "comments": [
              " The ID to use for the schema, which will become the final component of",
              " the schema's resource name.",
              "",
              " See https://cloud.google.com/pubsub/docs/admin#resource_names for resource",
              " name constraints."
            ]
          },
          "GetSchemaRequest:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the schema to get.",
              " Format is `projects/{project}/schemas/{schema}`."
            ],
            "fieldBehavior": 2
          },
          "GetSchemaRequest:view": {
            "paramName": "view",
            "paramType": ".google.pubsub.v1.SchemaView",
            "comments": [
              " The set of fields to return in the response. If not set, returns a Schema",
              " with `name` and `type`, but not `definition`. Set to `FULL` to retrieve all",
              " fields."
            ]
          },
          "ListSchemasRequest:parent": {
            "paramName": "parent",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to list schemas.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "ListSchemasRequest:view": {
            "paramName": "view",
            "paramType": ".google.pubsub.v1.SchemaView",
            "comments": [
              " The set of Schema fields to return in the response. If not set, returns",
              " Schemas with `name` and `type`, but not `definition`. Set to `FULL` to",
              " retrieve all fields."
            ]
          },
          "ListSchemasRequest:page_size": {
            "paramName": "page_size",
            "paramType": "TYPE_INT32",
            "comments": [
              " Maximum number of schemas to return."
            ]
          },
          "ListSchemasRequest:page_token": {
            "paramName": "page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value returned by the last `ListSchemasResponse`; indicates that",
              " this is a continuation of a prior `ListSchemas` call, and that the",
              " system should return the next page of data."
            ]
          },
          "ListSchemasResponse:schemas": {
            "paramName": "schemas",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The resulting schemas."
            ]
          },
          "ListSchemasResponse:next_page_token": {
            "paramName": "next_page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " If not empty, indicates that there may be more schemas that match the",
              " request; this value should be passed in a new `ListSchemasRequest`."
            ]
          },
          "DeleteSchemaRequest:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. Name of the schema to delete.",
              " Format is `projects/{project}/schemas/{schema}`."
            ],
            "fieldBehavior": 2
          },
          "ValidateSchemaRequest:parent": {
            "paramName": "parent",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to validate schemas.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "ValidateSchemaRequest:schema": {
            "paramName": "schema",
            "paramType": ".google.pubsub.v1.Schema",
            "comments": [
              " Required. The schema object to validate."
            ],
            "fieldBehavior": 2
          },
          "ValidateMessageRequest:parent": {
            "paramName": "parent",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to validate schemas.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "ValidateMessageRequest:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Name of the schema against which to validate.",
              "",
              " Format is `projects/{project}/schemas/{schema}`."
            ]
          },
          "ValidateMessageRequest:schema": {
            "paramName": "schema",
            "paramType": ".google.pubsub.v1.Schema",
            "comments": [
              " Ad-hoc schema against which to validate"
            ]
          },
          "ValidateMessageRequest:message": {
            "paramName": "message",
            "paramType": "TYPE_BYTES",
            "comments": [
              " Message to validate against the provided `schema_spec`."
            ]
          },
          "ValidateMessageRequest:encoding": {
            "paramName": "encoding",
            "paramType": ".google.pubsub.v1.Encoding",
            "comments": [
              " The encoding expected for messages"
            ]
          },
          "Publisher": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " The service that an application uses to manipulate topics, and to send",
              " messages to a topic."
            ]
          },
          "Publisher:CreateTopic": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Creates the given topic with the given name. See the [resource name rules]",
              " (https://cloud.google.com/pubsub/docs/admin#resource_names).",
              ""
            ]
          },
          "Publisher:UpdateTopic": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Updates an existing topic. Note that certain properties of a",
              " topic are not modifiable.",
              ""
            ]
          },
          "Publisher:Publish": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Adds one or more messages to the topic. Returns `NOT_FOUND` if the topic",
              " does not exist.",
              ""
            ]
          },
          "Publisher:GetTopic": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Gets the configuration of a topic.",
              ""
            ]
          },
          "Publisher:ListTopics": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Lists matching topics.",
              ""
            ]
          },
          "Publisher:ListTopicSubscriptions": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Lists the names of the attached subscriptions on this topic.",
              ""
            ]
          },
          "Publisher:ListTopicSnapshots": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Lists the names of the snapshots on this topic. Snapshots are used in",
              " [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,",
              " which allow you to manage message acknowledgments in bulk. That is, you can",
              " set the acknowledgment state of messages in an existing subscription to the",
              " state captured by a snapshot.",
              ""
            ]
          },
          "Publisher:DeleteTopic": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Deletes the topic with the given name. Returns `NOT_FOUND` if the topic",
              " does not exist. After a topic is deleted, a new topic may be created with",
              " the same name; this is an entirely new topic with none of the old",
              " configuration or subscriptions. Existing subscriptions to this topic are",
              " not deleted, but their `topic` field is set to `_deleted-topic_`.",
              ""
            ]
          },
          "Publisher:DetachSubscription": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Detaches a subscription from this topic. All messages retained in the",
              " subscription are dropped. Subsequent `Pull` and `StreamingPull` requests",
              " will return FAILED_PRECONDITION. If the subscription is a push",
              " subscription, pushes to the endpoint will stop.",
              ""
            ]
          },
          "MessageStoragePolicy:allowed_persistence_regions": {
            "paramName": "allowed_persistence_regions",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " A list of IDs of GCP regions where messages that are published to the topic",
              " may be persisted in storage. Messages published by publishers running in",
              " non-allowed GCP regions (or running outside of GCP altogether) will be",
              " routed for storage in one of the allowed regions. An empty list means that",
              " no regions are allowed, and is not a valid configuration."
            ]
          },
          "SchemaSettings:schema": {
            "paramName": "schema",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the schema that messages published should be",
              " validated against. Format is `projects/{project}/schemas/{schema}`. The",
              " value of this field will be `_deleted-schema_` if the schema has been",
              " deleted."
            ],
            "fieldBehavior": 2
          },
          "SchemaSettings:encoding": {
            "paramName": "encoding",
            "paramType": ".google.pubsub.v1.Encoding",
            "comments": [
              " The encoding of messages validated against `schema`."
            ]
          },
          "Topic:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the topic. It must have the format",
              " `\"projects/{project}/topics/{topic}\"`. `{topic}` must start with a letter,",
              " and contain only letters (`[A-Za-z]`), numbers (`[0-9]`), dashes (`-`),",
              " underscores (`_`), periods (`.`), tildes (`~`), plus (`+`) or percent",
              " signs (`%`). It must be between 3 and 255 characters in length, and it",
              " must not start with `\"goog\"`."
            ],
            "fieldBehavior": 2
          },
          "Topic:labels": {
            "paramName": "labels",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " See [Creating and managing labels]",
              " (https://cloud.google.com/pubsub/docs/labels)."
            ]
          },
          "Topic:message_storage_policy": {
            "paramName": "message_storage_policy",
            "paramType": ".google.pubsub.v1.MessageStoragePolicy",
            "comments": [
              " Policy constraining the set of Google Cloud Platform regions where messages",
              " published to the topic may be stored. If not present, then no constraints",
              " are in effect."
            ]
          },
          "Topic:kms_key_name": {
            "paramName": "kms_key_name",
            "paramType": "TYPE_STRING",
            "comments": [
              " The resource name of the Cloud KMS CryptoKey to be used to protect access",
              " to messages published on this topic.",
              "",
              " The expected format is `projects/*/locations/*/keyRings/*/cryptoKeys/*`."
            ]
          },
          "Topic:schema_settings": {
            "paramName": "schema_settings",
            "paramType": ".google.pubsub.v1.SchemaSettings",
            "comments": [
              " Settings for validating messages published against a schema."
            ]
          },
          "Topic:satisfies_pzs": {
            "paramName": "satisfies_pzs",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Reserved for future use. This field is set only in responses from the",
              " server; it is ignored if it is set in any requests."
            ]
          },
          "PubsubMessage:data": {
            "paramName": "data",
            "paramType": "TYPE_BYTES",
            "comments": [
              " The message data field. If this field is empty, the message must contain",
              " at least one attribute."
            ]
          },
          "PubsubMessage:attributes": {
            "paramName": "attributes",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Attributes for this message. If this field is empty, the message must",
              " contain non-empty data. This can be used to filter messages on the",
              " subscription."
            ]
          },
          "PubsubMessage:message_id": {
            "paramName": "message_id",
            "paramType": "TYPE_STRING",
            "comments": [
              " ID of this message, assigned by the server when the message is published.",
              " Guaranteed to be unique within the topic. This value may be read by a",
              " subscriber that receives a `PubsubMessage` via a `Pull` call or a push",
              " delivery. It must not be populated by the publisher in a `Publish` call."
            ]
          },
          "PubsubMessage:publish_time": {
            "paramName": "publish_time",
            "paramType": ".google.protobuf.Timestamp",
            "comments": [
              " The time at which the message was published, populated by the server when",
              " it receives the `Publish` call. It must not be populated by the",
              " publisher in a `Publish` call."
            ]
          },
          "PubsubMessage:ordering_key": {
            "paramName": "ordering_key",
            "paramType": "TYPE_STRING",
            "comments": [
              " If non-empty, identifies related messages for which publish order should be",
              " respected. If a `Subscription` has `enable_message_ordering` set to `true`,",
              " messages published with the same non-empty `ordering_key` value will be",
              " delivered to subscribers in the order in which they are received by the",
              " Pub/Sub system. All `PubsubMessage`s published in a given `PublishRequest`",
              " must specify the same `ordering_key` value."
            ]
          },
          "GetTopicRequest:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the topic to get.",
              " Format is `projects/{project}/topics/{topic}`."
            ],
            "fieldBehavior": 2
          },
          "UpdateTopicRequest:topic": {
            "paramName": "topic",
            "paramType": ".google.pubsub.v1.Topic",
            "comments": [
              " Required. The updated topic object."
            ],
            "fieldBehavior": 2
          },
          "UpdateTopicRequest:update_mask": {
            "paramName": "update_mask",
            "paramType": ".google.protobuf.FieldMask",
            "comments": [
              " Required. Indicates which fields in the provided topic to update. Must be",
              " specified and non-empty. Note that if `update_mask` contains",
              " \"message_storage_policy\" but the `message_storage_policy` is not set in",
              " the `topic` provided above, then the updated value is determined by the",
              " policy configured at the project or organization level."
            ],
            "fieldBehavior": 2
          },
          "PublishRequest:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The messages in the request will be published on this topic.",
              " Format is `projects/{project}/topics/{topic}`."
            ],
            "fieldBehavior": 2
          },
          "PublishRequest:messages": {
            "paramName": "messages",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Required. The messages to publish."
            ],
            "fieldBehavior": 2
          },
          "PublishResponse:message_ids": {
            "paramName": "message_ids",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " The server-assigned ID of each published message, in the same order as",
              " the messages in the request. IDs are guaranteed to be unique within",
              " the topic."
            ]
          },
          "ListTopicsRequest:project": {
            "paramName": "project",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to list topics.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "ListTopicsRequest:page_size": {
            "paramName": "page_size",
            "paramType": "TYPE_INT32",
            "comments": [
              " Maximum number of topics to return."
            ]
          },
          "ListTopicsRequest:page_token": {
            "paramName": "page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value returned by the last `ListTopicsResponse`; indicates that this is",
              " a continuation of a prior `ListTopics` call, and that the system should",
              " return the next page of data."
            ]
          },
          "ListTopicsResponse:topics": {
            "paramName": "topics",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The resulting topics."
            ]
          },
          "ListTopicsResponse:next_page_token": {
            "paramName": "next_page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " If not empty, indicates that there may be more topics that match the",
              " request; this value should be passed in a new `ListTopicsRequest`."
            ]
          },
          "ListTopicSubscriptionsRequest:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the topic that subscriptions are attached to.",
              " Format is `projects/{project}/topics/{topic}`."
            ],
            "fieldBehavior": 2
          },
          "ListTopicSubscriptionsRequest:page_size": {
            "paramName": "page_size",
            "paramType": "TYPE_INT32",
            "comments": [
              " Maximum number of subscription names to return."
            ]
          },
          "ListTopicSubscriptionsRequest:page_token": {
            "paramName": "page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value returned by the last `ListTopicSubscriptionsResponse`; indicates",
              " that this is a continuation of a prior `ListTopicSubscriptions` call, and",
              " that the system should return the next page of data."
            ]
          },
          "ListTopicSubscriptionsResponse:subscriptions": {
            "paramName": "subscriptions",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " The names of subscriptions attached to the topic specified in the request."
            ]
          },
          "ListTopicSubscriptionsResponse:next_page_token": {
            "paramName": "next_page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " If not empty, indicates that there may be more subscriptions that match",
              " the request; this value should be passed in a new",
              " `ListTopicSubscriptionsRequest` to get more subscriptions."
            ]
          },
          "ListTopicSnapshotsRequest:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the topic that snapshots are attached to.",
              " Format is `projects/{project}/topics/{topic}`."
            ],
            "fieldBehavior": 2
          },
          "ListTopicSnapshotsRequest:page_size": {
            "paramName": "page_size",
            "paramType": "TYPE_INT32",
            "comments": [
              " Maximum number of snapshot names to return."
            ]
          },
          "ListTopicSnapshotsRequest:page_token": {
            "paramName": "page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value returned by the last `ListTopicSnapshotsResponse`; indicates",
              " that this is a continuation of a prior `ListTopicSnapshots` call, and",
              " that the system should return the next page of data."
            ]
          },
          "ListTopicSnapshotsResponse:snapshots": {
            "paramName": "snapshots",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " The names of the snapshots that match the request."
            ]
          },
          "ListTopicSnapshotsResponse:next_page_token": {
            "paramName": "next_page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " If not empty, indicates that there may be more snapshots that match",
              " the request; this value should be passed in a new",
              " `ListTopicSnapshotsRequest` to get more snapshots."
            ]
          },
          "DeleteTopicRequest:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. Name of the topic to delete.",
              " Format is `projects/{project}/topics/{topic}`."
            ],
            "fieldBehavior": 2
          },
          "DetachSubscriptionRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription to detach.",
              " Format is `projects/{project}/subscriptions/{subscription}`."
            ],
            "fieldBehavior": 2
          },
          "Subscriber": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " The service that an application uses to manipulate subscriptions and to",
              " consume messages from a subscription via the `Pull` method or by",
              " establishing a bi-directional stream using the `StreamingPull` method."
            ]
          },
          "Subscriber:CreateSubscription": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Creates a subscription to a given topic. See the [resource name rules]",
              " (https://cloud.google.com/pubsub/docs/admin#resource_names).",
              " If the subscription already exists, returns `ALREADY_EXISTS`.",
              " If the corresponding topic doesn't exist, returns `NOT_FOUND`.",
              "",
              " If the name is not provided in the request, the server will assign a random",
              " name for this subscription on the same project as the topic, conforming",
              " to the [resource name format]",
              " (https://cloud.google.com/pubsub/docs/admin#resource_names). The generated",
              " name is populated in the returned Subscription object. Note that for REST",
              " API requests, you must specify a name in the request.",
              ""
            ]
          },
          "Subscriber:GetSubscription": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Gets the configuration details of a subscription.",
              ""
            ]
          },
          "Subscriber:UpdateSubscription": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Updates an existing subscription. Note that certain properties of a",
              " subscription, such as its topic, are not modifiable.",
              ""
            ]
          },
          "Subscriber:ListSubscriptions": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Lists matching subscriptions.",
              ""
            ]
          },
          "Subscriber:DeleteSubscription": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Deletes an existing subscription. All messages retained in the subscription",
              " are immediately dropped. Calls to `Pull` after deletion will return",
              " `NOT_FOUND`. After a subscription is deleted, a new one may be created with",
              " the same name, but the new one has no association with the old",
              " subscription or its topic unless the same topic is specified.",
              ""
            ]
          },
          "Subscriber:ModifyAckDeadline": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Modifies the ack deadline for a specific message. This method is useful",
              " to indicate that more time is needed to process a message by the",
              " subscriber, or to make the message available for redelivery if the",
              " processing was interrupted. Note that this does not modify the",
              " subscription-level `ackDeadlineSeconds` used for subsequent messages.",
              ""
            ]
          },
          "Subscriber:Acknowledge": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Acknowledges the messages associated with the `ack_ids` in the",
              " `AcknowledgeRequest`. The Pub/Sub system can remove the relevant messages",
              " from the subscription.",
              "",
              " Acknowledging a message whose ack deadline has expired may succeed,",
              " but such a message may be redelivered later. Acknowledging a message more",
              " than once will not result in an error.",
              ""
            ]
          },
          "Subscriber:Pull": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Pulls messages from the server. The server may return `UNAVAILABLE` if",
              " there are too many concurrent pull requests pending for the given",
              " subscription.",
              ""
            ]
          },
          "Subscriber:StreamingPull": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Establishes a stream with the server, which sends messages down to the",
              " client. The client streams acknowledgements and ack deadline modifications",
              " back to the server. The server will close the stream and return the status",
              " on any error. The server may close the stream with status `UNAVAILABLE` to",
              " reassign server-side resources, in which case, the client should",
              " re-establish the stream. Flow control can be achieved by configuring the",
              " underlying RPC channel.",
              ""
            ]
          },
          "Subscriber:ModifyPushConfig": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Modifies the `PushConfig` for a specified subscription.",
              "",
              " This may be used to change a push subscription to a pull one (signified by",
              " an empty `PushConfig`) or vice versa, or change the endpoint URL and other",
              " attributes of a push subscription. Messages will accumulate for delivery",
              " continuously through the call regardless of changes to the `PushConfig`.",
              ""
            ]
          },
          "Subscriber:GetSnapshot": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Gets the configuration details of a snapshot. Snapshots are used in",
              " <a href=\"https://cloud.google.com/pubsub/docs/replay-overview\">Seek</a>",
              " operations, which allow you to manage message acknowledgments in bulk. That",
              " is, you can set the acknowledgment state of messages in an existing",
              " subscription to the state captured by a snapshot.",
              ""
            ]
          },
          "Subscriber:ListSnapshots": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Lists the existing snapshots. Snapshots are used in [Seek](",
              " https://cloud.google.com/pubsub/docs/replay-overview) operations, which",
              " allow you to manage message acknowledgments in bulk. That is, you can set",
              " the acknowledgment state of messages in an existing subscription to the",
              " state captured by a snapshot.",
              ""
            ]
          },
          "Subscriber:CreateSnapshot": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Creates a snapshot from the requested subscription. Snapshots are used in",
              " [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,",
              " which allow you to manage message acknowledgments in bulk. That is, you can",
              " set the acknowledgment state of messages in an existing subscription to the",
              " state captured by a snapshot.",
              " If the snapshot already exists, returns `ALREADY_EXISTS`.",
              " If the requested subscription doesn't exist, returns `NOT_FOUND`.",
              " If the backlog in the subscription is too old -- and the resulting snapshot",
              " would expire in less than 1 hour -- then `FAILED_PRECONDITION` is returned.",
              " See also the `Snapshot.expire_time` field. If the name is not provided in",
              " the request, the server will assign a random",
              " name for this snapshot on the same project as the subscription, conforming",
              " to the [resource name format]",
              " (https://cloud.google.com/pubsub/docs/admin#resource_names). The",
              " generated name is populated in the returned Snapshot object. Note that for",
              " REST API requests, you must specify a name in the request.",
              ""
            ]
          },
          "Subscriber:UpdateSnapshot": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Updates an existing snapshot. Snapshots are used in",
              " <a href=\"https://cloud.google.com/pubsub/docs/replay-overview\">Seek</a>",
              " operations, which allow",
              " you to manage message acknowledgments in bulk. That is, you can set the",
              " acknowledgment state of messages in an existing subscription to the state",
              " captured by a snapshot.",
              ""
            ]
          },
          "Subscriber:DeleteSnapshot": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Removes an existing snapshot. Snapshots are used in [Seek]",
              " (https://cloud.google.com/pubsub/docs/replay-overview) operations, which",
              " allow you to manage message acknowledgments in bulk. That is, you can set",
              " the acknowledgment state of messages in an existing subscription to the",
              " state captured by a snapshot.",
              " When the snapshot is deleted, all messages retained in the snapshot",
              " are immediately dropped. After a snapshot is deleted, a new one may be",
              " created with the same name, but the new one has no association with the old",
              " snapshot or its subscription, unless the same subscription is specified.",
              ""
            ]
          },
          "Subscriber:Seek": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Seeks an existing subscription to a point in time or to a given snapshot,",
              " whichever is provided in the request. Snapshots are used in [Seek]",
              " (https://cloud.google.com/pubsub/docs/replay-overview) operations, which",
              " allow you to manage message acknowledgments in bulk. That is, you can set",
              " the acknowledgment state of messages in an existing subscription to the",
              " state captured by a snapshot. Note that both the subscription and the",
              " snapshot must be on the same topic.",
              ""
            ]
          },
          "Subscription:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the subscription. It must have the format",
              " `\"projects/{project}/subscriptions/{subscription}\"`. `{subscription}` must",
              " start with a letter, and contain only letters (`[A-Za-z]`), numbers",
              " (`[0-9]`), dashes (`-`), underscores (`_`), periods (`.`), tildes (`~`),",
              " plus (`+`) or percent signs (`%`). It must be between 3 and 255 characters",
              " in length, and it must not start with `\"goog\"`."
            ],
            "fieldBehavior": 2
          },
          "Subscription:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the topic from which this subscription is receiving",
              " messages. Format is `projects/{project}/topics/{topic}`. The value of this",
              " field will be `_deleted-topic_` if the topic has been deleted."
            ],
            "fieldBehavior": 2
          },
          "Subscription:push_config": {
            "paramName": "push_config",
            "paramType": ".google.pubsub.v1.PushConfig",
            "comments": [
              " If push delivery is used with this subscription, this field is",
              " used to configure it. An empty `pushConfig` signifies that the subscriber",
              " will pull and ack messages using API methods."
            ]
          },
          "Subscription:ack_deadline_seconds": {
            "paramName": "ack_deadline_seconds",
            "paramType": "TYPE_INT32",
            "comments": [
              " The approximate amount of time (on a best-effort basis) Pub/Sub waits for",
              " the subscriber to acknowledge receipt before resending the message. In the",
              " interval after the message is delivered and before it is acknowledged, it",
              " is considered to be <i>outstanding</i>. During that time period, the",
              " message will not be redelivered (on a best-effort basis).",
              "",
              " For pull subscriptions, this value is used as the initial value for the ack",
              " deadline. To override this value for a given message, call",
              " `ModifyAckDeadline` with the corresponding `ack_id` if using",
              " non-streaming pull or send the `ack_id` in a",
              " `StreamingModifyAckDeadlineRequest` if using streaming pull.",
              " The minimum custom deadline you can specify is 10 seconds.",
              " The maximum custom deadline you can specify is 600 seconds (10 minutes).",
              " If this parameter is 0, a default value of 10 seconds is used.",
              "",
              " For push delivery, this value is also used to set the request timeout for",
              " the call to the push endpoint.",
              "",
              " If the subscriber never acknowledges the message, the Pub/Sub",
              " system will eventually redeliver the message."
            ]
          },
          "Subscription:retain_acked_messages": {
            "paramName": "retain_acked_messages",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Indicates whether to retain acknowledged messages. If true, then",
              " messages are not expunged from the subscription's backlog, even if they are",
              " acknowledged, until they fall out of the `message_retention_duration`",
              " window. This must be true if you would like to [Seek to a timestamp]",
              " (https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time)."
            ]
          },
          "Subscription:message_retention_duration": {
            "paramName": "message_retention_duration",
            "paramType": ".google.protobuf.Duration",
            "comments": [
              " How long to retain unacknowledged messages in the subscription's backlog,",
              " from the moment a message is published.",
              " If `retain_acked_messages` is true, then this also configures the retention",
              " of acknowledged messages, and thus configures how far back in time a `Seek`",
              " can be done. Defaults to 7 days. Cannot be more than 7 days or less than 10",
              " minutes."
            ]
          },
          "Subscription:labels": {
            "paramName": "labels",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " See <a href=\"https://cloud.google.com/pubsub/docs/labels\"> Creating and",
              " managing labels</a>."
            ]
          },
          "Subscription:enable_message_ordering": {
            "paramName": "enable_message_ordering",
            "paramType": "TYPE_BOOL",
            "comments": [
              " If true, messages published with the same `ordering_key` in `PubsubMessage`",
              " will be delivered to the subscribers in the order in which they",
              " are received by the Pub/Sub system. Otherwise, they may be delivered in",
              " any order."
            ]
          },
          "Subscription:expiration_policy": {
            "paramName": "expiration_policy",
            "paramType": ".google.pubsub.v1.ExpirationPolicy",
            "comments": [
              " A policy that specifies the conditions for this subscription's expiration.",
              " A subscription is considered active as long as any connected subscriber is",
              " successfully consuming messages from the subscription or is issuing",
              " operations on the subscription. If `expiration_policy` is not set, a",
              " *default policy* with `ttl` of 31 days will be used. The minimum allowed",
              " value for `expiration_policy.ttl` is 1 day."
            ]
          },
          "Subscription:filter": {
            "paramName": "filter",
            "paramType": "TYPE_STRING",
            "comments": [
              " An expression written in the Pub/Sub [filter",
              " language](https://cloud.google.com/pubsub/docs/filtering). If non-empty,",
              " then only `PubsubMessage`s whose `attributes` field matches the filter are",
              " delivered on this subscription. If empty, then no messages are filtered",
              " out."
            ]
          },
          "Subscription:dead_letter_policy": {
            "paramName": "dead_letter_policy",
            "paramType": ".google.pubsub.v1.DeadLetterPolicy",
            "comments": [
              " A policy that specifies the conditions for dead lettering messages in",
              " this subscription. If dead_letter_policy is not set, dead lettering",
              " is disabled.",
              "",
              " The Cloud Pub/Sub service account associated with this subscriptions's",
              " parent project (i.e.,",
              " service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have",
              " permission to Acknowledge() messages on this subscription."
            ]
          },
          "Subscription:retry_policy": {
            "paramName": "retry_policy",
            "paramType": ".google.pubsub.v1.RetryPolicy",
            "comments": [
              " A policy that specifies how Pub/Sub retries message delivery for this",
              " subscription.",
              "",
              " If not set, the default retry policy is applied. This generally implies",
              " that messages will be retried as soon as possible for healthy subscribers.",
              " RetryPolicy will be triggered on NACKs or acknowledgement deadline",
              " exceeded events for a given message."
            ]
          },
          "Subscription:detached": {
            "paramName": "detached",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Indicates whether the subscription is detached from its topic. Detached",
              " subscriptions don't receive messages from their topic and don't retain any",
              " backlog. `Pull` and `StreamingPull` requests will return",
              " FAILED_PRECONDITION. If the subscription is a push subscription, pushes to",
              " the endpoint will not be made."
            ]
          },
          "RetryPolicy:minimum_backoff": {
            "paramName": "minimum_backoff",
            "paramType": ".google.protobuf.Duration",
            "comments": [
              " The minimum delay between consecutive deliveries of a given message.",
              " Value should be between 0 and 600 seconds. Defaults to 10 seconds."
            ]
          },
          "RetryPolicy:maximum_backoff": {
            "paramName": "maximum_backoff",
            "paramType": ".google.protobuf.Duration",
            "comments": [
              " The maximum delay between consecutive deliveries of a given message.",
              " Value should be between 0 and 600 seconds. Defaults to 600 seconds."
            ]
          },
          "DeadLetterPolicy:dead_letter_topic": {
            "paramName": "dead_letter_topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " The name of the topic to which dead letter messages should be published.",
              " Format is `projects/{project}/topics/{topic}`.The Cloud Pub/Sub service",
              " account associated with the enclosing subscription's parent project (i.e.,",
              " service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have",
              " permission to Publish() to this topic.",
              "",
              " The operation will fail if the topic does not exist.",
              " Users should ensure that there is a subscription attached to this topic",
              " since messages published to a topic with no subscriptions are lost."
            ]
          },
          "DeadLetterPolicy:max_delivery_attempts": {
            "paramName": "max_delivery_attempts",
            "paramType": "TYPE_INT32",
            "comments": [
              " The maximum number of delivery attempts for any message. The value must be",
              " between 5 and 100.",
              "",
              " The number of delivery attempts is defined as 1 + (the sum of number of",
              " NACKs and number of times the acknowledgement deadline has been exceeded",
              " for the message).",
              "",
              " A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that",
              " client libraries may automatically extend ack_deadlines.",
              "",
              " This field will be honored on a best effort basis.",
              "",
              " If this parameter is 0, a default value of 5 is used."
            ]
          },
          "ExpirationPolicy:ttl": {
            "paramName": "ttl",
            "paramType": ".google.protobuf.Duration",
            "comments": [
              " Specifies the \"time-to-live\" duration for an associated resource. The",
              " resource expires if it is not active for a period of `ttl`. The definition",
              " of \"activity\" depends on the type of the associated resource. The minimum",
              " and maximum allowed values for `ttl` depend on the type of the associated",
              " resource, as well. If `ttl` is not set, the associated resource never",
              " expires."
            ]
          },
          "PushConfig:push_endpoint": {
            "paramName": "push_endpoint",
            "paramType": "TYPE_STRING",
            "comments": [
              " A URL locating the endpoint to which messages should be pushed.",
              " For example, a Webhook endpoint might use `https://example.com/push`."
            ]
          },
          "PushConfig:attributes": {
            "paramName": "attributes",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Endpoint configuration attributes that can be used to control different",
              " aspects of the message delivery.",
              "",
              " The only currently supported attribute is `x-goog-version`, which you can",
              " use to change the format of the pushed message. This attribute",
              " indicates the version of the data expected by the endpoint. This",
              " controls the shape of the pushed message (i.e., its fields and metadata).",
              "",
              " If not present during the `CreateSubscription` call, it will default to",
              " the version of the Pub/Sub API used to make such call. If not present in a",
              " `ModifyPushConfig` call, its value will not be changed. `GetSubscription`",
              " calls will always return a valid version, even if the subscription was",
              " created without this attribute.",
              "",
              " The only supported values for the `x-goog-version` attribute are:",
              "",
              " * `v1beta1`: uses the push format defined in the v1beta1 Pub/Sub API.",
              " * `v1` or `v1beta2`: uses the push format defined in the v1 Pub/Sub API.",
              "",
              " For example:",
              " <pre><code>attributes { \"x-goog-version\": \"v1\" } </code></pre>"
            ]
          },
          "PushConfig:oidc_token": {
            "paramName": "oidc_token",
            "paramType": ".google.pubsub.v1.PushConfig.OidcToken",
            "comments": [
              " If specified, Pub/Sub will generate and attach an OIDC JWT token as an",
              " `Authorization` header in the HTTP request for every pushed message."
            ]
          },
          "ReceivedMessage:ack_id": {
            "paramName": "ack_id",
            "paramType": "TYPE_STRING",
            "comments": [
              " This ID can be used to acknowledge the received message."
            ]
          },
          "ReceivedMessage:message": {
            "paramName": "message",
            "paramType": ".google.pubsub.v1.PubsubMessage",
            "comments": [
              " The message."
            ]
          },
          "ReceivedMessage:delivery_attempt": {
            "paramName": "delivery_attempt",
            "paramType": "TYPE_INT32",
            "comments": [
              " The approximate number of times that Cloud Pub/Sub has attempted to deliver",
              " the associated message to a subscriber.",
              "",
              " More precisely, this is 1 + (number of NACKs) +",
              " (number of ack_deadline exceeds) for this message.",
              "",
              " A NACK is any call to ModifyAckDeadline with a 0 deadline. An ack_deadline",
              " exceeds event is whenever a message is not acknowledged within",
              " ack_deadline. Note that ack_deadline is initially",
              " Subscription.ackDeadlineSeconds, but may get extended automatically by",
              " the client library.",
              "",
              " Upon the first delivery of a given message, `delivery_attempt` will have a",
              " value of 1. The value is calculated at best effort and is approximate.",
              "",
              " If a DeadLetterPolicy is not set on the subscription, this will be 0."
            ]
          },
          "GetSubscriptionRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the subscription to get.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "UpdateSubscriptionRequest:subscription": {
            "paramName": "subscription",
            "paramType": ".google.pubsub.v1.Subscription",
            "comments": [
              " Required. The updated subscription object."
            ],
            "fieldBehavior": 2
          },
          "UpdateSubscriptionRequest:update_mask": {
            "paramName": "update_mask",
            "paramType": ".google.protobuf.FieldMask",
            "comments": [
              " Required. Indicates which fields in the provided subscription to update.",
              " Must be specified and non-empty."
            ],
            "fieldBehavior": 2
          },
          "ListSubscriptionsRequest:project": {
            "paramName": "project",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to list subscriptions.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "ListSubscriptionsRequest:page_size": {
            "paramName": "page_size",
            "paramType": "TYPE_INT32",
            "comments": [
              " Maximum number of subscriptions to return."
            ]
          },
          "ListSubscriptionsRequest:page_token": {
            "paramName": "page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value returned by the last `ListSubscriptionsResponse`; indicates that",
              " this is a continuation of a prior `ListSubscriptions` call, and that the",
              " system should return the next page of data."
            ]
          },
          "ListSubscriptionsResponse:subscriptions": {
            "paramName": "subscriptions",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The subscriptions that match the request."
            ]
          },
          "ListSubscriptionsResponse:next_page_token": {
            "paramName": "next_page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " If not empty, indicates that there may be more subscriptions that match",
              " the request; this value should be passed in a new",
              " `ListSubscriptionsRequest` to get more subscriptions."
            ]
          },
          "DeleteSubscriptionRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription to delete.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "ModifyPushConfigRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the subscription.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "ModifyPushConfigRequest:push_config": {
            "paramName": "push_config",
            "paramType": ".google.pubsub.v1.PushConfig",
            "comments": [
              " Required. The push configuration for future deliveries.",
              "",
              " An empty `pushConfig` indicates that the Pub/Sub system should",
              " stop pushing messages from the given subscription and allow",
              " messages to be pulled and acknowledged - effectively pausing",
              " the subscription if `Pull` or `StreamingPull` is not called."
            ],
            "fieldBehavior": 2
          },
          "PullRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription from which messages should be pulled.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "PullRequest:return_immediately": {
            "paramName": "return_immediately",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Optional. If this field set to true, the system will respond immediately",
              " even if it there are no messages available to return in the `Pull`",
              " response. Otherwise, the system may wait (for a bounded amount of time)",
              " until at least one message is available, rather than returning no messages.",
              " Warning: setting this field to `true` is discouraged because it adversely",
              " impacts the performance of `Pull` operations. We recommend that users do",
              " not set this field."
            ],
            "fieldBehavior": 1
          },
          "PullRequest:max_messages": {
            "paramName": "max_messages",
            "paramType": "TYPE_INT32",
            "comments": [
              " Required. The maximum number of messages to return for this request. Must",
              " be a positive integer. The Pub/Sub system may return fewer than the number",
              " specified."
            ],
            "fieldBehavior": 2
          },
          "PullResponse:received_messages": {
            "paramName": "received_messages",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Received Pub/Sub messages. The list will be empty if there are no more",
              " messages available in the backlog. For JSON, the response can be entirely",
              " empty. The Pub/Sub system may return fewer than the `maxMessages` requested",
              " even if there are more messages available in the backlog."
            ]
          },
          "ModifyAckDeadlineRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the subscription.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "ModifyAckDeadlineRequest:ack_ids": {
            "paramName": "ack_ids",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Required. List of acknowledgment IDs."
            ],
            "fieldBehavior": 2
          },
          "ModifyAckDeadlineRequest:ack_deadline_seconds": {
            "paramName": "ack_deadline_seconds",
            "paramType": "TYPE_INT32",
            "comments": [
              " Required. The new ack deadline with respect to the time this request was",
              " sent to the Pub/Sub system. For example, if the value is 10, the new ack",
              " deadline will expire 10 seconds after the `ModifyAckDeadline` call was",
              " made. Specifying zero might immediately make the message available for",
              " delivery to another subscriber client. This typically results in an",
              " increase in the rate of message redeliveries (that is, duplicates).",
              " The minimum deadline you can specify is 0 seconds.",
              " The maximum deadline you can specify is 600 seconds (10 minutes)."
            ],
            "fieldBehavior": 2
          },
          "AcknowledgeRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription whose message is being acknowledged.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "AcknowledgeRequest:ack_ids": {
            "paramName": "ack_ids",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Required. The acknowledgment ID for the messages being acknowledged that",
              " was returned by the Pub/Sub system in the `Pull` response. Must not be",
              " empty."
            ],
            "fieldBehavior": 2
          },
          "StreamingPullRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription for which to initialize the new stream. This",
              " must be provided in the first request on the stream, and must not be set in",
              " subsequent requests from client to server.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "StreamingPullRequest:ack_ids": {
            "paramName": "ack_ids",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " List of acknowledgement IDs for acknowledging previously received messages",
              " (received on this stream or a different stream). If an ack ID has expired,",
              " the corresponding message may be redelivered later. Acknowledging a message",
              " more than once will not result in an error. If the acknowledgement ID is",
              " malformed, the stream will be aborted with status `INVALID_ARGUMENT`."
            ]
          },
          "StreamingPullRequest:modify_deadline_seconds": {
            "paramName": "modify_deadline_seconds",
            "paramType": "TYPE_INT32[]",
            "comments": [
              " The list of new ack deadlines for the IDs listed in",
              " `modify_deadline_ack_ids`. The size of this list must be the same as the",
              " size of `modify_deadline_ack_ids`. If it differs the stream will be aborted",
              " with `INVALID_ARGUMENT`. Each element in this list is applied to the",
              " element in the same position in `modify_deadline_ack_ids`. The new ack",
              " deadline is with respect to the time this request was sent to the Pub/Sub",
              " system. Must be >= 0. For example, if the value is 10, the new ack deadline",
              " will expire 10 seconds after this request is received. If the value is 0,",
              " the message is immediately made available for another streaming or",
              " non-streaming pull request. If the value is < 0 (an error), the stream will",
              " be aborted with status `INVALID_ARGUMENT`."
            ]
          },
          "StreamingPullRequest:modify_deadline_ack_ids": {
            "paramName": "modify_deadline_ack_ids",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " List of acknowledgement IDs whose deadline will be modified based on the",
              " corresponding element in `modify_deadline_seconds`. This field can be used",
              " to indicate that more time is needed to process a message by the",
              " subscriber, or to make the message available for redelivery if the",
              " processing was interrupted."
            ]
          },
          "StreamingPullRequest:stream_ack_deadline_seconds": {
            "paramName": "stream_ack_deadline_seconds",
            "paramType": "TYPE_INT32",
            "comments": [
              " Required. The ack deadline to use for the stream. This must be provided in",
              " the first request on the stream, but it can also be updated on subsequent",
              " requests from client to server. The minimum deadline you can specify is 10",
              " seconds. The maximum deadline you can specify is 600 seconds (10 minutes)."
            ],
            "fieldBehavior": 2
          },
          "StreamingPullRequest:client_id": {
            "paramName": "client_id",
            "paramType": "TYPE_STRING",
            "comments": [
              " A unique identifier that is used to distinguish client instances from each",
              " other. Only needs to be provided on the initial request. When a stream",
              " disconnects and reconnects for the same stream, the client_id should be set",
              " to the same value so that state associated with the old stream can be",
              " transferred to the new stream. The same client_id should not be used for",
              " different client instances."
            ]
          },
          "StreamingPullRequest:max_outstanding_messages": {
            "paramName": "max_outstanding_messages",
            "paramType": "TYPE_INT64",
            "comments": [
              " Flow control settings for the maximum number of outstanding messages. When",
              " there are `max_outstanding_messages` or more currently sent to the",
              " streaming pull client that have not yet been acked or nacked, the server",
              " stops sending more messages. The sending of messages resumes once the",
              " number of outstanding messages is less than this value. If the value is",
              " <= 0, there is no limit to the number of outstanding messages. This",
              " property can only be set on the initial StreamingPullRequest. If it is set",
              " on a subsequent request, the stream will be aborted with status",
              " `INVALID_ARGUMENT`."
            ]
          },
          "StreamingPullRequest:max_outstanding_bytes": {
            "paramName": "max_outstanding_bytes",
            "paramType": "TYPE_INT64",
            "comments": [
              " Flow control settings for the maximum number of outstanding bytes. When",
              " there are `max_outstanding_bytes` or more worth of messages currently sent",
              " to the streaming pull client that have not yet been acked or nacked, the",
              " server will stop sending more messages. The sending of messages resumes",
              " once the number of outstanding bytes is less than this value. If the value",
              " is <= 0, there is no limit to the number of outstanding bytes. This",
              " property can only be set on the initial StreamingPullRequest. If it is set",
              " on a subsequent request, the stream will be aborted with status",
              " `INVALID_ARGUMENT`."
            ]
          },
          "StreamingPullResponse:received_messages": {
            "paramName": "received_messages",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Received Pub/Sub messages. This will not be empty."
            ]
          },
          "CreateSnapshotRequest:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. User-provided name for this snapshot. If the name is not provided",
              " in the request, the server will assign a random name for this snapshot on",
              " the same project as the subscription. Note that for REST API requests, you",
              " must specify a name.  See the <a",
              " href=\"https://cloud.google.com/pubsub/docs/admin#resource_names\"> resource",
              " name rules</a>. Format is `projects/{project}/snapshots/{snap}`."
            ],
            "fieldBehavior": 2
          },
          "CreateSnapshotRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription whose backlog the snapshot retains.",
              " Specifically, the created snapshot is guaranteed to retain:",
              "  (a) The existing backlog on the subscription. More precisely, this is",
              "      defined as the messages in the subscription's backlog that are",
              "      unacknowledged upon the successful completion of the",
              "      `CreateSnapshot` request; as well as:",
              "  (b) Any messages published to the subscription's topic following the",
              "      successful completion of the CreateSnapshot request.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "CreateSnapshotRequest:labels": {
            "paramName": "labels",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " See <a href=\"https://cloud.google.com/pubsub/docs/labels\"> Creating and",
              " managing labels</a>."
            ]
          },
          "UpdateSnapshotRequest:snapshot": {
            "paramName": "snapshot",
            "paramType": ".google.pubsub.v1.Snapshot",
            "comments": [
              " Required. The updated snapshot object."
            ],
            "fieldBehavior": 2
          },
          "UpdateSnapshotRequest:update_mask": {
            "paramName": "update_mask",
            "paramType": ".google.protobuf.FieldMask",
            "comments": [
              " Required. Indicates which fields in the provided snapshot to update.",
              " Must be specified and non-empty."
            ],
            "fieldBehavior": 2
          },
          "Snapshot:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " The name of the snapshot."
            ]
          },
          "Snapshot:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " The name of the topic from which this snapshot is retaining messages."
            ]
          },
          "Snapshot:expire_time": {
            "paramName": "expire_time",
            "paramType": ".google.protobuf.Timestamp",
            "comments": [
              " The snapshot is guaranteed to exist up until this time.",
              " A newly-created snapshot expires no later than 7 days from the time of its",
              " creation. Its exact lifetime is determined at creation by the existing",
              " backlog in the source subscription. Specifically, the lifetime of the",
              " snapshot is `7 days - (age of oldest unacked message in the subscription)`.",
              " For example, consider a subscription whose oldest unacked message is 3 days",
              " old. If a snapshot is created from this subscription, the snapshot -- which",
              " will always capture this 3-day-old backlog as long as the snapshot",
              " exists -- will expire in 4 days. The service will refuse to create a",
              " snapshot that would expire in less than 1 hour after creation."
            ]
          },
          "Snapshot:labels": {
            "paramName": "labels",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " See [Creating and managing labels]",
              " (https://cloud.google.com/pubsub/docs/labels)."
            ]
          },
          "GetSnapshotRequest:snapshot": {
            "paramName": "snapshot",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the snapshot to get.",
              " Format is `projects/{project}/snapshots/{snap}`."
            ],
            "fieldBehavior": 2
          },
          "ListSnapshotsRequest:project": {
            "paramName": "project",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to list snapshots.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "ListSnapshotsRequest:page_size": {
            "paramName": "page_size",
            "paramType": "TYPE_INT32",
            "comments": [
              " Maximum number of snapshots to return."
            ]
          },
          "ListSnapshotsRequest:page_token": {
            "paramName": "page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value returned by the last `ListSnapshotsResponse`; indicates that this",
              " is a continuation of a prior `ListSnapshots` call, and that the system",
              " should return the next page of data."
            ]
          },
          "ListSnapshotsResponse:snapshots": {
            "paramName": "snapshots",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The resulting snapshots."
            ]
          },
          "ListSnapshotsResponse:next_page_token": {
            "paramName": "next_page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " If not empty, indicates that there may be more snapshot that match the",
              " request; this value should be passed in a new `ListSnapshotsRequest`."
            ]
          },
          "DeleteSnapshotRequest:snapshot": {
            "paramName": "snapshot",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the snapshot to delete.",
              " Format is `projects/{project}/snapshots/{snap}`."
            ],
            "fieldBehavior": 2
          },
          "SeekRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription to affect."
            ],
            "fieldBehavior": 2
          },
          "SeekRequest:time": {
            "paramName": "time",
            "paramType": ".google.protobuf.Timestamp",
            "comments": [
              " The time to seek to.",
              " Messages retained in the subscription that were published before this",
              " time are marked as acknowledged, and messages retained in the",
              " subscription that were published after this time are marked as",
              " unacknowledged. Note that this operation affects only those messages",
              " retained in the subscription (configured by the combination of",
              " `message_retention_duration` and `retain_acked_messages`). For example,",
              " if `time` corresponds to a point before the message retention",
              " window (or to a point before the system's notion of the subscription",
              " creation time), only retained messages will be marked as unacknowledged,",
              " and already-expunged messages will not be restored."
            ]
          },
          "SeekRequest:snapshot": {
            "paramName": "snapshot",
            "paramType": "TYPE_STRING",
            "comments": [
              " The snapshot to seek to. The snapshot's topic must be the same as that of",
              " the provided subscription.",
              " Format is `projects/{project}/snapshots/{snap}`."
            ]
          },
          "GetPolicyOptions:requested_policy_version": {
            "paramName": "requested_policy_version",
            "paramType": "TYPE_INT32",
            "comments": [
              " Optional. The policy format version to be returned.",
              "",
              " Valid values are 0, 1, and 3. Requests specifying an invalid value will be",
              " rejected.",
              "",
              " Requests for policies with any conditional bindings must specify version 3.",
              " Policies without any conditional bindings may specify any valid value or",
              " leave the field unset."
            ]
          },
          "Expr:expression": {
            "paramName": "expression",
            "paramType": "TYPE_STRING",
            "comments": [
              " Textual representation of an expression in Common Expression Language",
              " syntax."
            ]
          },
          "Expr:title": {
            "paramName": "title",
            "paramType": "TYPE_STRING",
            "comments": [
              " Optional. Title for the expression, i.e. a short string describing",
              " its purpose. This can be used e.g. in UIs which allow to enter the",
              " expression."
            ]
          },
          "Expr:description": {
            "paramName": "description",
            "paramType": "TYPE_STRING",
            "comments": [
              " Optional. Description of the expression. This is a longer text which",
              " describes the expression, e.g. when hovered over it in a UI."
            ]
          },
          "Expr:location": {
            "paramName": "location",
            "paramType": "TYPE_STRING",
            "comments": [
              " Optional. String indicating the location of the expression for error",
              " reporting, e.g. a file name and a position in the file."
            ]
          },
          "Policy:version": {
            "paramName": "version",
            "paramType": "TYPE_INT32",
            "comments": [
              " Specifies the format of the policy.",
              "",
              " Valid values are `0`, `1`, and `3`. Requests that specify an invalid value",
              " are rejected.",
              "",
              " Any operation that affects conditional role bindings must specify version",
              " `3`. This requirement applies to the following operations:",
              "",
              " * Getting a policy that includes a conditional role binding",
              " * Adding a conditional role binding to a policy",
              " * Changing a conditional role binding in a policy",
              " * Removing any role binding, with or without a condition, from a policy",
              "   that includes conditions",
              "",
              " **Important:** If you use IAM Conditions, you must include the `etag` field",
              " whenever you call `setIamPolicy`. If you omit this field, then IAM allows",
              " you to overwrite a version `3` policy with a version `1` policy, and all of",
              " the conditions in the version `3` policy are lost.",
              "",
              " If a policy does not include any conditions, operations on that policy may",
              " specify any valid version or leave the field unset.",
              "",
              " To learn which resources support conditions in their IAM policies, see the",
              " [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies)."
            ]
          },
          "Policy:bindings": {
            "paramName": "bindings",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Associates a list of `members`, or principals, with a `role`. Optionally,",
              " may specify a `condition` that determines how and when the `bindings` are",
              " applied. Each of the `bindings` must contain at least one principal.",
              "",
              " The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250",
              " of these principals can be Google groups. Each occurrence of a principal",
              " counts towards these limits. For example, if the `bindings` grant 50",
              " different roles to `user:alice@example.com`, and not to any other",
              " principal, then you can add another 1,450 principals to the `bindings` in",
              " the `Policy`."
            ]
          },
          "Policy:audit_configs": {
            "paramName": "audit_configs",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Specifies cloud audit logging configuration for this policy."
            ]
          },
          "Policy:etag": {
            "paramName": "etag",
            "paramType": "TYPE_BYTES",
            "comments": [
              " `etag` is used for optimistic concurrency control as a way to help",
              " prevent simultaneous updates of a policy from overwriting each other.",
              " It is strongly suggested that systems make use of the `etag` in the",
              " read-modify-write cycle to perform policy updates in order to avoid race",
              " conditions: An `etag` is returned in the response to `getIamPolicy`, and",
              " systems are expected to put that etag in the request to `setIamPolicy` to",
              " ensure that their change will be applied to the same version of the policy.",
              "",
              " **Important:** If you use IAM Conditions, you must include the `etag` field",
              " whenever you call `setIamPolicy`. If you omit this field, then IAM allows",
              " you to overwrite a version `3` policy with a version `1` policy, and all of",
              " the conditions in the version `3` policy are lost."
            ]
          },
          "Binding:role": {
            "paramName": "role",
            "paramType": "TYPE_STRING",
            "comments": [
              " Role that is assigned to the list of `members`, or principals.",
              " For example, `roles/viewer`, `roles/editor`, or `roles/owner`."
            ]
          },
          "Binding:members": {
            "paramName": "members",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Specifies the principals requesting access for a Cloud Platform resource.",
              " `members` can have the following values:",
              "",
              " * `allUsers`: A special identifier that represents anyone who is",
              "    on the internet; with or without a Google account.",
              "",
              " * `allAuthenticatedUsers`: A special identifier that represents anyone",
              "    who is authenticated with a Google account or a service account.",
              "",
              " * `user:{emailid}`: An email address that represents a specific Google",
              "    account. For example, `alice@example.com` .",
              "",
              "",
              " * `serviceAccount:{emailid}`: An email address that represents a service",
              "    account. For example, `my-other-app@appspot.gserviceaccount.com`.",
              "",
              " * `group:{emailid}`: An email address that represents a Google group.",
              "    For example, `admins@example.com`.",
              "",
              " * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique",
              "    identifier) representing a user that has been recently deleted. For",
              "    example, `alice@example.com?uid=123456789012345678901`. If the user is",
              "    recovered, this value reverts to `user:{emailid}` and the recovered user",
              "    retains the role in the binding.",
              "",
              " * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus",
              "    unique identifier) representing a service account that has been recently",
              "    deleted. For example,",
              "    `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`.",
              "    If the service account is undeleted, this value reverts to",
              "    `serviceAccount:{emailid}` and the undeleted service account retains the",
              "    role in the binding.",
              "",
              " * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique",
              "    identifier) representing a Google group that has been recently",
              "    deleted. For example, `admins@example.com?uid=123456789012345678901`. If",
              "    the group is recovered, this value reverts to `group:{emailid}` and the",
              "    recovered group retains the role in the binding.",
              "",
              "",
              " * `domain:{domain}`: The G Suite domain (primary) that represents all the",
              "    users of that domain. For example, `google.com` or `example.com`.",
              "",
              ""
            ]
          },
          "Binding:condition": {
            "paramName": "condition",
            "paramType": ".google.type.Expr",
            "comments": [
              " The condition that is associated with this binding.",
              "",
              " If the condition evaluates to `true`, then this binding applies to the",
              " current request.",
              "",
              " If the condition evaluates to `false`, then this binding does not apply to",
              " the current request. However, a different role binding might grant the same",
              " role to one or more of the principals in this binding.",
              "",
              " To learn which resources support conditions in their IAM policies, see the",
              " [IAM",
              " documentation](https://cloud.google.com/iam/help/conditions/resource-policies)."
            ]
          },
          "AuditConfig:service": {
            "paramName": "service",
            "paramType": "TYPE_STRING",
            "comments": [
              " Specifies a service that will be enabled for audit logging.",
              " For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.",
              " `allServices` is a special value that covers all services."
            ]
          },
          "AuditConfig:audit_log_configs": {
            "paramName": "audit_log_configs",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The configuration for logging of each type of permission."
            ]
          },
          "AuditLogConfig:log_type": {
            "paramName": "log_type",
            "paramType": ".google.iam.v1.AuditLogConfig.LogType",
            "comments": [
              " The log type that this config enables."
            ]
          },
          "AuditLogConfig:exempted_members": {
            "paramName": "exempted_members",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Specifies the identities that do not cause logging for this type of",
              " permission.",
              " Follows the same format of [Binding.members][google.iam.v1.Binding.members]."
            ]
          },
          "PolicyDelta:binding_deltas": {
            "paramName": "binding_deltas",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The delta for Bindings between two policies."
            ]
          },
          "PolicyDelta:audit_config_deltas": {
            "paramName": "audit_config_deltas",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The delta for AuditConfigs between two policies."
            ]
          },
          "BindingDelta:action": {
            "paramName": "action",
            "paramType": ".google.iam.v1.BindingDelta.Action",
            "comments": [
              " The action that was performed on a Binding.",
              " Required"
            ]
          },
          "BindingDelta:role": {
            "paramName": "role",
            "paramType": "TYPE_STRING",
            "comments": [
              " Role that is assigned to `members`.",
              " For example, `roles/viewer`, `roles/editor`, or `roles/owner`.",
              " Required"
            ]
          },
          "BindingDelta:member": {
            "paramName": "member",
            "paramType": "TYPE_STRING",
            "comments": [
              " A single identity requesting access for a Cloud Platform resource.",
              " Follows the same format of Binding.members.",
              " Required"
            ]
          },
          "BindingDelta:condition": {
            "paramName": "condition",
            "paramType": ".google.type.Expr",
            "comments": [
              " The condition that is associated with this binding."
            ]
          },
          "AuditConfigDelta:action": {
            "paramName": "action",
            "paramType": ".google.iam.v1.AuditConfigDelta.Action",
            "comments": [
              " The action that was performed on an audit configuration in a policy.",
              " Required"
            ]
          },
          "AuditConfigDelta:service": {
            "paramName": "service",
            "paramType": "TYPE_STRING",
            "comments": [
              " Specifies a service that was configured for Cloud Audit Logging.",
              " For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.",
              " `allServices` is a special value that covers all services.",
              " Required"
            ]
          },
          "AuditConfigDelta:exempted_member": {
            "paramName": "exempted_member",
            "paramType": "TYPE_STRING",
            "comments": [
              " A single identity that is exempted from \"data access\" audit",
              " logging for the `service` specified above.",
              " Follows the same format of Binding.members."
            ]
          },
          "AuditConfigDelta:log_type": {
            "paramName": "log_type",
            "paramType": "TYPE_STRING",
            "comments": [
              " Specifies the log_type that was be enabled. ADMIN_ACTIVITY is always",
              " enabled, and cannot be configured.",
              " Required"
            ]
          },
          "IAMPolicy": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " ## API Overview",
              "",
              " Manages Identity and Access Management (IAM) policies.",
              "",
              " Any implementation of an API that offers access control features",
              " implements the google.iam.v1.IAMPolicy interface.",
              "",
              " ## Data model",
              "",
              " Access control is applied when a principal (user or service account), takes",
              " some action on a resource exposed by a service. Resources, identified by",
              " URI-like names, are the unit of access control specification. Service",
              " implementations can choose the granularity of access control and the",
              " supported permissions for their resources.",
              " For example one database service may allow access control to be",
              " specified only at the Table level, whereas another might allow access control",
              " to also be specified at the Column level.",
              "",
              " ## Policy Structure",
              "",
              " See google.iam.v1.Policy",
              "",
              " This is intentionally not a CRUD style API because access control policies",
              " are created and deleted implicitly with the resources to which they are",
              " attached."
            ]
          },
          "IAMPolicy:SetIamPolicy": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Sets the access control policy on the specified resource. Replaces any",
              " existing policy.",
              ""
            ]
          },
          "IAMPolicy:GetIamPolicy": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Gets the access control policy for a resource.",
              " Returns an empty policy if the resource exists and does not have a policy",
              " set.",
              ""
            ]
          },
          "IAMPolicy:TestIamPermissions": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Returns permissions that a caller has on the specified resource.",
              " If the resource does not exist, this will return an empty set of",
              " permissions, not a NOT_FOUND error.",
              "",
              " Note: This operation is designed to be used for building permission-aware",
              " UIs and command-line tools, not for authorization checking. This operation",
              " may \"fail open\" without warning.",
              ""
            ]
          },
          "SetIamPolicyRequest:resource": {
            "paramName": "resource",
            "paramType": "TYPE_STRING",
            "comments": [
              " REQUIRED: The resource for which the policy is being specified.",
              " See the operation documentation for the appropriate value for this field."
            ],
            "fieldBehavior": 2
          },
          "SetIamPolicyRequest:policy": {
            "paramName": "policy",
            "paramType": ".google.iam.v1.Policy",
            "comments": [
              " REQUIRED: The complete policy to be applied to the `resource`. The size of",
              " the policy is limited to a few 10s of KB. An empty policy is a",
              " valid policy but certain Cloud Platform services (such as Projects)",
              " might reject them."
            ],
            "fieldBehavior": 2
          },
          "GetIamPolicyRequest:resource": {
            "paramName": "resource",
            "paramType": "TYPE_STRING",
            "comments": [
              " REQUIRED: The resource for which the policy is being requested.",
              " See the operation documentation for the appropriate value for this field."
            ],
            "fieldBehavior": 2
          },
          "GetIamPolicyRequest:options": {
            "paramName": "options",
            "paramType": ".google.iam.v1.GetPolicyOptions",
            "comments": [
              " OPTIONAL: A `GetPolicyOptions` object for specifying options to",
              " `GetIamPolicy`. This field is only used by Cloud IAM."
            ]
          },
          "TestIamPermissionsRequest:resource": {
            "paramName": "resource",
            "paramType": "TYPE_STRING",
            "comments": [
              " REQUIRED: The resource for which the policy detail is being requested.",
              " See the operation documentation for the appropriate value for this field."
            ],
            "fieldBehavior": 2
          },
          "TestIamPermissionsRequest:permissions": {
            "paramName": "permissions",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " The set of permissions to check for the `resource`. Permissions with",
              " wildcards (such as '*' or 'storage.*') are not allowed. For more",
              " information see",
              " [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions)."
            ],
            "fieldBehavior": 2
          },
          "TestIamPermissionsResponse:permissions": {
            "paramName": "permissions",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " A subset of `TestPermissionsRequest.permissions` that the caller is",
              " allowed."
            ]
          }
        }
      },
      "retryableCodeMap": {
        "uniqueCodesNamesMap": {
          "": "non_idempotent",
          "deadline_exceeded_unavailable": "idempotent"
        },
        "prettyCodesNamesMap": {
          "non_idempotent": [],
          "idempotent": [
            "DEADLINE_EXCEEDED",
            "UNAVAILABLE"
          ]
        },
        "uniqueParamsNamesMap": {
          "94312e9926796a52a8fcbbedaac41972e07ccd1c": "default"
        },
        "prettyParamNamesMap": {
          "default": {
            "initial_retry_delay_millis": 100,
            "retry_delay_multiplier": 1.3,
            "max_retry_delay_millis": 60000,
            "initial_rpc_timeout_millis": 60000,
            "rpc_timeout_multiplier": 1,
            "max_rpc_timeout_millis": 60000,
            "total_timeout_millis": 600000
          }
        },
        "codeEnumMapping": {
          "0": "OK",
          "1": "CANCELLED",
          "2": "UNKNOWN",
          "3": "INVALID_ARGUMENT",
          "4": "DEADLINE_EXCEEDED",
          "5": "NOT_FOUND",
          "6": "ALREADY_EXISTS",
          "7": "PERMISSION_DENIED",
          "8": "RESOURCE_EXHAUSTED",
          "9": "FAILED_PRECONDITION",
          "10": "ABORTED",
          "11": "OUT_OF_RANGE",
          "12": "UNIMPLEMENTED",
          "13": "INTERNAL",
          "14": "UNAVAILABLE",
          "15": "DATA_LOSS",
          "16": "UNAUTHENTICATED"
        }
      },
      "grpcServiceConfig": {},
      "bundleConfigs": [],
      "bundleConfigsMethods": [],
      "simpleMethods": [
        {
          "inputInterface": ".google.pubsub.v1.Topic",
          "outputInterface": ".google.pubsub.v1.Topic",
          "comments": [
            " Creates the given topic with the given name. See the [resource name rules]",
            " (https://cloud.google.com/pubsub/docs/admin#resource_names).",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "CreateTopic",
          "inputType": ".google.pubsub.v1.Topic",
          "outputType": ".google.pubsub.v1.Topic",
          "options": {
            ".google.api.methodSignature": [
              "name"
            ],
            ".google.api.http": {
              "put": "/v1/{name=projects/*/topics/*}",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "name",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the topic. It must have the format",
                " `\"projects/{project}/topics/{topic}\"`. `{topic}` must start with a letter,",
                " and contain only letters (`[A-Za-z]`), numbers (`[0-9]`), dashes (`-`),",
                " underscores (`_`), periods (`.`), tildes (`~`), plus (`+`) or percent",
                " signs (`%`). It must be between 3 and 255 characters in length, and it",
                " must not start with `\"goog\"`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "labels",
              "paramType": "TYPE_MESSAGE[]",
              "comments": [
                " See [Creating and managing labels]",
                " (https://cloud.google.com/pubsub/docs/labels)."
              ]
            },
            {
              "paramName": "message_storage_policy",
              "paramType": ".google.pubsub.v1.MessageStoragePolicy",
              "comments": [
                " Policy constraining the set of Google Cloud Platform regions where messages",
                " published to the topic may be stored. If not present, then no constraints",
                " are in effect."
              ]
            },
            {
              "paramName": "kms_key_name",
              "paramType": "TYPE_STRING",
              "comments": [
                " The resource name of the Cloud KMS CryptoKey to be used to protect access",
                " to messages published on this topic.",
                "",
                " The expected format is `projects/*/locations/*/keyRings/*/cryptoKeys/*`."
              ]
            },
            {
              "paramName": "schema_settings",
              "paramType": ".google.pubsub.v1.SchemaSettings",
              "comments": [
                " Settings for validating messages published against a schema."
              ]
            },
            {
              "paramName": "satisfies_pzs",
              "paramType": "TYPE_BOOL",
              "comments": [
                " Reserved for future use. This field is set only in responses from the",
                " server; it is ignored if it is set in any requests."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "name"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.UpdateTopicRequest",
          "outputInterface": ".google.pubsub.v1.Topic",
          "comments": [
            " Updates an existing topic. Note that certain properties of a",
            " topic are not modifiable.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "UpdateTopic",
          "inputType": ".google.pubsub.v1.UpdateTopicRequest",
          "outputType": ".google.pubsub.v1.Topic",
          "options": {
            ".google.api.http": {
              "patch": "/v1/{topic.name=projects/*/topics/*}",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "topic",
              "paramType": ".google.pubsub.v1.Topic",
              "comments": [
                " Required. The updated topic object."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "update_mask",
              "paramType": ".google.protobuf.FieldMask",
              "comments": [
                " Required. Indicates which fields in the provided topic to update. Must be",
                " specified and non-empty. Note that if `update_mask` contains",
                " \"message_storage_policy\" but the `message_storage_policy` is not set in",
                " the `topic` provided above, then the updated value is determined by the",
                " policy configured at the project or organization level."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "topic",
              "name"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.PublishRequest",
          "outputInterface": ".google.pubsub.v1.PublishResponse",
          "comments": [
            " Adds one or more messages to the topic. Returns `NOT_FOUND` if the topic",
            " does not exist.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "Publish",
          "inputType": ".google.pubsub.v1.PublishRequest",
          "outputType": ".google.pubsub.v1.PublishResponse",
          "options": {
            ".google.api.methodSignature": [
              "topic,messages"
            ],
            ".google.api.http": {
              "post": "/v1/{topic=projects/*/topics/*}:publish",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "topic",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The messages in the request will be published on this topic.",
                " Format is `projects/{project}/topics/{topic}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "messages",
              "paramType": "TYPE_MESSAGE[]",
              "comments": [
                " Required. The messages to publish."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "topic"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.GetTopicRequest",
          "outputInterface": ".google.pubsub.v1.Topic",
          "comments": [
            " Gets the configuration of a topic.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "GetTopic",
          "inputType": ".google.pubsub.v1.GetTopicRequest",
          "outputType": ".google.pubsub.v1.Topic",
          "options": {
            ".google.api.methodSignature": [
              "topic"
            ],
            ".google.api.http": {
              "get": "/v1/{topic=projects/*/topics/*}"
            }
          },
          "paramComment": [
            {
              "paramName": "topic",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the topic to get.",
                " Format is `projects/{project}/topics/{topic}`."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "topic"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.DeleteTopicRequest",
          "outputInterface": ".google.protobuf.Empty",
          "comments": [
            " Deletes the topic with the given name. Returns `NOT_FOUND` if the topic",
            " does not exist. After a topic is deleted, a new topic may be created with",
            " the same name; this is an entirely new topic with none of the old",
            " configuration or subscriptions. Existing subscriptions to this topic are",
            " not deleted, but their `topic` field is set to `_deleted-topic_`.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "DeleteTopic",
          "inputType": ".google.pubsub.v1.DeleteTopicRequest",
          "outputType": ".google.protobuf.Empty",
          "options": {
            ".google.api.methodSignature": [
              "topic"
            ],
            ".google.api.http": {
              "delete": "/v1/{topic=projects/*/topics/*}"
            }
          },
          "paramComment": [
            {
              "paramName": "topic",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. Name of the topic to delete.",
                " Format is `projects/{project}/topics/{topic}`."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "topic"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.DetachSubscriptionRequest",
          "outputInterface": ".google.pubsub.v1.DetachSubscriptionResponse",
          "comments": [
            " Detaches a subscription from this topic. All messages retained in the",
            " subscription are dropped. Subsequent `Pull` and `StreamingPull` requests",
            " will return FAILED_PRECONDITION. If the subscription is a push",
            " subscription, pushes to the endpoint will stop.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "DetachSubscription",
          "inputType": ".google.pubsub.v1.DetachSubscriptionRequest",
          "outputType": ".google.pubsub.v1.DetachSubscriptionResponse",
          "options": {
            ".google.api.http": {
              "post": "/v1/{subscription=projects/*/subscriptions/*}:detach"
            }
          },
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The subscription to detach.",
                " Format is `projects/{project}/subscriptions/{subscription}`."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "subscription"
            ]
          ]
        }
      ],
      "longRunning": [],
      "diregapicLRO": [],
      "streaming": [],
      "clientStreaming": [],
      "serverStreaming": [],
      "bidiStreaming": [],
      "paging": [
        {
          "pagingFieldName": "topics",
          "pagingResponseType": ".google.pubsub.v1.Topic",
          "ignoreMapPagingMethod": false,
          "inputInterface": ".google.pubsub.v1.ListTopicsRequest",
          "outputInterface": ".google.pubsub.v1.ListTopicsResponse",
          "comments": [
            " Lists matching topics.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ListTopics",
          "inputType": ".google.pubsub.v1.ListTopicsRequest",
          "outputType": ".google.pubsub.v1.ListTopicsResponse",
          "options": {
            ".google.api.methodSignature": [
              "project"
            ],
            ".google.api.http": {
              "get": "/v1/{project=projects/*}/topics"
            }
          },
          "paramComment": [
            {
              "paramName": "project",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the project in which to list topics.",
                " Format is `projects/{project-id}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "page_size",
              "paramType": "TYPE_INT32",
              "comments": [
                " Maximum number of topics to return."
              ]
            },
            {
              "paramName": "page_token",
              "paramType": "TYPE_STRING",
              "comments": [
                " The value returned by the last `ListTopicsResponse`; indicates that this is",
                " a continuation of a prior `ListTopics` call, and that the system should",
                " return the next page of data."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "project"
            ]
          ]
        },
        {
          "pagingFieldName": "subscriptions",
          "pagingResponseType": ".google.protobuf.FieldDescriptorProto.Type.TYPE_STRING",
          "ignoreMapPagingMethod": false,
          "inputInterface": ".google.pubsub.v1.ListTopicSubscriptionsRequest",
          "outputInterface": ".google.pubsub.v1.ListTopicSubscriptionsResponse",
          "comments": [
            " Lists the names of the attached subscriptions on this topic.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ListTopicSubscriptions",
          "inputType": ".google.pubsub.v1.ListTopicSubscriptionsRequest",
          "outputType": ".google.pubsub.v1.ListTopicSubscriptionsResponse",
          "options": {
            ".google.api.methodSignature": [
              "topic"
            ],
            ".google.api.http": {
              "get": "/v1/{topic=projects/*/topics/*}/subscriptions"
            }
          },
          "paramComment": [
            {
              "paramName": "topic",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the topic that subscriptions are attached to.",
                " Format is `projects/{project}/topics/{topic}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "page_size",
              "paramType": "TYPE_INT32",
              "comments": [
                " Maximum number of subscription names to return."
              ]
            },
            {
              "paramName": "page_token",
              "paramType": "TYPE_STRING",
              "comments": [
                " The value returned by the last `ListTopicSubscriptionsResponse`; indicates",
                " that this is a continuation of a prior `ListTopicSubscriptions` call, and",
                " that the system should return the next page of data."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "topic"
            ]
          ]
        },
        {
          "pagingFieldName": "snapshots",
          "pagingResponseType": ".google.protobuf.FieldDescriptorProto.Type.TYPE_STRING",
          "ignoreMapPagingMethod": false,
          "inputInterface": ".google.pubsub.v1.ListTopicSnapshotsRequest",
          "outputInterface": ".google.pubsub.v1.ListTopicSnapshotsResponse",
          "comments": [
            " Lists the names of the snapshots on this topic. Snapshots are used in",
            " [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,",
            " which allow you to manage message acknowledgments in bulk. That is, you can",
            " set the acknowledgment state of messages in an existing subscription to the",
            " state captured by a snapshot.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ListTopicSnapshots",
          "inputType": ".google.pubsub.v1.ListTopicSnapshotsRequest",
          "outputType": ".google.pubsub.v1.ListTopicSnapshotsResponse",
          "options": {
            ".google.api.methodSignature": [
              "topic"
            ],
            ".google.api.http": {
              "get": "/v1/{topic=projects/*/topics/*}/snapshots"
            }
          },
          "paramComment": [
            {
              "paramName": "topic",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the topic that snapshots are attached to.",
                " Format is `projects/{project}/topics/{topic}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "page_size",
              "paramType": "TYPE_INT32",
              "comments": [
                " Maximum number of snapshot names to return."
              ]
            },
            {
              "paramName": "page_token",
              "paramType": "TYPE_STRING",
              "comments": [
                " The value returned by the last `ListTopicSnapshotsResponse`; indicates",
                " that this is a continuation of a prior `ListTopicSnapshots` call, and",
                " that the system should return the next page of data."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "topic"
            ]
          ]
        }
      ],
      "hostname": "",
      "port": 0,
      "oauthScopes": [
        "https://www.googleapis.com/auth/cloud-platform",
        "https://www.googleapis.com/auth/pubsub"
      ],
      "pathTemplates": [
        {
          "name": "Project",
          "params": [
            "project"
          ],
          "pattern": [
            "projects/{project}"
          ],
          "style": [],
          "type": "cloudresourcemanager.googleapis.com/Project"
        },
        {
          "name": "project_topic",
          "params": [
            "project",
            "topic"
          ],
          "pattern": [
            "projects/{project}/topics/{topic}"
          ],
          "type": "pubsub.googleapis.com/Topic"
        },
        {
          "name": "Schema",
          "params": [
            "project",
            "schema"
          ],
          "pattern": [
            "projects/{project}/schemas/{schema}"
          ],
          "style": [],
          "type": "pubsub.googleapis.com/Schema"
        },
        {
          "name": "Snapshot",
          "params": [
            "project",
            "snapshot"
          ],
          "pattern": [
            "projects/{project}/snapshots/{snapshot}"
          ],
          "style": [],
          "type": "pubsub.googleapis.com/Snapshot"
        },
        {
          "name": "Subscription",
          "params": [
            "project",
            "subscription"
          ],
          "pattern": [
            "projects/{project}/subscriptions/{subscription}"
          ],
          "style": [],
          "type": "pubsub.googleapis.com/Subscription"
        }
      ]
    },
    {
      "method": [
        {
          "inputInterface": ".google.pubsub.v1.CreateSchemaRequest",
          "outputInterface": ".google.pubsub.v1.Schema",
          "comments": [
            " Creates a schema.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "CreateSchema",
          "inputType": ".google.pubsub.v1.CreateSchemaRequest",
          "outputType": ".google.pubsub.v1.Schema",
          "options": {
            ".google.api.methodSignature": [
              "parent,schema,schema_id"
            ],
            ".google.api.http": {
              "post": "/v1/{parent=projects/*}/schemas",
              "body": "schema"
            }
          },
          "paramComment": [
            {
              "paramName": "parent",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the project in which to create the schema.",
                " Format is `projects/{project-id}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "schema",
              "paramType": ".google.pubsub.v1.Schema",
              "comments": [
                " Required. The schema object to create.",
                "",
                " This schema's `name` parameter is ignored. The schema object returned",
                " by CreateSchema will have a `name` made using the given `parent` and",
                " `schema_id`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "schema_id",
              "paramType": "TYPE_STRING",
              "comments": [
                " The ID to use for the schema, which will become the final component of",
                " the schema's resource name.",
                "",
                " See https://cloud.google.com/pubsub/docs/admin#resource_names for resource",
                " name constraints."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "parent"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.GetSchemaRequest",
          "outputInterface": ".google.pubsub.v1.Schema",
          "comments": [
            " Gets a schema.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "GetSchema",
          "inputType": ".google.pubsub.v1.GetSchemaRequest",
          "outputType": ".google.pubsub.v1.Schema",
          "options": {
            ".google.api.methodSignature": [
              "name"
            ],
            ".google.api.http": {
              "get": "/v1/{name=projects/*/schemas/*}"
            }
          },
          "paramComment": [
            {
              "paramName": "name",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the schema to get.",
                " Format is `projects/{project}/schemas/{schema}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "view",
              "paramType": ".google.pubsub.v1.SchemaView",
              "comments": [
                " The set of fields to return in the response. If not set, returns a Schema",
                " with `name` and `type`, but not `definition`. Set to `FULL` to retrieve all",
                " fields."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "name"
            ]
          ]
        },
        {
          "pagingFieldName": "schemas",
          "pagingResponseType": ".google.pubsub.v1.Schema",
          "ignoreMapPagingMethod": false,
          "inputInterface": ".google.pubsub.v1.ListSchemasRequest",
          "outputInterface": ".google.pubsub.v1.ListSchemasResponse",
          "comments": [
            " Lists schemas in a project.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ListSchemas",
          "inputType": ".google.pubsub.v1.ListSchemasRequest",
          "outputType": ".google.pubsub.v1.ListSchemasResponse",
          "options": {
            ".google.api.methodSignature": [
              "parent"
            ],
            ".google.api.http": {
              "get": "/v1/{parent=projects/*}/schemas"
            }
          },
          "paramComment": [
            {
              "paramName": "parent",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the project in which to list schemas.",
                " Format is `projects/{project-id}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "view",
              "paramType": ".google.pubsub.v1.SchemaView",
              "comments": [
                " The set of Schema fields to return in the response. If not set, returns",
                " Schemas with `name` and `type`, but not `definition`. Set to `FULL` to",
                " retrieve all fields."
              ]
            },
            {
              "paramName": "page_size",
              "paramType": "TYPE_INT32",
              "comments": [
                " Maximum number of schemas to return."
              ]
            },
            {
              "paramName": "page_token",
              "paramType": "TYPE_STRING",
              "comments": [
                " The value returned by the last `ListSchemasResponse`; indicates that",
                " this is a continuation of a prior `ListSchemas` call, and that the",
                " system should return the next page of data."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "parent"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.DeleteSchemaRequest",
          "outputInterface": ".google.protobuf.Empty",
          "comments": [
            " Deletes a schema.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "DeleteSchema",
          "inputType": ".google.pubsub.v1.DeleteSchemaRequest",
          "outputType": ".google.protobuf.Empty",
          "options": {
            ".google.api.methodSignature": [
              "name"
            ],
            ".google.api.http": {
              "delete": "/v1/{name=projects/*/schemas/*}"
            }
          },
          "paramComment": [
            {
              "paramName": "name",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. Name of the schema to delete.",
                " Format is `projects/{project}/schemas/{schema}`."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "name"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.ValidateSchemaRequest",
          "outputInterface": ".google.pubsub.v1.ValidateSchemaResponse",
          "comments": [
            " Validates a schema.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ValidateSchema",
          "inputType": ".google.pubsub.v1.ValidateSchemaRequest",
          "outputType": ".google.pubsub.v1.ValidateSchemaResponse",
          "options": {
            ".google.api.methodSignature": [
              "parent,schema"
            ],
            ".google.api.http": {
              "post": "/v1/{parent=projects/*}/schemas:validate",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "parent",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the project in which to validate schemas.",
                " Format is `projects/{project-id}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "schema",
              "paramType": ".google.pubsub.v1.Schema",
              "comments": [
                " Required. The schema object to validate."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "parent"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.ValidateMessageRequest",
          "outputInterface": ".google.pubsub.v1.ValidateMessageResponse",
          "comments": [
            " Validates a message against a schema.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ValidateMessage",
          "inputType": ".google.pubsub.v1.ValidateMessageRequest",
          "outputType": ".google.pubsub.v1.ValidateMessageResponse",
          "options": {
            ".google.api.http": {
              "post": "/v1/{parent=projects/*}/schemas:validateMessage",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "parent",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the project in which to validate schemas.",
                " Format is `projects/{project-id}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "name",
              "paramType": "TYPE_STRING",
              "comments": [
                " Name of the schema against which to validate.",
                "",
                " Format is `projects/{project}/schemas/{schema}`."
              ]
            },
            {
              "paramName": "schema",
              "paramType": ".google.pubsub.v1.Schema",
              "comments": [
                " Ad-hoc schema against which to validate"
              ]
            },
            {
              "paramName": "message",
              "paramType": "TYPE_BYTES",
              "comments": [
                " Message to validate against the provided `schema_spec`."
              ]
            },
            {
              "paramName": "encoding",
              "paramType": ".google.pubsub.v1.Encoding",
              "comments": [
                " The encoding expected for messages"
              ]
            }
          ],
          "headerRequestParams": [
            [
              "parent"
            ]
          ]
        }
      ],
      "name": "SchemaService",
      "options": {
        ".google.api.defaultHost": "pubsub.googleapis.com",
        ".google.api.oauthScopes": "https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/pubsub"
      },
      "packageName": "google.pubsub.v1",
      "protoFile": "google/pubsub/v1/schema.proto",
      "comments": [
        " Service for doing schema-related operations."
      ],
      "commentsMap": {
        "comments": {
          "Http:rules": {
            "paramName": "rules",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " A list of HTTP configuration rules that apply to individual API methods.",
              "",
              " **NOTE:** All service configuration rules follow \"last one wins\" order."
            ]
          },
          "Http:fully_decode_reserved_expansion": {
            "paramName": "fully_decode_reserved_expansion",
            "paramType": "TYPE_BOOL",
            "comments": [
              " When set to true, URL path parameters will be fully URI-decoded except in",
              " cases of single segment matches in reserved expansion, where \"%2F\" will be",
              " left encoded.",
              "",
              " The default behavior is to not decode RFC 6570 reserved characters in multi",
              " segment matches."
            ]
          },
          "HttpRule:selector": {
            "paramName": "selector",
            "paramType": "TYPE_STRING",
            "comments": [
              " Selects a method to which this rule applies.",
              "",
              " Refer to [selector][google.api.DocumentationRule.selector] for syntax details."
            ]
          },
          "HttpRule:get": {
            "paramName": "get",
            "paramType": "TYPE_STRING",
            "comments": [
              " Maps to HTTP GET. Used for listing and getting information about",
              " resources."
            ]
          },
          "HttpRule:put": {
            "paramName": "put",
            "paramType": "TYPE_STRING",
            "comments": [
              " Maps to HTTP PUT. Used for replacing a resource."
            ]
          },
          "HttpRule:post": {
            "paramName": "post",
            "paramType": "TYPE_STRING",
            "comments": [
              " Maps to HTTP POST. Used for creating a resource or performing an action."
            ]
          },
          "HttpRule:delete": {
            "paramName": "delete",
            "paramType": "TYPE_STRING",
            "comments": [
              " Maps to HTTP DELETE. Used for deleting a resource."
            ]
          },
          "HttpRule:patch": {
            "paramName": "patch",
            "paramType": "TYPE_STRING",
            "comments": [
              " Maps to HTTP PATCH. Used for updating a resource."
            ]
          },
          "HttpRule:custom": {
            "paramName": "custom",
            "paramType": ".google.api.CustomHttpPattern",
            "comments": [
              " The custom pattern is used for specifying an HTTP method that is not",
              " included in the `pattern` field, such as HEAD, or \"*\" to leave the",
              " HTTP method unspecified for this rule. The wild-card rule is useful",
              " for services that provide content to Web (HTML) clients."
            ]
          },
          "HttpRule:body": {
            "paramName": "body",
            "paramType": "TYPE_STRING",
            "comments": [
              " The name of the request field whose value is mapped to the HTTP request",
              " body, or `*` for mapping all request fields not captured by the path",
              " pattern to the HTTP body, or omitted for not having any HTTP request body.",
              "",
              " NOTE: the referred field must be present at the top-level of the request",
              " message type."
            ]
          },
          "HttpRule:response_body": {
            "paramName": "response_body",
            "paramType": "TYPE_STRING",
            "comments": [
              " Optional. The name of the response field whose value is mapped to the HTTP",
              " response body. When omitted, the entire response message will be used",
              " as the HTTP response body.",
              "",
              " NOTE: The referred field must be present at the top-level of the response",
              " message type."
            ]
          },
          "HttpRule:additional_bindings": {
            "paramName": "additional_bindings",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Additional HTTP bindings for the selector. Nested bindings must",
              " not contain an `additional_bindings` field themselves (that is,",
              " the nesting may only be one level deep)."
            ]
          },
          "CustomHttpPattern:kind": {
            "paramName": "kind",
            "paramType": "TYPE_STRING",
            "comments": [
              " The name of this custom HTTP verb."
            ]
          },
          "CustomHttpPattern:path": {
            "paramName": "path",
            "paramType": "TYPE_STRING",
            "comments": [
              " The path matched by this custom verb."
            ]
          },
          "FileDescriptorSet:file": {
            "paramName": "file",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "FileDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "FileDescriptorProto:package": {
            "paramName": "package",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "FileDescriptorProto:dependency": {
            "paramName": "dependency",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Names of files imported by this file."
            ]
          },
          "FileDescriptorProto:public_dependency": {
            "paramName": "public_dependency",
            "paramType": "TYPE_INT32[]",
            "comments": [
              " Indexes of the public imported files in the dependency list above."
            ]
          },
          "FileDescriptorProto:weak_dependency": {
            "paramName": "weak_dependency",
            "paramType": "TYPE_INT32[]",
            "comments": [
              " Indexes of the weak imported files in the dependency list.",
              " For Google-internal migration only. Do not use."
            ]
          },
          "FileDescriptorProto:message_type": {
            "paramName": "message_type",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " All top-level definitions in this file."
            ]
          },
          "FileDescriptorProto:enum_type": {
            "paramName": "enum_type",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "FileDescriptorProto:service": {
            "paramName": "service",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "FileDescriptorProto:extension": {
            "paramName": "extension",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "FileDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.FileOptions",
            "comments": []
          },
          "FileDescriptorProto:source_code_info": {
            "paramName": "source_code_info",
            "paramType": ".google.protobuf.SourceCodeInfo",
            "comments": [
              " This field contains optional information about the original source code.",
              " You may safely remove this entire field without harming runtime",
              " functionality of the descriptors -- the information is needed only by",
              " development tools."
            ]
          },
          "FileDescriptorProto:syntax": {
            "paramName": "syntax",
            "paramType": "TYPE_STRING",
            "comments": [
              " The syntax of the proto file.",
              " The supported values are \"proto2\" and \"proto3\"."
            ]
          },
          "DescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "DescriptorProto:field": {
            "paramName": "field",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:extension": {
            "paramName": "extension",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:nested_type": {
            "paramName": "nested_type",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:enum_type": {
            "paramName": "enum_type",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:extension_range": {
            "paramName": "extension_range",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:oneof_decl": {
            "paramName": "oneof_decl",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.MessageOptions",
            "comments": []
          },
          "DescriptorProto:reserved_range": {
            "paramName": "reserved_range",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:reserved_name": {
            "paramName": "reserved_name",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Reserved field names, which may not be used by fields in the same message.",
              " A given name may only be reserved once."
            ]
          },
          "ExtensionRangeOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "FieldDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "FieldDescriptorProto:number": {
            "paramName": "number",
            "paramType": "TYPE_INT32",
            "comments": []
          },
          "FieldDescriptorProto:label": {
            "paramName": "label",
            "paramType": ".google.protobuf.FieldDescriptorProto.Label",
            "comments": []
          },
          "FieldDescriptorProto:type": {
            "paramName": "type",
            "paramType": ".google.protobuf.FieldDescriptorProto.Type",
            "comments": [
              " If type_name is set, this need not be set.  If both this and type_name",
              " are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP."
            ]
          },
          "FieldDescriptorProto:type_name": {
            "paramName": "type_name",
            "paramType": "TYPE_STRING",
            "comments": [
              " For message and enum types, this is the name of the type.  If the name",
              " starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping",
              " rules are used to find the type (i.e. first the nested types within this",
              " message are searched, then within the parent, on up to the root",
              " namespace)."
            ]
          },
          "FieldDescriptorProto:extendee": {
            "paramName": "extendee",
            "paramType": "TYPE_STRING",
            "comments": [
              " For extensions, this is the name of the type being extended.  It is",
              " resolved in the same manner as type_name."
            ]
          },
          "FieldDescriptorProto:default_value": {
            "paramName": "default_value",
            "paramType": "TYPE_STRING",
            "comments": [
              " For numeric types, contains the original text representation of the value.",
              " For booleans, \"true\" or \"false\".",
              " For strings, contains the default text contents (not escaped in any way).",
              " For bytes, contains the C escaped value.  All bytes >= 128 are escaped."
            ]
          },
          "FieldDescriptorProto:oneof_index": {
            "paramName": "oneof_index",
            "paramType": "TYPE_INT32",
            "comments": [
              " If set, gives the index of a oneof in the containing type's oneof_decl",
              " list.  This field is a member of that oneof."
            ]
          },
          "FieldDescriptorProto:json_name": {
            "paramName": "json_name",
            "paramType": "TYPE_STRING",
            "comments": [
              " JSON name of this field. The value is set by protocol compiler. If the",
              " user has set a \"json_name\" option on this field, that option's value",
              " will be used. Otherwise, it's deduced from the field's name by converting",
              " it to camelCase."
            ]
          },
          "FieldDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.FieldOptions",
            "comments": []
          },
          "FieldDescriptorProto:proto3_optional": {
            "paramName": "proto3_optional",
            "paramType": "TYPE_BOOL",
            "comments": [
              " If true, this is a proto3 \"optional\". When a proto3 field is optional, it",
              " tracks presence regardless of field type.",
              "",
              " When proto3_optional is true, this field must be belong to a oneof to",
              " signal to old proto3 clients that presence is tracked for this field. This",
              " oneof is known as a \"synthetic\" oneof, and this field must be its sole",
              " member (each proto3 optional field gets its own synthetic oneof). Synthetic",
              " oneofs exist in the descriptor only, and do not generate any API. Synthetic",
              " oneofs must be ordered after all \"real\" oneofs.",
              "",
              " For message fields, proto3_optional doesn't create any semantic change,",
              " since non-repeated message fields always track presence. However it still",
              " indicates the semantic detail of whether the user wrote \"optional\" or not.",
              " This can be useful for round-tripping the .proto file. For consistency we",
              " give message fields a synthetic oneof also, even though it is not required",
              " to track presence. This is especially important because the parser can't",
              " tell if a field is a message or an enum, so it must always create a",
              " synthetic oneof.",
              "",
              " Proto2 optional fields do not set this flag, because they already indicate",
              " optional with `LABEL_OPTIONAL`."
            ]
          },
          "OneofDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "OneofDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.OneofOptions",
            "comments": []
          },
          "EnumDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "EnumDescriptorProto:value": {
            "paramName": "value",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "EnumDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.EnumOptions",
            "comments": []
          },
          "EnumDescriptorProto:reserved_range": {
            "paramName": "reserved_range",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Range of reserved numeric values. Reserved numeric values may not be used",
              " by enum values in the same enum declaration. Reserved ranges may not",
              " overlap."
            ]
          },
          "EnumDescriptorProto:reserved_name": {
            "paramName": "reserved_name",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Reserved enum value names, which may not be reused. A given name may only",
              " be reserved once."
            ]
          },
          "EnumValueDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "EnumValueDescriptorProto:number": {
            "paramName": "number",
            "paramType": "TYPE_INT32",
            "comments": []
          },
          "EnumValueDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.EnumValueOptions",
            "comments": []
          },
          "ServiceDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "ServiceDescriptorProto:method": {
            "paramName": "method",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "ServiceDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.ServiceOptions",
            "comments": []
          },
          "MethodDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "MethodDescriptorProto:input_type": {
            "paramName": "input_type",
            "paramType": "TYPE_STRING",
            "comments": [
              " Input and output type names.  These are resolved in the same way as",
              " FieldDescriptorProto.type_name, but must refer to a message type."
            ]
          },
          "MethodDescriptorProto:output_type": {
            "paramName": "output_type",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "MethodDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.MethodOptions",
            "comments": []
          },
          "MethodDescriptorProto:client_streaming": {
            "paramName": "client_streaming",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Identifies if client streams multiple client messages"
            ]
          },
          "MethodDescriptorProto:server_streaming": {
            "paramName": "server_streaming",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Identifies if server streams multiple server messages"
            ]
          },
          "FileOptions:java_package": {
            "paramName": "java_package",
            "paramType": "TYPE_STRING",
            "comments": [
              " Sets the Java package where classes generated from this .proto will be",
              " placed.  By default, the proto package is used, but this is often",
              " inappropriate because proto packages do not normally start with backwards",
              " domain names."
            ]
          },
          "FileOptions:java_outer_classname": {
            "paramName": "java_outer_classname",
            "paramType": "TYPE_STRING",
            "comments": [
              " Controls the name of the wrapper Java class generated for the .proto file.",
              " That class will always contain the .proto file's getDescriptor() method as",
              " well as any top-level extensions defined in the .proto file.",
              " If java_multiple_files is disabled, then all the other classes from the",
              " .proto file will be nested inside the single wrapper outer class."
            ]
          },
          "FileOptions:java_multiple_files": {
            "paramName": "java_multiple_files",
            "paramType": "TYPE_BOOL",
            "comments": [
              " If enabled, then the Java code generator will generate a separate .java",
              " file for each top-level message, enum, and service defined in the .proto",
              " file.  Thus, these types will *not* be nested inside the wrapper class",
              " named by java_outer_classname.  However, the wrapper class will still be",
              " generated to contain the file's getDescriptor() method as well as any",
              " top-level extensions defined in the file."
            ]
          },
          "FileOptions:java_generate_equals_and_hash": {
            "paramName": "java_generate_equals_and_hash",
            "paramType": "TYPE_BOOL",
            "comments": [
              " This option does nothing."
            ]
          },
          "FileOptions:java_string_check_utf8": {
            "paramName": "java_string_check_utf8",
            "paramType": "TYPE_BOOL",
            "comments": [
              " If set true, then the Java2 code generator will generate code that",
              " throws an exception whenever an attempt is made to assign a non-UTF-8",
              " byte sequence to a string field.",
              " Message reflection will do the same.",
              " However, an extension field still accepts non-UTF-8 byte sequences.",
              " This option has no effect on when used with the lite runtime."
            ]
          },
          "FileOptions:optimize_for": {
            "paramName": "optimize_for",
            "paramType": ".google.protobuf.FileOptions.OptimizeMode",
            "comments": []
          },
          "FileOptions:go_package": {
            "paramName": "go_package",
            "paramType": "TYPE_STRING",
            "comments": [
              " Sets the Go package where structs generated from this .proto will be",
              " placed. If omitted, the Go package will be derived from the following:",
              "   - The basename of the package import path, if provided.",
              "   - Otherwise, the package statement in the .proto file, if present.",
              "   - Otherwise, the basename of the .proto file, without extension."
            ]
          },
          "FileOptions:cc_generic_services": {
            "paramName": "cc_generic_services",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Should generic services be generated in each language?  \"Generic\" services",
              " are not specific to any particular RPC system.  They are generated by the",
              " main code generators in each language (without additional plugins).",
              " Generic services were the only kind of service generation supported by",
              " early versions of google.protobuf.",
              "",
              " Generic services are now considered deprecated in favor of using plugins",
              " that generate code specific to your particular RPC system.  Therefore,",
              " these default to false.  Old code which depends on generic services should",
              " explicitly set them to true."
            ]
          },
          "FileOptions:java_generic_services": {
            "paramName": "java_generic_services",
            "paramType": "TYPE_BOOL",
            "comments": []
          },
          "FileOptions:py_generic_services": {
            "paramName": "py_generic_services",
            "paramType": "TYPE_BOOL",
            "comments": []
          },
          "FileOptions:php_generic_services": {
            "paramName": "php_generic_services",
            "paramType": "TYPE_BOOL",
            "comments": []
          },
          "FileOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this file deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for everything in the file, or it will be completely ignored; in the very",
              " least, this is a formalization for deprecating files."
            ]
          },
          "FileOptions:cc_enable_arenas": {
            "paramName": "cc_enable_arenas",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Enables the use of arenas for the proto messages in this file. This applies",
              " only to generated classes for C++."
            ]
          },
          "FileOptions:objc_class_prefix": {
            "paramName": "objc_class_prefix",
            "paramType": "TYPE_STRING",
            "comments": [
              " Sets the objective c class prefix which is prepended to all objective c",
              " generated classes from this .proto. There is no default."
            ]
          },
          "FileOptions:csharp_namespace": {
            "paramName": "csharp_namespace",
            "paramType": "TYPE_STRING",
            "comments": [
              " Namespace for generated classes; defaults to the package."
            ]
          },
          "FileOptions:swift_prefix": {
            "paramName": "swift_prefix",
            "paramType": "TYPE_STRING",
            "comments": [
              " By default Swift generators will take the proto package and CamelCase it",
              " replacing '.' with underscore and use that to prefix the types/symbols",
              " defined. When this options is provided, they will use this value instead",
              " to prefix the types/symbols defined."
            ]
          },
          "FileOptions:php_class_prefix": {
            "paramName": "php_class_prefix",
            "paramType": "TYPE_STRING",
            "comments": [
              " Sets the php class prefix which is prepended to all php generated classes",
              " from this .proto. Default is empty."
            ]
          },
          "FileOptions:php_namespace": {
            "paramName": "php_namespace",
            "paramType": "TYPE_STRING",
            "comments": [
              " Use this option to change the namespace of php generated classes. Default",
              " is empty. When this option is empty, the package name will be used for",
              " determining the namespace."
            ]
          },
          "FileOptions:php_metadata_namespace": {
            "paramName": "php_metadata_namespace",
            "paramType": "TYPE_STRING",
            "comments": [
              " Use this option to change the namespace of php generated metadata classes.",
              " Default is empty. When this option is empty, the proto file name will be",
              " used for determining the namespace."
            ]
          },
          "FileOptions:ruby_package": {
            "paramName": "ruby_package",
            "paramType": "TYPE_STRING",
            "comments": [
              " Use this option to change the package of ruby generated classes. Default",
              " is empty. When this option is not set, the package name will be used for",
              " determining the ruby package."
            ]
          },
          "FileOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here.",
              " See the documentation for the \"Options\" section above."
            ]
          },
          "MessageOptions:message_set_wire_format": {
            "paramName": "message_set_wire_format",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Set true to use the old proto1 MessageSet wire format for extensions.",
              " This is provided for backwards-compatibility with the MessageSet wire",
              " format.  You should not use this for any other reason:  It's less",
              " efficient, has fewer features, and is more complicated.",
              "",
              " The message must be defined exactly as follows:",
              "   message Foo {",
              "     option message_set_wire_format = true;",
              "     extensions 4 to max;",
              "   }",
              " Note that the message cannot have any defined fields; MessageSets only",
              " have extensions.",
              "",
              " All extensions of your type must be singular messages; e.g. they cannot",
              " be int32s, enums, or repeated messages.",
              "",
              " Because this is an option, the above two restrictions are not enforced by",
              " the protocol compiler."
            ]
          },
          "MessageOptions:no_standard_descriptor_accessor": {
            "paramName": "no_standard_descriptor_accessor",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Disables the generation of the standard \"descriptor()\" accessor, which can",
              " conflict with a field of the same name.  This is meant to make migration",
              " from proto1 easier; new code should avoid fields named \"descriptor\"."
            ]
          },
          "MessageOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this message deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for the message, or it will be completely ignored; in the very least,",
              " this is a formalization for deprecating messages."
            ]
          },
          "MessageOptions:map_entry": {
            "paramName": "map_entry",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Whether the message is an automatically generated map entry type for the",
              " maps field.",
              "",
              " For maps fields:",
              "     map<KeyType, ValueType> map_field = 1;",
              " The parsed descriptor looks like:",
              "     message MapFieldEntry {",
              "         option map_entry = true;",
              "         optional KeyType key = 1;",
              "         optional ValueType value = 2;",
              "     }",
              "     repeated MapFieldEntry map_field = 1;",
              "",
              " Implementations may choose not to generate the map_entry=true message, but",
              " use a native map in the target language to hold the keys and values.",
              " The reflection APIs in such implementations still need to work as",
              " if the field is a repeated message field.",
              "",
              " NOTE: Do not set the option in .proto files. Always use the maps syntax",
              " instead. The option should only be implicitly set by the proto compiler",
              " parser."
            ]
          },
          "MessageOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "FieldOptions:ctype": {
            "paramName": "ctype",
            "paramType": ".google.protobuf.FieldOptions.CType",
            "comments": [
              " The ctype option instructs the C++ code generator to use a different",
              " representation of the field than it normally would.  See the specific",
              " options below.  This option is not yet implemented in the open source",
              " release -- sorry, we'll try to include it in a future version!"
            ]
          },
          "FieldOptions:packed": {
            "paramName": "packed",
            "paramType": "TYPE_BOOL",
            "comments": [
              " The packed option can be enabled for repeated primitive fields to enable",
              " a more efficient representation on the wire. Rather than repeatedly",
              " writing the tag and type for each element, the entire array is encoded as",
              " a single length-delimited blob. In proto3, only explicit setting it to",
              " false will avoid using packed encoding."
            ]
          },
          "FieldOptions:jstype": {
            "paramName": "jstype",
            "paramType": ".google.protobuf.FieldOptions.JSType",
            "comments": [
              " The jstype option determines the JavaScript type used for values of the",
              " field.  The option is permitted only for 64 bit integral and fixed types",
              " (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING",
              " is represented as JavaScript string, which avoids loss of precision that",
              " can happen when a large value is converted to a floating point JavaScript.",
              " Specifying JS_NUMBER for the jstype causes the generated JavaScript code to",
              " use the JavaScript \"number\" type.  The behavior of the default option",
              " JS_NORMAL is implementation dependent.",
              "",
              " This option is an enum to permit additional types to be added, e.g.",
              " goog.math.Integer."
            ]
          },
          "FieldOptions:lazy": {
            "paramName": "lazy",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Should this field be parsed lazily?  Lazy applies only to message-type",
              " fields.  It means that when the outer message is initially parsed, the",
              " inner message's contents will not be parsed but instead stored in encoded",
              " form.  The inner message will actually be parsed when it is first accessed.",
              "",
              " This is only a hint.  Implementations are free to choose whether to use",
              " eager or lazy parsing regardless of the value of this option.  However,",
              " setting this option true suggests that the protocol author believes that",
              " using lazy parsing on this field is worth the additional bookkeeping",
              " overhead typically needed to implement it.",
              "",
              " This option does not affect the public interface of any generated code;",
              " all method signatures remain the same.  Furthermore, thread-safety of the",
              " interface is not affected by this option; const methods remain safe to",
              " call from multiple threads concurrently, while non-const methods continue",
              " to require exclusive access.",
              "",
              "",
              " Note that implementations may choose not to check required fields within",
              " a lazy sub-message.  That is, calling IsInitialized() on the outer message",
              " may return true even if the inner message has missing required fields.",
              " This is necessary because otherwise the inner message would have to be",
              " parsed in order to perform the check, defeating the purpose of lazy",
              " parsing.  An implementation which chooses not to check required fields",
              " must be consistent about it.  That is, for any particular sub-message, the",
              " implementation must either *always* check its required fields, or *never*",
              " check its required fields, regardless of whether or not the message has",
              " been parsed.",
              "",
              " As of 2021, lazy does no correctness checks on the byte stream during",
              " parsing.  This may lead to crashes if and when an invalid byte stream is",
              " finally parsed upon access.",
              "",
              " TODO(b/211906113):  Enable validation on lazy fields."
            ]
          },
          "FieldOptions:unverified_lazy": {
            "paramName": "unverified_lazy",
            "paramType": "TYPE_BOOL",
            "comments": [
              " unverified_lazy does no correctness checks on the byte stream. This should",
              " only be used where lazy with verification is prohibitive for performance",
              " reasons."
            ]
          },
          "FieldOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this field deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for accessors, or it will be completely ignored; in the very least, this",
              " is a formalization for deprecating fields."
            ]
          },
          "FieldOptions:weak": {
            "paramName": "weak",
            "paramType": "TYPE_BOOL",
            "comments": [
              " For Google-internal migration only. Do not use."
            ]
          },
          "FieldOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "OneofOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "EnumOptions:allow_alias": {
            "paramName": "allow_alias",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Set this option to true to allow mapping different tag names to the same",
              " value."
            ]
          },
          "EnumOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this enum deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for the enum, or it will be completely ignored; in the very least, this",
              " is a formalization for deprecating enums."
            ]
          },
          "EnumOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "EnumValueOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this enum value deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for the enum value, or it will be completely ignored; in the very least,",
              " this is a formalization for deprecating enum values."
            ]
          },
          "EnumValueOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "ServiceOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this service deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for the service, or it will be completely ignored; in the very least,",
              " this is a formalization for deprecating services."
            ]
          },
          "ServiceOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "MethodOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this method deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for the method, or it will be completely ignored; in the very least,",
              " this is a formalization for deprecating methods."
            ]
          },
          "MethodOptions:idempotency_level": {
            "paramName": "idempotency_level",
            "paramType": ".google.protobuf.MethodOptions.IdempotencyLevel",
            "comments": []
          },
          "MethodOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "UninterpretedOption:name": {
            "paramName": "name",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "UninterpretedOption:identifier_value": {
            "paramName": "identifier_value",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value of the uninterpreted option, in whatever type the tokenizer",
              " identified it as during parsing. Exactly one of these should be set."
            ]
          },
          "UninterpretedOption:positive_int_value": {
            "paramName": "positive_int_value",
            "paramType": "TYPE_UINT64",
            "comments": []
          },
          "UninterpretedOption:negative_int_value": {
            "paramName": "negative_int_value",
            "paramType": "TYPE_INT64",
            "comments": []
          },
          "UninterpretedOption:double_value": {
            "paramName": "double_value",
            "paramType": "TYPE_DOUBLE",
            "comments": []
          },
          "UninterpretedOption:string_value": {
            "paramName": "string_value",
            "paramType": "TYPE_BYTES",
            "comments": []
          },
          "UninterpretedOption:aggregate_value": {
            "paramName": "aggregate_value",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "SourceCodeInfo:location": {
            "paramName": "location",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " A Location identifies a piece of source code in a .proto file which",
              " corresponds to a particular definition.  This information is intended",
              " to be useful to IDEs, code indexers, documentation generators, and similar",
              " tools.",
              "",
              " For example, say we have a file like:",
              "   message Foo {",
              "     optional string foo = 1;",
              "   }",
              " Let's look at just the field definition:",
              "   optional string foo = 1;",
              "   ^       ^^     ^^  ^  ^^^",
              "   a       bc     de  f  ghi",
              " We have the following locations:",
              "   span   path               represents",
              "   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.",
              "   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).",
              "   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).",
              "   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).",
              "   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).",
              "",
              " Notes:",
              " - A location may refer to a repeated field itself (i.e. not to any",
              "   particular index within it).  This is used whenever a set of elements are",
              "   logically enclosed in a single code segment.  For example, an entire",
              "   extend block (possibly containing multiple extension definitions) will",
              "   have an outer location whose path refers to the \"extensions\" repeated",
              "   field without an index.",
              " - Multiple locations may have the same path.  This happens when a single",
              "   logical declaration is spread out across multiple places.  The most",
              "   obvious example is the \"extend\" block again -- there may be multiple",
              "   extend blocks in the same scope, each of which will have the same path.",
              " - A location's span is not always a subset of its parent's span.  For",
              "   example, the \"extendee\" of an extension declaration appears at the",
              "   beginning of the \"extend\" block and is shared by all extensions within",
              "   the block.",
              " - Just because a location's span is a subset of some other location's span",
              "   does not mean that it is a descendant.  For example, a \"group\" defines",
              "   both a type and a field in a single declaration.  Thus, the locations",
              "   corresponding to the type and field and their components will overlap.",
              " - Code which tries to interpret locations should probably be designed to",
              "   ignore those that it doesn't understand, as more types of locations could",
              "   be recorded in the future."
            ]
          },
          "GeneratedCodeInfo:annotation": {
            "paramName": "annotation",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " An Annotation connects some span of text in generated code to an element",
              " of its generating .proto file."
            ]
          },
          "ResourceDescriptor:type": {
            "paramName": "type",
            "paramType": "TYPE_STRING",
            "comments": [
              " The resource type. It must be in the format of",
              " {service_name}/{resource_type_kind}. The `resource_type_kind` must be",
              " singular and must not include version numbers.",
              "",
              " Example: `storage.googleapis.com/Bucket`",
              "",
              " The value of the resource_type_kind must follow the regular expression",
              " /[A-Za-z][a-zA-Z0-9]+/. It should start with an upper case character and",
              " should use PascalCase (UpperCamelCase). The maximum number of",
              " characters allowed for the `resource_type_kind` is 100."
            ]
          },
          "ResourceDescriptor:pattern": {
            "paramName": "pattern",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Optional. The relative resource name pattern associated with this resource",
              " type. The DNS prefix of the full resource name shouldn't be specified here.",
              "",
              " The path pattern must follow the syntax, which aligns with HTTP binding",
              " syntax:",
              "",
              "     Template = Segment { \"/\" Segment } ;",
              "     Segment = LITERAL | Variable ;",
              "     Variable = \"{\" LITERAL \"}\" ;",
              "",
              " Examples:",
              "",
              "     - \"projects/{project}/topics/{topic}\"",
              "     - \"projects/{project}/knowledgeBases/{knowledge_base}\"",
              "",
              " The components in braces correspond to the IDs for each resource in the",
              " hierarchy. It is expected that, if multiple patterns are provided,",
              " the same component name (e.g. \"project\") refers to IDs of the same",
              " type of resource."
            ]
          },
          "ResourceDescriptor:name_field": {
            "paramName": "name_field",
            "paramType": "TYPE_STRING",
            "comments": [
              " Optional. The field on the resource that designates the resource name",
              " field. If omitted, this is assumed to be \"name\"."
            ]
          },
          "ResourceDescriptor:history": {
            "paramName": "history",
            "paramType": ".google.api.ResourceDescriptor.History",
            "comments": [
              " Optional. The historical or future-looking state of the resource pattern.",
              "",
              " Example:",
              "",
              "     // The InspectTemplate message originally only supported resource",
              "     // names with organization, and project was added later.",
              "     message InspectTemplate {",
              "       option (google.api.resource) = {",
              "         type: \"dlp.googleapis.com/InspectTemplate\"",
              "         pattern:",
              "         \"organizations/{organization}/inspectTemplates/{inspect_template}\"",
              "         pattern: \"projects/{project}/inspectTemplates/{inspect_template}\"",
              "         history: ORIGINALLY_SINGLE_PATTERN",
              "       };",
              "     }"
            ]
          },
          "ResourceDescriptor:plural": {
            "paramName": "plural",
            "paramType": "TYPE_STRING",
            "comments": [
              " The plural name used in the resource name and permission names, such as",
              " 'projects' for the resource name of 'projects/{project}' and the permission",
              " name of 'cloudresourcemanager.googleapis.com/projects.get'. It is the same",
              " concept of the `plural` field in k8s CRD spec",
              " https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/",
              "",
              " Note: The plural form is required even for singleton resources. See",
              " https://aip.dev/156"
            ]
          },
          "ResourceDescriptor:singular": {
            "paramName": "singular",
            "paramType": "TYPE_STRING",
            "comments": [
              " The same concept of the `singular` field in k8s CRD spec",
              " https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/",
              " Such as \"project\" for the `resourcemanager.googleapis.com/Project` type."
            ]
          },
          "ResourceDescriptor:style": {
            "paramName": "style",
            "paramType": "TYPE_ENUM[]",
            "comments": [
              " Style flag(s) for this resource.",
              " These indicate that a resource is expected to conform to a given",
              " style. See the specific style flags for additional information."
            ]
          },
          "ResourceReference:type": {
            "paramName": "type",
            "paramType": "TYPE_STRING",
            "comments": [
              " The resource type that the annotated field references.",
              "",
              " Example:",
              "",
              "     message Subscription {",
              "       string topic = 2 [(google.api.resource_reference) = {",
              "         type: \"pubsub.googleapis.com/Topic\"",
              "       }];",
              "     }",
              "",
              " Occasionally, a field may reference an arbitrary resource. In this case,",
              " APIs use the special value * in their resource reference.",
              "",
              " Example:",
              "",
              "     message GetIamPolicyRequest {",
              "       string resource = 2 [(google.api.resource_reference) = {",
              "         type: \"*\"",
              "       }];",
              "     }"
            ]
          },
          "ResourceReference:child_type": {
            "paramName": "child_type",
            "paramType": "TYPE_STRING",
            "comments": [
              " The resource type of a child collection that the annotated field",
              " references. This is useful for annotating the `parent` field that",
              " doesn't have a fixed resource type.",
              "",
              " Example:",
              "",
              "     message ListLogEntriesRequest {",
              "       string parent = 1 [(google.api.resource_reference) = {",
              "         child_type: \"logging.googleapis.com/LogEntry\"",
              "       };",
              "     }"
            ]
          },
          "Duration:seconds": {
            "paramName": "seconds",
            "paramType": "TYPE_INT64",
            "comments": [
              " Signed seconds of the span of time. Must be from -315,576,000,000",
              " to +315,576,000,000 inclusive. Note: these bounds are computed from:",
              " 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
            ]
          },
          "Duration:nanos": {
            "paramName": "nanos",
            "paramType": "TYPE_INT32",
            "comments": [
              " Signed fractions of a second at nanosecond resolution of the span",
              " of time. Durations less than one second are represented with a 0",
              " `seconds` field and a positive or negative `nanos` field. For durations",
              " of one second or more, a non-zero value for the `nanos` field must be",
              " of the same sign as the `seconds` field. Must be from -999,999,999",
              " to +999,999,999 inclusive."
            ]
          },
          "FieldMask:paths": {
            "paramName": "paths",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " The set of field mask paths."
            ]
          },
          "Timestamp:seconds": {
            "paramName": "seconds",
            "paramType": "TYPE_INT64",
            "comments": [
              " Represents seconds of UTC time since Unix epoch",
              " 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to",
              " 9999-12-31T23:59:59Z inclusive."
            ]
          },
          "Timestamp:nanos": {
            "paramName": "nanos",
            "paramType": "TYPE_INT32",
            "comments": [
              " Non-negative fractions of a second at nanosecond resolution. Negative",
              " second values with fractions must still have non-negative nanos values",
              " that count forward in time. Must be from 0 to 999,999,999",
              " inclusive."
            ]
          },
          "SchemaService": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Service for doing schema-related operations."
            ]
          },
          "SchemaService:CreateSchema": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Creates a schema.",
              ""
            ]
          },
          "SchemaService:GetSchema": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Gets a schema.",
              ""
            ]
          },
          "SchemaService:ListSchemas": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Lists schemas in a project.",
              ""
            ]
          },
          "SchemaService:DeleteSchema": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Deletes a schema.",
              ""
            ]
          },
          "SchemaService:ValidateSchema": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Validates a schema.",
              ""
            ]
          },
          "SchemaService:ValidateMessage": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Validates a message against a schema.",
              ""
            ]
          },
          "Schema:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. Name of the schema.",
              " Format is `projects/{project}/schemas/{schema}`."
            ],
            "fieldBehavior": 2
          },
          "Schema:type": {
            "paramName": "type",
            "paramType": ".google.pubsub.v1.Schema.Type",
            "comments": [
              " The type of the schema definition."
            ]
          },
          "Schema:definition": {
            "paramName": "definition",
            "paramType": "TYPE_STRING",
            "comments": [
              " The definition of the schema. This should contain a string representing",
              " the full definition of the schema that is a valid schema definition of",
              " the type specified in `type`."
            ]
          },
          "CreateSchemaRequest:parent": {
            "paramName": "parent",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to create the schema.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "CreateSchemaRequest:schema": {
            "paramName": "schema",
            "paramType": ".google.pubsub.v1.Schema",
            "comments": [
              " Required. The schema object to create.",
              "",
              " This schema's `name` parameter is ignored. The schema object returned",
              " by CreateSchema will have a `name` made using the given `parent` and",
              " `schema_id`."
            ],
            "fieldBehavior": 2
          },
          "CreateSchemaRequest:schema_id": {
            "paramName": "schema_id",
            "paramType": "TYPE_STRING",
            "comments": [
              " The ID to use for the schema, which will become the final component of",
              " the schema's resource name.",
              "",
              " See https://cloud.google.com/pubsub/docs/admin#resource_names for resource",
              " name constraints."
            ]
          },
          "GetSchemaRequest:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the schema to get.",
              " Format is `projects/{project}/schemas/{schema}`."
            ],
            "fieldBehavior": 2
          },
          "GetSchemaRequest:view": {
            "paramName": "view",
            "paramType": ".google.pubsub.v1.SchemaView",
            "comments": [
              " The set of fields to return in the response. If not set, returns a Schema",
              " with `name` and `type`, but not `definition`. Set to `FULL` to retrieve all",
              " fields."
            ]
          },
          "ListSchemasRequest:parent": {
            "paramName": "parent",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to list schemas.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "ListSchemasRequest:view": {
            "paramName": "view",
            "paramType": ".google.pubsub.v1.SchemaView",
            "comments": [
              " The set of Schema fields to return in the response. If not set, returns",
              " Schemas with `name` and `type`, but not `definition`. Set to `FULL` to",
              " retrieve all fields."
            ]
          },
          "ListSchemasRequest:page_size": {
            "paramName": "page_size",
            "paramType": "TYPE_INT32",
            "comments": [
              " Maximum number of schemas to return."
            ]
          },
          "ListSchemasRequest:page_token": {
            "paramName": "page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value returned by the last `ListSchemasResponse`; indicates that",
              " this is a continuation of a prior `ListSchemas` call, and that the",
              " system should return the next page of data."
            ]
          },
          "ListSchemasResponse:schemas": {
            "paramName": "schemas",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The resulting schemas."
            ]
          },
          "ListSchemasResponse:next_page_token": {
            "paramName": "next_page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " If not empty, indicates that there may be more schemas that match the",
              " request; this value should be passed in a new `ListSchemasRequest`."
            ]
          },
          "DeleteSchemaRequest:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. Name of the schema to delete.",
              " Format is `projects/{project}/schemas/{schema}`."
            ],
            "fieldBehavior": 2
          },
          "ValidateSchemaRequest:parent": {
            "paramName": "parent",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to validate schemas.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "ValidateSchemaRequest:schema": {
            "paramName": "schema",
            "paramType": ".google.pubsub.v1.Schema",
            "comments": [
              " Required. The schema object to validate."
            ],
            "fieldBehavior": 2
          },
          "ValidateMessageRequest:parent": {
            "paramName": "parent",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to validate schemas.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "ValidateMessageRequest:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Name of the schema against which to validate.",
              "",
              " Format is `projects/{project}/schemas/{schema}`."
            ]
          },
          "ValidateMessageRequest:schema": {
            "paramName": "schema",
            "paramType": ".google.pubsub.v1.Schema",
            "comments": [
              " Ad-hoc schema against which to validate"
            ]
          },
          "ValidateMessageRequest:message": {
            "paramName": "message",
            "paramType": "TYPE_BYTES",
            "comments": [
              " Message to validate against the provided `schema_spec`."
            ]
          },
          "ValidateMessageRequest:encoding": {
            "paramName": "encoding",
            "paramType": ".google.pubsub.v1.Encoding",
            "comments": [
              " The encoding expected for messages"
            ]
          },
          "Publisher": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " The service that an application uses to manipulate topics, and to send",
              " messages to a topic."
            ]
          },
          "Publisher:CreateTopic": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Creates the given topic with the given name. See the [resource name rules]",
              " (https://cloud.google.com/pubsub/docs/admin#resource_names).",
              ""
            ]
          },
          "Publisher:UpdateTopic": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Updates an existing topic. Note that certain properties of a",
              " topic are not modifiable.",
              ""
            ]
          },
          "Publisher:Publish": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Adds one or more messages to the topic. Returns `NOT_FOUND` if the topic",
              " does not exist.",
              ""
            ]
          },
          "Publisher:GetTopic": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Gets the configuration of a topic.",
              ""
            ]
          },
          "Publisher:ListTopics": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Lists matching topics.",
              ""
            ]
          },
          "Publisher:ListTopicSubscriptions": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Lists the names of the attached subscriptions on this topic.",
              ""
            ]
          },
          "Publisher:ListTopicSnapshots": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Lists the names of the snapshots on this topic. Snapshots are used in",
              " [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,",
              " which allow you to manage message acknowledgments in bulk. That is, you can",
              " set the acknowledgment state of messages in an existing subscription to the",
              " state captured by a snapshot.",
              ""
            ]
          },
          "Publisher:DeleteTopic": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Deletes the topic with the given name. Returns `NOT_FOUND` if the topic",
              " does not exist. After a topic is deleted, a new topic may be created with",
              " the same name; this is an entirely new topic with none of the old",
              " configuration or subscriptions. Existing subscriptions to this topic are",
              " not deleted, but their `topic` field is set to `_deleted-topic_`.",
              ""
            ]
          },
          "Publisher:DetachSubscription": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Detaches a subscription from this topic. All messages retained in the",
              " subscription are dropped. Subsequent `Pull` and `StreamingPull` requests",
              " will return FAILED_PRECONDITION. If the subscription is a push",
              " subscription, pushes to the endpoint will stop.",
              ""
            ]
          },
          "MessageStoragePolicy:allowed_persistence_regions": {
            "paramName": "allowed_persistence_regions",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " A list of IDs of GCP regions where messages that are published to the topic",
              " may be persisted in storage. Messages published by publishers running in",
              " non-allowed GCP regions (or running outside of GCP altogether) will be",
              " routed for storage in one of the allowed regions. An empty list means that",
              " no regions are allowed, and is not a valid configuration."
            ]
          },
          "SchemaSettings:schema": {
            "paramName": "schema",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the schema that messages published should be",
              " validated against. Format is `projects/{project}/schemas/{schema}`. The",
              " value of this field will be `_deleted-schema_` if the schema has been",
              " deleted."
            ],
            "fieldBehavior": 2
          },
          "SchemaSettings:encoding": {
            "paramName": "encoding",
            "paramType": ".google.pubsub.v1.Encoding",
            "comments": [
              " The encoding of messages validated against `schema`."
            ]
          },
          "Topic:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the topic. It must have the format",
              " `\"projects/{project}/topics/{topic}\"`. `{topic}` must start with a letter,",
              " and contain only letters (`[A-Za-z]`), numbers (`[0-9]`), dashes (`-`),",
              " underscores (`_`), periods (`.`), tildes (`~`), plus (`+`) or percent",
              " signs (`%`). It must be between 3 and 255 characters in length, and it",
              " must not start with `\"goog\"`."
            ],
            "fieldBehavior": 2
          },
          "Topic:labels": {
            "paramName": "labels",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " See [Creating and managing labels]",
              " (https://cloud.google.com/pubsub/docs/labels)."
            ]
          },
          "Topic:message_storage_policy": {
            "paramName": "message_storage_policy",
            "paramType": ".google.pubsub.v1.MessageStoragePolicy",
            "comments": [
              " Policy constraining the set of Google Cloud Platform regions where messages",
              " published to the topic may be stored. If not present, then no constraints",
              " are in effect."
            ]
          },
          "Topic:kms_key_name": {
            "paramName": "kms_key_name",
            "paramType": "TYPE_STRING",
            "comments": [
              " The resource name of the Cloud KMS CryptoKey to be used to protect access",
              " to messages published on this topic.",
              "",
              " The expected format is `projects/*/locations/*/keyRings/*/cryptoKeys/*`."
            ]
          },
          "Topic:schema_settings": {
            "paramName": "schema_settings",
            "paramType": ".google.pubsub.v1.SchemaSettings",
            "comments": [
              " Settings for validating messages published against a schema."
            ]
          },
          "Topic:satisfies_pzs": {
            "paramName": "satisfies_pzs",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Reserved for future use. This field is set only in responses from the",
              " server; it is ignored if it is set in any requests."
            ]
          },
          "PubsubMessage:data": {
            "paramName": "data",
            "paramType": "TYPE_BYTES",
            "comments": [
              " The message data field. If this field is empty, the message must contain",
              " at least one attribute."
            ]
          },
          "PubsubMessage:attributes": {
            "paramName": "attributes",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Attributes for this message. If this field is empty, the message must",
              " contain non-empty data. This can be used to filter messages on the",
              " subscription."
            ]
          },
          "PubsubMessage:message_id": {
            "paramName": "message_id",
            "paramType": "TYPE_STRING",
            "comments": [
              " ID of this message, assigned by the server when the message is published.",
              " Guaranteed to be unique within the topic. This value may be read by a",
              " subscriber that receives a `PubsubMessage` via a `Pull` call or a push",
              " delivery. It must not be populated by the publisher in a `Publish` call."
            ]
          },
          "PubsubMessage:publish_time": {
            "paramName": "publish_time",
            "paramType": ".google.protobuf.Timestamp",
            "comments": [
              " The time at which the message was published, populated by the server when",
              " it receives the `Publish` call. It must not be populated by the",
              " publisher in a `Publish` call."
            ]
          },
          "PubsubMessage:ordering_key": {
            "paramName": "ordering_key",
            "paramType": "TYPE_STRING",
            "comments": [
              " If non-empty, identifies related messages for which publish order should be",
              " respected. If a `Subscription` has `enable_message_ordering` set to `true`,",
              " messages published with the same non-empty `ordering_key` value will be",
              " delivered to subscribers in the order in which they are received by the",
              " Pub/Sub system. All `PubsubMessage`s published in a given `PublishRequest`",
              " must specify the same `ordering_key` value."
            ]
          },
          "GetTopicRequest:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the topic to get.",
              " Format is `projects/{project}/topics/{topic}`."
            ],
            "fieldBehavior": 2
          },
          "UpdateTopicRequest:topic": {
            "paramName": "topic",
            "paramType": ".google.pubsub.v1.Topic",
            "comments": [
              " Required. The updated topic object."
            ],
            "fieldBehavior": 2
          },
          "UpdateTopicRequest:update_mask": {
            "paramName": "update_mask",
            "paramType": ".google.protobuf.FieldMask",
            "comments": [
              " Required. Indicates which fields in the provided topic to update. Must be",
              " specified and non-empty. Note that if `update_mask` contains",
              " \"message_storage_policy\" but the `message_storage_policy` is not set in",
              " the `topic` provided above, then the updated value is determined by the",
              " policy configured at the project or organization level."
            ],
            "fieldBehavior": 2
          },
          "PublishRequest:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The messages in the request will be published on this topic.",
              " Format is `projects/{project}/topics/{topic}`."
            ],
            "fieldBehavior": 2
          },
          "PublishRequest:messages": {
            "paramName": "messages",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Required. The messages to publish."
            ],
            "fieldBehavior": 2
          },
          "PublishResponse:message_ids": {
            "paramName": "message_ids",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " The server-assigned ID of each published message, in the same order as",
              " the messages in the request. IDs are guaranteed to be unique within",
              " the topic."
            ]
          },
          "ListTopicsRequest:project": {
            "paramName": "project",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to list topics.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "ListTopicsRequest:page_size": {
            "paramName": "page_size",
            "paramType": "TYPE_INT32",
            "comments": [
              " Maximum number of topics to return."
            ]
          },
          "ListTopicsRequest:page_token": {
            "paramName": "page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value returned by the last `ListTopicsResponse`; indicates that this is",
              " a continuation of a prior `ListTopics` call, and that the system should",
              " return the next page of data."
            ]
          },
          "ListTopicsResponse:topics": {
            "paramName": "topics",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The resulting topics."
            ]
          },
          "ListTopicsResponse:next_page_token": {
            "paramName": "next_page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " If not empty, indicates that there may be more topics that match the",
              " request; this value should be passed in a new `ListTopicsRequest`."
            ]
          },
          "ListTopicSubscriptionsRequest:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the topic that subscriptions are attached to.",
              " Format is `projects/{project}/topics/{topic}`."
            ],
            "fieldBehavior": 2
          },
          "ListTopicSubscriptionsRequest:page_size": {
            "paramName": "page_size",
            "paramType": "TYPE_INT32",
            "comments": [
              " Maximum number of subscription names to return."
            ]
          },
          "ListTopicSubscriptionsRequest:page_token": {
            "paramName": "page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value returned by the last `ListTopicSubscriptionsResponse`; indicates",
              " that this is a continuation of a prior `ListTopicSubscriptions` call, and",
              " that the system should return the next page of data."
            ]
          },
          "ListTopicSubscriptionsResponse:subscriptions": {
            "paramName": "subscriptions",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " The names of subscriptions attached to the topic specified in the request."
            ]
          },
          "ListTopicSubscriptionsResponse:next_page_token": {
            "paramName": "next_page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " If not empty, indicates that there may be more subscriptions that match",
              " the request; this value should be passed in a new",
              " `ListTopicSubscriptionsRequest` to get more subscriptions."
            ]
          },
          "ListTopicSnapshotsRequest:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the topic that snapshots are attached to.",
              " Format is `projects/{project}/topics/{topic}`."
            ],
            "fieldBehavior": 2
          },
          "ListTopicSnapshotsRequest:page_size": {
            "paramName": "page_size",
            "paramType": "TYPE_INT32",
            "comments": [
              " Maximum number of snapshot names to return."
            ]
          },
          "ListTopicSnapshotsRequest:page_token": {
            "paramName": "page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value returned by the last `ListTopicSnapshotsResponse`; indicates",
              " that this is a continuation of a prior `ListTopicSnapshots` call, and",
              " that the system should return the next page of data."
            ]
          },
          "ListTopicSnapshotsResponse:snapshots": {
            "paramName": "snapshots",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " The names of the snapshots that match the request."
            ]
          },
          "ListTopicSnapshotsResponse:next_page_token": {
            "paramName": "next_page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " If not empty, indicates that there may be more snapshots that match",
              " the request; this value should be passed in a new",
              " `ListTopicSnapshotsRequest` to get more snapshots."
            ]
          },
          "DeleteTopicRequest:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. Name of the topic to delete.",
              " Format is `projects/{project}/topics/{topic}`."
            ],
            "fieldBehavior": 2
          },
          "DetachSubscriptionRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription to detach.",
              " Format is `projects/{project}/subscriptions/{subscription}`."
            ],
            "fieldBehavior": 2
          },
          "Subscriber": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " The service that an application uses to manipulate subscriptions and to",
              " consume messages from a subscription via the `Pull` method or by",
              " establishing a bi-directional stream using the `StreamingPull` method."
            ]
          },
          "Subscriber:CreateSubscription": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Creates a subscription to a given topic. See the [resource name rules]",
              " (https://cloud.google.com/pubsub/docs/admin#resource_names).",
              " If the subscription already exists, returns `ALREADY_EXISTS`.",
              " If the corresponding topic doesn't exist, returns `NOT_FOUND`.",
              "",
              " If the name is not provided in the request, the server will assign a random",
              " name for this subscription on the same project as the topic, conforming",
              " to the [resource name format]",
              " (https://cloud.google.com/pubsub/docs/admin#resource_names). The generated",
              " name is populated in the returned Subscription object. Note that for REST",
              " API requests, you must specify a name in the request.",
              ""
            ]
          },
          "Subscriber:GetSubscription": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Gets the configuration details of a subscription.",
              ""
            ]
          },
          "Subscriber:UpdateSubscription": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Updates an existing subscription. Note that certain properties of a",
              " subscription, such as its topic, are not modifiable.",
              ""
            ]
          },
          "Subscriber:ListSubscriptions": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Lists matching subscriptions.",
              ""
            ]
          },
          "Subscriber:DeleteSubscription": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Deletes an existing subscription. All messages retained in the subscription",
              " are immediately dropped. Calls to `Pull` after deletion will return",
              " `NOT_FOUND`. After a subscription is deleted, a new one may be created with",
              " the same name, but the new one has no association with the old",
              " subscription or its topic unless the same topic is specified.",
              ""
            ]
          },
          "Subscriber:ModifyAckDeadline": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Modifies the ack deadline for a specific message. This method is useful",
              " to indicate that more time is needed to process a message by the",
              " subscriber, or to make the message available for redelivery if the",
              " processing was interrupted. Note that this does not modify the",
              " subscription-level `ackDeadlineSeconds` used for subsequent messages.",
              ""
            ]
          },
          "Subscriber:Acknowledge": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Acknowledges the messages associated with the `ack_ids` in the",
              " `AcknowledgeRequest`. The Pub/Sub system can remove the relevant messages",
              " from the subscription.",
              "",
              " Acknowledging a message whose ack deadline has expired may succeed,",
              " but such a message may be redelivered later. Acknowledging a message more",
              " than once will not result in an error.",
              ""
            ]
          },
          "Subscriber:Pull": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Pulls messages from the server. The server may return `UNAVAILABLE` if",
              " there are too many concurrent pull requests pending for the given",
              " subscription.",
              ""
            ]
          },
          "Subscriber:StreamingPull": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Establishes a stream with the server, which sends messages down to the",
              " client. The client streams acknowledgements and ack deadline modifications",
              " back to the server. The server will close the stream and return the status",
              " on any error. The server may close the stream with status `UNAVAILABLE` to",
              " reassign server-side resources, in which case, the client should",
              " re-establish the stream. Flow control can be achieved by configuring the",
              " underlying RPC channel.",
              ""
            ]
          },
          "Subscriber:ModifyPushConfig": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Modifies the `PushConfig` for a specified subscription.",
              "",
              " This may be used to change a push subscription to a pull one (signified by",
              " an empty `PushConfig`) or vice versa, or change the endpoint URL and other",
              " attributes of a push subscription. Messages will accumulate for delivery",
              " continuously through the call regardless of changes to the `PushConfig`.",
              ""
            ]
          },
          "Subscriber:GetSnapshot": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Gets the configuration details of a snapshot. Snapshots are used in",
              " <a href=\"https://cloud.google.com/pubsub/docs/replay-overview\">Seek</a>",
              " operations, which allow you to manage message acknowledgments in bulk. That",
              " is, you can set the acknowledgment state of messages in an existing",
              " subscription to the state captured by a snapshot.",
              ""
            ]
          },
          "Subscriber:ListSnapshots": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Lists the existing snapshots. Snapshots are used in [Seek](",
              " https://cloud.google.com/pubsub/docs/replay-overview) operations, which",
              " allow you to manage message acknowledgments in bulk. That is, you can set",
              " the acknowledgment state of messages in an existing subscription to the",
              " state captured by a snapshot.",
              ""
            ]
          },
          "Subscriber:CreateSnapshot": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Creates a snapshot from the requested subscription. Snapshots are used in",
              " [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,",
              " which allow you to manage message acknowledgments in bulk. That is, you can",
              " set the acknowledgment state of messages in an existing subscription to the",
              " state captured by a snapshot.",
              " If the snapshot already exists, returns `ALREADY_EXISTS`.",
              " If the requested subscription doesn't exist, returns `NOT_FOUND`.",
              " If the backlog in the subscription is too old -- and the resulting snapshot",
              " would expire in less than 1 hour -- then `FAILED_PRECONDITION` is returned.",
              " See also the `Snapshot.expire_time` field. If the name is not provided in",
              " the request, the server will assign a random",
              " name for this snapshot on the same project as the subscription, conforming",
              " to the [resource name format]",
              " (https://cloud.google.com/pubsub/docs/admin#resource_names). The",
              " generated name is populated in the returned Snapshot object. Note that for",
              " REST API requests, you must specify a name in the request.",
              ""
            ]
          },
          "Subscriber:UpdateSnapshot": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Updates an existing snapshot. Snapshots are used in",
              " <a href=\"https://cloud.google.com/pubsub/docs/replay-overview\">Seek</a>",
              " operations, which allow",
              " you to manage message acknowledgments in bulk. That is, you can set the",
              " acknowledgment state of messages in an existing subscription to the state",
              " captured by a snapshot.",
              ""
            ]
          },
          "Subscriber:DeleteSnapshot": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Removes an existing snapshot. Snapshots are used in [Seek]",
              " (https://cloud.google.com/pubsub/docs/replay-overview) operations, which",
              " allow you to manage message acknowledgments in bulk. That is, you can set",
              " the acknowledgment state of messages in an existing subscription to the",
              " state captured by a snapshot.",
              " When the snapshot is deleted, all messages retained in the snapshot",
              " are immediately dropped. After a snapshot is deleted, a new one may be",
              " created with the same name, but the new one has no association with the old",
              " snapshot or its subscription, unless the same subscription is specified.",
              ""
            ]
          },
          "Subscriber:Seek": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Seeks an existing subscription to a point in time or to a given snapshot,",
              " whichever is provided in the request. Snapshots are used in [Seek]",
              " (https://cloud.google.com/pubsub/docs/replay-overview) operations, which",
              " allow you to manage message acknowledgments in bulk. That is, you can set",
              " the acknowledgment state of messages in an existing subscription to the",
              " state captured by a snapshot. Note that both the subscription and the",
              " snapshot must be on the same topic.",
              ""
            ]
          },
          "Subscription:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the subscription. It must have the format",
              " `\"projects/{project}/subscriptions/{subscription}\"`. `{subscription}` must",
              " start with a letter, and contain only letters (`[A-Za-z]`), numbers",
              " (`[0-9]`), dashes (`-`), underscores (`_`), periods (`.`), tildes (`~`),",
              " plus (`+`) or percent signs (`%`). It must be between 3 and 255 characters",
              " in length, and it must not start with `\"goog\"`."
            ],
            "fieldBehavior": 2
          },
          "Subscription:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the topic from which this subscription is receiving",
              " messages. Format is `projects/{project}/topics/{topic}`. The value of this",
              " field will be `_deleted-topic_` if the topic has been deleted."
            ],
            "fieldBehavior": 2
          },
          "Subscription:push_config": {
            "paramName": "push_config",
            "paramType": ".google.pubsub.v1.PushConfig",
            "comments": [
              " If push delivery is used with this subscription, this field is",
              " used to configure it. An empty `pushConfig` signifies that the subscriber",
              " will pull and ack messages using API methods."
            ]
          },
          "Subscription:ack_deadline_seconds": {
            "paramName": "ack_deadline_seconds",
            "paramType": "TYPE_INT32",
            "comments": [
              " The approximate amount of time (on a best-effort basis) Pub/Sub waits for",
              " the subscriber to acknowledge receipt before resending the message. In the",
              " interval after the message is delivered and before it is acknowledged, it",
              " is considered to be <i>outstanding</i>. During that time period, the",
              " message will not be redelivered (on a best-effort basis).",
              "",
              " For pull subscriptions, this value is used as the initial value for the ack",
              " deadline. To override this value for a given message, call",
              " `ModifyAckDeadline` with the corresponding `ack_id` if using",
              " non-streaming pull or send the `ack_id` in a",
              " `StreamingModifyAckDeadlineRequest` if using streaming pull.",
              " The minimum custom deadline you can specify is 10 seconds.",
              " The maximum custom deadline you can specify is 600 seconds (10 minutes).",
              " If this parameter is 0, a default value of 10 seconds is used.",
              "",
              " For push delivery, this value is also used to set the request timeout for",
              " the call to the push endpoint.",
              "",
              " If the subscriber never acknowledges the message, the Pub/Sub",
              " system will eventually redeliver the message."
            ]
          },
          "Subscription:retain_acked_messages": {
            "paramName": "retain_acked_messages",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Indicates whether to retain acknowledged messages. If true, then",
              " messages are not expunged from the subscription's backlog, even if they are",
              " acknowledged, until they fall out of the `message_retention_duration`",
              " window. This must be true if you would like to [Seek to a timestamp]",
              " (https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time)."
            ]
          },
          "Subscription:message_retention_duration": {
            "paramName": "message_retention_duration",
            "paramType": ".google.protobuf.Duration",
            "comments": [
              " How long to retain unacknowledged messages in the subscription's backlog,",
              " from the moment a message is published.",
              " If `retain_acked_messages` is true, then this also configures the retention",
              " of acknowledged messages, and thus configures how far back in time a `Seek`",
              " can be done. Defaults to 7 days. Cannot be more than 7 days or less than 10",
              " minutes."
            ]
          },
          "Subscription:labels": {
            "paramName": "labels",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " See <a href=\"https://cloud.google.com/pubsub/docs/labels\"> Creating and",
              " managing labels</a>."
            ]
          },
          "Subscription:enable_message_ordering": {
            "paramName": "enable_message_ordering",
            "paramType": "TYPE_BOOL",
            "comments": [
              " If true, messages published with the same `ordering_key` in `PubsubMessage`",
              " will be delivered to the subscribers in the order in which they",
              " are received by the Pub/Sub system. Otherwise, they may be delivered in",
              " any order."
            ]
          },
          "Subscription:expiration_policy": {
            "paramName": "expiration_policy",
            "paramType": ".google.pubsub.v1.ExpirationPolicy",
            "comments": [
              " A policy that specifies the conditions for this subscription's expiration.",
              " A subscription is considered active as long as any connected subscriber is",
              " successfully consuming messages from the subscription or is issuing",
              " operations on the subscription. If `expiration_policy` is not set, a",
              " *default policy* with `ttl` of 31 days will be used. The minimum allowed",
              " value for `expiration_policy.ttl` is 1 day."
            ]
          },
          "Subscription:filter": {
            "paramName": "filter",
            "paramType": "TYPE_STRING",
            "comments": [
              " An expression written in the Pub/Sub [filter",
              " language](https://cloud.google.com/pubsub/docs/filtering). If non-empty,",
              " then only `PubsubMessage`s whose `attributes` field matches the filter are",
              " delivered on this subscription. If empty, then no messages are filtered",
              " out."
            ]
          },
          "Subscription:dead_letter_policy": {
            "paramName": "dead_letter_policy",
            "paramType": ".google.pubsub.v1.DeadLetterPolicy",
            "comments": [
              " A policy that specifies the conditions for dead lettering messages in",
              " this subscription. If dead_letter_policy is not set, dead lettering",
              " is disabled.",
              "",
              " The Cloud Pub/Sub service account associated with this subscriptions's",
              " parent project (i.e.,",
              " service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have",
              " permission to Acknowledge() messages on this subscription."
            ]
          },
          "Subscription:retry_policy": {
            "paramName": "retry_policy",
            "paramType": ".google.pubsub.v1.RetryPolicy",
            "comments": [
              " A policy that specifies how Pub/Sub retries message delivery for this",
              " subscription.",
              "",
              " If not set, the default retry policy is applied. This generally implies",
              " that messages will be retried as soon as possible for healthy subscribers.",
              " RetryPolicy will be triggered on NACKs or acknowledgement deadline",
              " exceeded events for a given message."
            ]
          },
          "Subscription:detached": {
            "paramName": "detached",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Indicates whether the subscription is detached from its topic. Detached",
              " subscriptions don't receive messages from their topic and don't retain any",
              " backlog. `Pull` and `StreamingPull` requests will return",
              " FAILED_PRECONDITION. If the subscription is a push subscription, pushes to",
              " the endpoint will not be made."
            ]
          },
          "RetryPolicy:minimum_backoff": {
            "paramName": "minimum_backoff",
            "paramType": ".google.protobuf.Duration",
            "comments": [
              " The minimum delay between consecutive deliveries of a given message.",
              " Value should be between 0 and 600 seconds. Defaults to 10 seconds."
            ]
          },
          "RetryPolicy:maximum_backoff": {
            "paramName": "maximum_backoff",
            "paramType": ".google.protobuf.Duration",
            "comments": [
              " The maximum delay between consecutive deliveries of a given message.",
              " Value should be between 0 and 600 seconds. Defaults to 600 seconds."
            ]
          },
          "DeadLetterPolicy:dead_letter_topic": {
            "paramName": "dead_letter_topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " The name of the topic to which dead letter messages should be published.",
              " Format is `projects/{project}/topics/{topic}`.The Cloud Pub/Sub service",
              " account associated with the enclosing subscription's parent project (i.e.,",
              " service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have",
              " permission to Publish() to this topic.",
              "",
              " The operation will fail if the topic does not exist.",
              " Users should ensure that there is a subscription attached to this topic",
              " since messages published to a topic with no subscriptions are lost."
            ]
          },
          "DeadLetterPolicy:max_delivery_attempts": {
            "paramName": "max_delivery_attempts",
            "paramType": "TYPE_INT32",
            "comments": [
              " The maximum number of delivery attempts for any message. The value must be",
              " between 5 and 100.",
              "",
              " The number of delivery attempts is defined as 1 + (the sum of number of",
              " NACKs and number of times the acknowledgement deadline has been exceeded",
              " for the message).",
              "",
              " A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that",
              " client libraries may automatically extend ack_deadlines.",
              "",
              " This field will be honored on a best effort basis.",
              "",
              " If this parameter is 0, a default value of 5 is used."
            ]
          },
          "ExpirationPolicy:ttl": {
            "paramName": "ttl",
            "paramType": ".google.protobuf.Duration",
            "comments": [
              " Specifies the \"time-to-live\" duration for an associated resource. The",
              " resource expires if it is not active for a period of `ttl`. The definition",
              " of \"activity\" depends on the type of the associated resource. The minimum",
              " and maximum allowed values for `ttl` depend on the type of the associated",
              " resource, as well. If `ttl` is not set, the associated resource never",
              " expires."
            ]
          },
          "PushConfig:push_endpoint": {
            "paramName": "push_endpoint",
            "paramType": "TYPE_STRING",
            "comments": [
              " A URL locating the endpoint to which messages should be pushed.",
              " For example, a Webhook endpoint might use `https://example.com/push`."
            ]
          },
          "PushConfig:attributes": {
            "paramName": "attributes",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Endpoint configuration attributes that can be used to control different",
              " aspects of the message delivery.",
              "",
              " The only currently supported attribute is `x-goog-version`, which you can",
              " use to change the format of the pushed message. This attribute",
              " indicates the version of the data expected by the endpoint. This",
              " controls the shape of the pushed message (i.e., its fields and metadata).",
              "",
              " If not present during the `CreateSubscription` call, it will default to",
              " the version of the Pub/Sub API used to make such call. If not present in a",
              " `ModifyPushConfig` call, its value will not be changed. `GetSubscription`",
              " calls will always return a valid version, even if the subscription was",
              " created without this attribute.",
              "",
              " The only supported values for the `x-goog-version` attribute are:",
              "",
              " * `v1beta1`: uses the push format defined in the v1beta1 Pub/Sub API.",
              " * `v1` or `v1beta2`: uses the push format defined in the v1 Pub/Sub API.",
              "",
              " For example:",
              " <pre><code>attributes { \"x-goog-version\": \"v1\" } </code></pre>"
            ]
          },
          "PushConfig:oidc_token": {
            "paramName": "oidc_token",
            "paramType": ".google.pubsub.v1.PushConfig.OidcToken",
            "comments": [
              " If specified, Pub/Sub will generate and attach an OIDC JWT token as an",
              " `Authorization` header in the HTTP request for every pushed message."
            ]
          },
          "ReceivedMessage:ack_id": {
            "paramName": "ack_id",
            "paramType": "TYPE_STRING",
            "comments": [
              " This ID can be used to acknowledge the received message."
            ]
          },
          "ReceivedMessage:message": {
            "paramName": "message",
            "paramType": ".google.pubsub.v1.PubsubMessage",
            "comments": [
              " The message."
            ]
          },
          "ReceivedMessage:delivery_attempt": {
            "paramName": "delivery_attempt",
            "paramType": "TYPE_INT32",
            "comments": [
              " The approximate number of times that Cloud Pub/Sub has attempted to deliver",
              " the associated message to a subscriber.",
              "",
              " More precisely, this is 1 + (number of NACKs) +",
              " (number of ack_deadline exceeds) for this message.",
              "",
              " A NACK is any call to ModifyAckDeadline with a 0 deadline. An ack_deadline",
              " exceeds event is whenever a message is not acknowledged within",
              " ack_deadline. Note that ack_deadline is initially",
              " Subscription.ackDeadlineSeconds, but may get extended automatically by",
              " the client library.",
              "",
              " Upon the first delivery of a given message, `delivery_attempt` will have a",
              " value of 1. The value is calculated at best effort and is approximate.",
              "",
              " If a DeadLetterPolicy is not set on the subscription, this will be 0."
            ]
          },
          "GetSubscriptionRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the subscription to get.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "UpdateSubscriptionRequest:subscription": {
            "paramName": "subscription",
            "paramType": ".google.pubsub.v1.Subscription",
            "comments": [
              " Required. The updated subscription object."
            ],
            "fieldBehavior": 2
          },
          "UpdateSubscriptionRequest:update_mask": {
            "paramName": "update_mask",
            "paramType": ".google.protobuf.FieldMask",
            "comments": [
              " Required. Indicates which fields in the provided subscription to update.",
              " Must be specified and non-empty."
            ],
            "fieldBehavior": 2
          },
          "ListSubscriptionsRequest:project": {
            "paramName": "project",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to list subscriptions.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "ListSubscriptionsRequest:page_size": {
            "paramName": "page_size",
            "paramType": "TYPE_INT32",
            "comments": [
              " Maximum number of subscriptions to return."
            ]
          },
          "ListSubscriptionsRequest:page_token": {
            "paramName": "page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value returned by the last `ListSubscriptionsResponse`; indicates that",
              " this is a continuation of a prior `ListSubscriptions` call, and that the",
              " system should return the next page of data."
            ]
          },
          "ListSubscriptionsResponse:subscriptions": {
            "paramName": "subscriptions",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The subscriptions that match the request."
            ]
          },
          "ListSubscriptionsResponse:next_page_token": {
            "paramName": "next_page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " If not empty, indicates that there may be more subscriptions that match",
              " the request; this value should be passed in a new",
              " `ListSubscriptionsRequest` to get more subscriptions."
            ]
          },
          "DeleteSubscriptionRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription to delete.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "ModifyPushConfigRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the subscription.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "ModifyPushConfigRequest:push_config": {
            "paramName": "push_config",
            "paramType": ".google.pubsub.v1.PushConfig",
            "comments": [
              " Required. The push configuration for future deliveries.",
              "",
              " An empty `pushConfig` indicates that the Pub/Sub system should",
              " stop pushing messages from the given subscription and allow",
              " messages to be pulled and acknowledged - effectively pausing",
              " the subscription if `Pull` or `StreamingPull` is not called."
            ],
            "fieldBehavior": 2
          },
          "PullRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription from which messages should be pulled.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "PullRequest:return_immediately": {
            "paramName": "return_immediately",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Optional. If this field set to true, the system will respond immediately",
              " even if it there are no messages available to return in the `Pull`",
              " response. Otherwise, the system may wait (for a bounded amount of time)",
              " until at least one message is available, rather than returning no messages.",
              " Warning: setting this field to `true` is discouraged because it adversely",
              " impacts the performance of `Pull` operations. We recommend that users do",
              " not set this field."
            ],
            "fieldBehavior": 1
          },
          "PullRequest:max_messages": {
            "paramName": "max_messages",
            "paramType": "TYPE_INT32",
            "comments": [
              " Required. The maximum number of messages to return for this request. Must",
              " be a positive integer. The Pub/Sub system may return fewer than the number",
              " specified."
            ],
            "fieldBehavior": 2
          },
          "PullResponse:received_messages": {
            "paramName": "received_messages",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Received Pub/Sub messages. The list will be empty if there are no more",
              " messages available in the backlog. For JSON, the response can be entirely",
              " empty. The Pub/Sub system may return fewer than the `maxMessages` requested",
              " even if there are more messages available in the backlog."
            ]
          },
          "ModifyAckDeadlineRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the subscription.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "ModifyAckDeadlineRequest:ack_ids": {
            "paramName": "ack_ids",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Required. List of acknowledgment IDs."
            ],
            "fieldBehavior": 2
          },
          "ModifyAckDeadlineRequest:ack_deadline_seconds": {
            "paramName": "ack_deadline_seconds",
            "paramType": "TYPE_INT32",
            "comments": [
              " Required. The new ack deadline with respect to the time this request was",
              " sent to the Pub/Sub system. For example, if the value is 10, the new ack",
              " deadline will expire 10 seconds after the `ModifyAckDeadline` call was",
              " made. Specifying zero might immediately make the message available for",
              " delivery to another subscriber client. This typically results in an",
              " increase in the rate of message redeliveries (that is, duplicates).",
              " The minimum deadline you can specify is 0 seconds.",
              " The maximum deadline you can specify is 600 seconds (10 minutes)."
            ],
            "fieldBehavior": 2
          },
          "AcknowledgeRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription whose message is being acknowledged.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "AcknowledgeRequest:ack_ids": {
            "paramName": "ack_ids",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Required. The acknowledgment ID for the messages being acknowledged that",
              " was returned by the Pub/Sub system in the `Pull` response. Must not be",
              " empty."
            ],
            "fieldBehavior": 2
          },
          "StreamingPullRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription for which to initialize the new stream. This",
              " must be provided in the first request on the stream, and must not be set in",
              " subsequent requests from client to server.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "StreamingPullRequest:ack_ids": {
            "paramName": "ack_ids",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " List of acknowledgement IDs for acknowledging previously received messages",
              " (received on this stream or a different stream). If an ack ID has expired,",
              " the corresponding message may be redelivered later. Acknowledging a message",
              " more than once will not result in an error. If the acknowledgement ID is",
              " malformed, the stream will be aborted with status `INVALID_ARGUMENT`."
            ]
          },
          "StreamingPullRequest:modify_deadline_seconds": {
            "paramName": "modify_deadline_seconds",
            "paramType": "TYPE_INT32[]",
            "comments": [
              " The list of new ack deadlines for the IDs listed in",
              " `modify_deadline_ack_ids`. The size of this list must be the same as the",
              " size of `modify_deadline_ack_ids`. If it differs the stream will be aborted",
              " with `INVALID_ARGUMENT`. Each element in this list is applied to the",
              " element in the same position in `modify_deadline_ack_ids`. The new ack",
              " deadline is with respect to the time this request was sent to the Pub/Sub",
              " system. Must be >= 0. For example, if the value is 10, the new ack deadline",
              " will expire 10 seconds after this request is received. If the value is 0,",
              " the message is immediately made available for another streaming or",
              " non-streaming pull request. If the value is < 0 (an error), the stream will",
              " be aborted with status `INVALID_ARGUMENT`."
            ]
          },
          "StreamingPullRequest:modify_deadline_ack_ids": {
            "paramName": "modify_deadline_ack_ids",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " List of acknowledgement IDs whose deadline will be modified based on the",
              " corresponding element in `modify_deadline_seconds`. This field can be used",
              " to indicate that more time is needed to process a message by the",
              " subscriber, or to make the message available for redelivery if the",
              " processing was interrupted."
            ]
          },
          "StreamingPullRequest:stream_ack_deadline_seconds": {
            "paramName": "stream_ack_deadline_seconds",
            "paramType": "TYPE_INT32",
            "comments": [
              " Required. The ack deadline to use for the stream. This must be provided in",
              " the first request on the stream, but it can also be updated on subsequent",
              " requests from client to server. The minimum deadline you can specify is 10",
              " seconds. The maximum deadline you can specify is 600 seconds (10 minutes)."
            ],
            "fieldBehavior": 2
          },
          "StreamingPullRequest:client_id": {
            "paramName": "client_id",
            "paramType": "TYPE_STRING",
            "comments": [
              " A unique identifier that is used to distinguish client instances from each",
              " other. Only needs to be provided on the initial request. When a stream",
              " disconnects and reconnects for the same stream, the client_id should be set",
              " to the same value so that state associated with the old stream can be",
              " transferred to the new stream. The same client_id should not be used for",
              " different client instances."
            ]
          },
          "StreamingPullRequest:max_outstanding_messages": {
            "paramName": "max_outstanding_messages",
            "paramType": "TYPE_INT64",
            "comments": [
              " Flow control settings for the maximum number of outstanding messages. When",
              " there are `max_outstanding_messages` or more currently sent to the",
              " streaming pull client that have not yet been acked or nacked, the server",
              " stops sending more messages. The sending of messages resumes once the",
              " number of outstanding messages is less than this value. If the value is",
              " <= 0, there is no limit to the number of outstanding messages. This",
              " property can only be set on the initial StreamingPullRequest. If it is set",
              " on a subsequent request, the stream will be aborted with status",
              " `INVALID_ARGUMENT`."
            ]
          },
          "StreamingPullRequest:max_outstanding_bytes": {
            "paramName": "max_outstanding_bytes",
            "paramType": "TYPE_INT64",
            "comments": [
              " Flow control settings for the maximum number of outstanding bytes. When",
              " there are `max_outstanding_bytes` or more worth of messages currently sent",
              " to the streaming pull client that have not yet been acked or nacked, the",
              " server will stop sending more messages. The sending of messages resumes",
              " once the number of outstanding bytes is less than this value. If the value",
              " is <= 0, there is no limit to the number of outstanding bytes. This",
              " property can only be set on the initial StreamingPullRequest. If it is set",
              " on a subsequent request, the stream will be aborted with status",
              " `INVALID_ARGUMENT`."
            ]
          },
          "StreamingPullResponse:received_messages": {
            "paramName": "received_messages",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Received Pub/Sub messages. This will not be empty."
            ]
          },
          "CreateSnapshotRequest:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. User-provided name for this snapshot. If the name is not provided",
              " in the request, the server will assign a random name for this snapshot on",
              " the same project as the subscription. Note that for REST API requests, you",
              " must specify a name.  See the <a",
              " href=\"https://cloud.google.com/pubsub/docs/admin#resource_names\"> resource",
              " name rules</a>. Format is `projects/{project}/snapshots/{snap}`."
            ],
            "fieldBehavior": 2
          },
          "CreateSnapshotRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription whose backlog the snapshot retains.",
              " Specifically, the created snapshot is guaranteed to retain:",
              "  (a) The existing backlog on the subscription. More precisely, this is",
              "      defined as the messages in the subscription's backlog that are",
              "      unacknowledged upon the successful completion of the",
              "      `CreateSnapshot` request; as well as:",
              "  (b) Any messages published to the subscription's topic following the",
              "      successful completion of the CreateSnapshot request.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "CreateSnapshotRequest:labels": {
            "paramName": "labels",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " See <a href=\"https://cloud.google.com/pubsub/docs/labels\"> Creating and",
              " managing labels</a>."
            ]
          },
          "UpdateSnapshotRequest:snapshot": {
            "paramName": "snapshot",
            "paramType": ".google.pubsub.v1.Snapshot",
            "comments": [
              " Required. The updated snapshot object."
            ],
            "fieldBehavior": 2
          },
          "UpdateSnapshotRequest:update_mask": {
            "paramName": "update_mask",
            "paramType": ".google.protobuf.FieldMask",
            "comments": [
              " Required. Indicates which fields in the provided snapshot to update.",
              " Must be specified and non-empty."
            ],
            "fieldBehavior": 2
          },
          "Snapshot:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " The name of the snapshot."
            ]
          },
          "Snapshot:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " The name of the topic from which this snapshot is retaining messages."
            ]
          },
          "Snapshot:expire_time": {
            "paramName": "expire_time",
            "paramType": ".google.protobuf.Timestamp",
            "comments": [
              " The snapshot is guaranteed to exist up until this time.",
              " A newly-created snapshot expires no later than 7 days from the time of its",
              " creation. Its exact lifetime is determined at creation by the existing",
              " backlog in the source subscription. Specifically, the lifetime of the",
              " snapshot is `7 days - (age of oldest unacked message in the subscription)`.",
              " For example, consider a subscription whose oldest unacked message is 3 days",
              " old. If a snapshot is created from this subscription, the snapshot -- which",
              " will always capture this 3-day-old backlog as long as the snapshot",
              " exists -- will expire in 4 days. The service will refuse to create a",
              " snapshot that would expire in less than 1 hour after creation."
            ]
          },
          "Snapshot:labels": {
            "paramName": "labels",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " See [Creating and managing labels]",
              " (https://cloud.google.com/pubsub/docs/labels)."
            ]
          },
          "GetSnapshotRequest:snapshot": {
            "paramName": "snapshot",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the snapshot to get.",
              " Format is `projects/{project}/snapshots/{snap}`."
            ],
            "fieldBehavior": 2
          },
          "ListSnapshotsRequest:project": {
            "paramName": "project",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to list snapshots.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "ListSnapshotsRequest:page_size": {
            "paramName": "page_size",
            "paramType": "TYPE_INT32",
            "comments": [
              " Maximum number of snapshots to return."
            ]
          },
          "ListSnapshotsRequest:page_token": {
            "paramName": "page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value returned by the last `ListSnapshotsResponse`; indicates that this",
              " is a continuation of a prior `ListSnapshots` call, and that the system",
              " should return the next page of data."
            ]
          },
          "ListSnapshotsResponse:snapshots": {
            "paramName": "snapshots",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The resulting snapshots."
            ]
          },
          "ListSnapshotsResponse:next_page_token": {
            "paramName": "next_page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " If not empty, indicates that there may be more snapshot that match the",
              " request; this value should be passed in a new `ListSnapshotsRequest`."
            ]
          },
          "DeleteSnapshotRequest:snapshot": {
            "paramName": "snapshot",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the snapshot to delete.",
              " Format is `projects/{project}/snapshots/{snap}`."
            ],
            "fieldBehavior": 2
          },
          "SeekRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription to affect."
            ],
            "fieldBehavior": 2
          },
          "SeekRequest:time": {
            "paramName": "time",
            "paramType": ".google.protobuf.Timestamp",
            "comments": [
              " The time to seek to.",
              " Messages retained in the subscription that were published before this",
              " time are marked as acknowledged, and messages retained in the",
              " subscription that were published after this time are marked as",
              " unacknowledged. Note that this operation affects only those messages",
              " retained in the subscription (configured by the combination of",
              " `message_retention_duration` and `retain_acked_messages`). For example,",
              " if `time` corresponds to a point before the message retention",
              " window (or to a point before the system's notion of the subscription",
              " creation time), only retained messages will be marked as unacknowledged,",
              " and already-expunged messages will not be restored."
            ]
          },
          "SeekRequest:snapshot": {
            "paramName": "snapshot",
            "paramType": "TYPE_STRING",
            "comments": [
              " The snapshot to seek to. The snapshot's topic must be the same as that of",
              " the provided subscription.",
              " Format is `projects/{project}/snapshots/{snap}`."
            ]
          },
          "GetPolicyOptions:requested_policy_version": {
            "paramName": "requested_policy_version",
            "paramType": "TYPE_INT32",
            "comments": [
              " Optional. The policy format version to be returned.",
              "",
              " Valid values are 0, 1, and 3. Requests specifying an invalid value will be",
              " rejected.",
              "",
              " Requests for policies with any conditional bindings must specify version 3.",
              " Policies without any conditional bindings may specify any valid value or",
              " leave the field unset."
            ]
          },
          "Expr:expression": {
            "paramName": "expression",
            "paramType": "TYPE_STRING",
            "comments": [
              " Textual representation of an expression in Common Expression Language",
              " syntax."
            ]
          },
          "Expr:title": {
            "paramName": "title",
            "paramType": "TYPE_STRING",
            "comments": [
              " Optional. Title for the expression, i.e. a short string describing",
              " its purpose. This can be used e.g. in UIs which allow to enter the",
              " expression."
            ]
          },
          "Expr:description": {
            "paramName": "description",
            "paramType": "TYPE_STRING",
            "comments": [
              " Optional. Description of the expression. This is a longer text which",
              " describes the expression, e.g. when hovered over it in a UI."
            ]
          },
          "Expr:location": {
            "paramName": "location",
            "paramType": "TYPE_STRING",
            "comments": [
              " Optional. String indicating the location of the expression for error",
              " reporting, e.g. a file name and a position in the file."
            ]
          },
          "Policy:version": {
            "paramName": "version",
            "paramType": "TYPE_INT32",
            "comments": [
              " Specifies the format of the policy.",
              "",
              " Valid values are `0`, `1`, and `3`. Requests that specify an invalid value",
              " are rejected.",
              "",
              " Any operation that affects conditional role bindings must specify version",
              " `3`. This requirement applies to the following operations:",
              "",
              " * Getting a policy that includes a conditional role binding",
              " * Adding a conditional role binding to a policy",
              " * Changing a conditional role binding in a policy",
              " * Removing any role binding, with or without a condition, from a policy",
              "   that includes conditions",
              "",
              " **Important:** If you use IAM Conditions, you must include the `etag` field",
              " whenever you call `setIamPolicy`. If you omit this field, then IAM allows",
              " you to overwrite a version `3` policy with a version `1` policy, and all of",
              " the conditions in the version `3` policy are lost.",
              "",
              " If a policy does not include any conditions, operations on that policy may",
              " specify any valid version or leave the field unset.",
              "",
              " To learn which resources support conditions in their IAM policies, see the",
              " [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies)."
            ]
          },
          "Policy:bindings": {
            "paramName": "bindings",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Associates a list of `members`, or principals, with a `role`. Optionally,",
              " may specify a `condition` that determines how and when the `bindings` are",
              " applied. Each of the `bindings` must contain at least one principal.",
              "",
              " The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250",
              " of these principals can be Google groups. Each occurrence of a principal",
              " counts towards these limits. For example, if the `bindings` grant 50",
              " different roles to `user:alice@example.com`, and not to any other",
              " principal, then you can add another 1,450 principals to the `bindings` in",
              " the `Policy`."
            ]
          },
          "Policy:audit_configs": {
            "paramName": "audit_configs",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Specifies cloud audit logging configuration for this policy."
            ]
          },
          "Policy:etag": {
            "paramName": "etag",
            "paramType": "TYPE_BYTES",
            "comments": [
              " `etag` is used for optimistic concurrency control as a way to help",
              " prevent simultaneous updates of a policy from overwriting each other.",
              " It is strongly suggested that systems make use of the `etag` in the",
              " read-modify-write cycle to perform policy updates in order to avoid race",
              " conditions: An `etag` is returned in the response to `getIamPolicy`, and",
              " systems are expected to put that etag in the request to `setIamPolicy` to",
              " ensure that their change will be applied to the same version of the policy.",
              "",
              " **Important:** If you use IAM Conditions, you must include the `etag` field",
              " whenever you call `setIamPolicy`. If you omit this field, then IAM allows",
              " you to overwrite a version `3` policy with a version `1` policy, and all of",
              " the conditions in the version `3` policy are lost."
            ]
          },
          "Binding:role": {
            "paramName": "role",
            "paramType": "TYPE_STRING",
            "comments": [
              " Role that is assigned to the list of `members`, or principals.",
              " For example, `roles/viewer`, `roles/editor`, or `roles/owner`."
            ]
          },
          "Binding:members": {
            "paramName": "members",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Specifies the principals requesting access for a Cloud Platform resource.",
              " `members` can have the following values:",
              "",
              " * `allUsers`: A special identifier that represents anyone who is",
              "    on the internet; with or without a Google account.",
              "",
              " * `allAuthenticatedUsers`: A special identifier that represents anyone",
              "    who is authenticated with a Google account or a service account.",
              "",
              " * `user:{emailid}`: An email address that represents a specific Google",
              "    account. For example, `alice@example.com` .",
              "",
              "",
              " * `serviceAccount:{emailid}`: An email address that represents a service",
              "    account. For example, `my-other-app@appspot.gserviceaccount.com`.",
              "",
              " * `group:{emailid}`: An email address that represents a Google group.",
              "    For example, `admins@example.com`.",
              "",
              " * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique",
              "    identifier) representing a user that has been recently deleted. For",
              "    example, `alice@example.com?uid=123456789012345678901`. If the user is",
              "    recovered, this value reverts to `user:{emailid}` and the recovered user",
              "    retains the role in the binding.",
              "",
              " * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus",
              "    unique identifier) representing a service account that has been recently",
              "    deleted. For example,",
              "    `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`.",
              "    If the service account is undeleted, this value reverts to",
              "    `serviceAccount:{emailid}` and the undeleted service account retains the",
              "    role in the binding.",
              "",
              " * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique",
              "    identifier) representing a Google group that has been recently",
              "    deleted. For example, `admins@example.com?uid=123456789012345678901`. If",
              "    the group is recovered, this value reverts to `group:{emailid}` and the",
              "    recovered group retains the role in the binding.",
              "",
              "",
              " * `domain:{domain}`: The G Suite domain (primary) that represents all the",
              "    users of that domain. For example, `google.com` or `example.com`.",
              "",
              ""
            ]
          },
          "Binding:condition": {
            "paramName": "condition",
            "paramType": ".google.type.Expr",
            "comments": [
              " The condition that is associated with this binding.",
              "",
              " If the condition evaluates to `true`, then this binding applies to the",
              " current request.",
              "",
              " If the condition evaluates to `false`, then this binding does not apply to",
              " the current request. However, a different role binding might grant the same",
              " role to one or more of the principals in this binding.",
              "",
              " To learn which resources support conditions in their IAM policies, see the",
              " [IAM",
              " documentation](https://cloud.google.com/iam/help/conditions/resource-policies)."
            ]
          },
          "AuditConfig:service": {
            "paramName": "service",
            "paramType": "TYPE_STRING",
            "comments": [
              " Specifies a service that will be enabled for audit logging.",
              " For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.",
              " `allServices` is a special value that covers all services."
            ]
          },
          "AuditConfig:audit_log_configs": {
            "paramName": "audit_log_configs",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The configuration for logging of each type of permission."
            ]
          },
          "AuditLogConfig:log_type": {
            "paramName": "log_type",
            "paramType": ".google.iam.v1.AuditLogConfig.LogType",
            "comments": [
              " The log type that this config enables."
            ]
          },
          "AuditLogConfig:exempted_members": {
            "paramName": "exempted_members",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Specifies the identities that do not cause logging for this type of",
              " permission.",
              " Follows the same format of [Binding.members][google.iam.v1.Binding.members]."
            ]
          },
          "PolicyDelta:binding_deltas": {
            "paramName": "binding_deltas",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The delta for Bindings between two policies."
            ]
          },
          "PolicyDelta:audit_config_deltas": {
            "paramName": "audit_config_deltas",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The delta for AuditConfigs between two policies."
            ]
          },
          "BindingDelta:action": {
            "paramName": "action",
            "paramType": ".google.iam.v1.BindingDelta.Action",
            "comments": [
              " The action that was performed on a Binding.",
              " Required"
            ]
          },
          "BindingDelta:role": {
            "paramName": "role",
            "paramType": "TYPE_STRING",
            "comments": [
              " Role that is assigned to `members`.",
              " For example, `roles/viewer`, `roles/editor`, or `roles/owner`.",
              " Required"
            ]
          },
          "BindingDelta:member": {
            "paramName": "member",
            "paramType": "TYPE_STRING",
            "comments": [
              " A single identity requesting access for a Cloud Platform resource.",
              " Follows the same format of Binding.members.",
              " Required"
            ]
          },
          "BindingDelta:condition": {
            "paramName": "condition",
            "paramType": ".google.type.Expr",
            "comments": [
              " The condition that is associated with this binding."
            ]
          },
          "AuditConfigDelta:action": {
            "paramName": "action",
            "paramType": ".google.iam.v1.AuditConfigDelta.Action",
            "comments": [
              " The action that was performed on an audit configuration in a policy.",
              " Required"
            ]
          },
          "AuditConfigDelta:service": {
            "paramName": "service",
            "paramType": "TYPE_STRING",
            "comments": [
              " Specifies a service that was configured for Cloud Audit Logging.",
              " For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.",
              " `allServices` is a special value that covers all services.",
              " Required"
            ]
          },
          "AuditConfigDelta:exempted_member": {
            "paramName": "exempted_member",
            "paramType": "TYPE_STRING",
            "comments": [
              " A single identity that is exempted from \"data access\" audit",
              " logging for the `service` specified above.",
              " Follows the same format of Binding.members."
            ]
          },
          "AuditConfigDelta:log_type": {
            "paramName": "log_type",
            "paramType": "TYPE_STRING",
            "comments": [
              " Specifies the log_type that was be enabled. ADMIN_ACTIVITY is always",
              " enabled, and cannot be configured.",
              " Required"
            ]
          },
          "IAMPolicy": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " ## API Overview",
              "",
              " Manages Identity and Access Management (IAM) policies.",
              "",
              " Any implementation of an API that offers access control features",
              " implements the google.iam.v1.IAMPolicy interface.",
              "",
              " ## Data model",
              "",
              " Access control is applied when a principal (user or service account), takes",
              " some action on a resource exposed by a service. Resources, identified by",
              " URI-like names, are the unit of access control specification. Service",
              " implementations can choose the granularity of access control and the",
              " supported permissions for their resources.",
              " For example one database service may allow access control to be",
              " specified only at the Table level, whereas another might allow access control",
              " to also be specified at the Column level.",
              "",
              " ## Policy Structure",
              "",
              " See google.iam.v1.Policy",
              "",
              " This is intentionally not a CRUD style API because access control policies",
              " are created and deleted implicitly with the resources to which they are",
              " attached."
            ]
          },
          "IAMPolicy:SetIamPolicy": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Sets the access control policy on the specified resource. Replaces any",
              " existing policy.",
              ""
            ]
          },
          "IAMPolicy:GetIamPolicy": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Gets the access control policy for a resource.",
              " Returns an empty policy if the resource exists and does not have a policy",
              " set.",
              ""
            ]
          },
          "IAMPolicy:TestIamPermissions": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Returns permissions that a caller has on the specified resource.",
              " If the resource does not exist, this will return an empty set of",
              " permissions, not a NOT_FOUND error.",
              "",
              " Note: This operation is designed to be used for building permission-aware",
              " UIs and command-line tools, not for authorization checking. This operation",
              " may \"fail open\" without warning.",
              ""
            ]
          },
          "SetIamPolicyRequest:resource": {
            "paramName": "resource",
            "paramType": "TYPE_STRING",
            "comments": [
              " REQUIRED: The resource for which the policy is being specified.",
              " See the operation documentation for the appropriate value for this field."
            ],
            "fieldBehavior": 2
          },
          "SetIamPolicyRequest:policy": {
            "paramName": "policy",
            "paramType": ".google.iam.v1.Policy",
            "comments": [
              " REQUIRED: The complete policy to be applied to the `resource`. The size of",
              " the policy is limited to a few 10s of KB. An empty policy is a",
              " valid policy but certain Cloud Platform services (such as Projects)",
              " might reject them."
            ],
            "fieldBehavior": 2
          },
          "GetIamPolicyRequest:resource": {
            "paramName": "resource",
            "paramType": "TYPE_STRING",
            "comments": [
              " REQUIRED: The resource for which the policy is being requested.",
              " See the operation documentation for the appropriate value for this field."
            ],
            "fieldBehavior": 2
          },
          "GetIamPolicyRequest:options": {
            "paramName": "options",
            "paramType": ".google.iam.v1.GetPolicyOptions",
            "comments": [
              " OPTIONAL: A `GetPolicyOptions` object for specifying options to",
              " `GetIamPolicy`. This field is only used by Cloud IAM."
            ]
          },
          "TestIamPermissionsRequest:resource": {
            "paramName": "resource",
            "paramType": "TYPE_STRING",
            "comments": [
              " REQUIRED: The resource for which the policy detail is being requested.",
              " See the operation documentation for the appropriate value for this field."
            ],
            "fieldBehavior": 2
          },
          "TestIamPermissionsRequest:permissions": {
            "paramName": "permissions",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " The set of permissions to check for the `resource`. Permissions with",
              " wildcards (such as '*' or 'storage.*') are not allowed. For more",
              " information see",
              " [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions)."
            ],
            "fieldBehavior": 2
          },
          "TestIamPermissionsResponse:permissions": {
            "paramName": "permissions",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " A subset of `TestPermissionsRequest.permissions` that the caller is",
              " allowed."
            ]
          }
        }
      },
      "retryableCodeMap": {
        "uniqueCodesNamesMap": {
          "": "non_idempotent",
          "deadline_exceeded_unavailable": "idempotent"
        },
        "prettyCodesNamesMap": {
          "non_idempotent": [],
          "idempotent": [
            "DEADLINE_EXCEEDED",
            "UNAVAILABLE"
          ]
        },
        "uniqueParamsNamesMap": {
          "94312e9926796a52a8fcbbedaac41972e07ccd1c": "default"
        },
        "prettyParamNamesMap": {
          "default": {
            "initial_retry_delay_millis": 100,
            "retry_delay_multiplier": 1.3,
            "max_retry_delay_millis": 60000,
            "initial_rpc_timeout_millis": 60000,
            "rpc_timeout_multiplier": 1,
            "max_rpc_timeout_millis": 60000,
            "total_timeout_millis": 600000
          }
        },
        "codeEnumMapping": {
          "0": "OK",
          "1": "CANCELLED",
          "2": "UNKNOWN",
          "3": "INVALID_ARGUMENT",
          "4": "DEADLINE_EXCEEDED",
          "5": "NOT_FOUND",
          "6": "ALREADY_EXISTS",
          "7": "PERMISSION_DENIED",
          "8": "RESOURCE_EXHAUSTED",
          "9": "FAILED_PRECONDITION",
          "10": "ABORTED",
          "11": "OUT_OF_RANGE",
          "12": "UNIMPLEMENTED",
          "13": "INTERNAL",
          "14": "UNAVAILABLE",
          "15": "DATA_LOSS",
          "16": "UNAUTHENTICATED"
        }
      },
      "grpcServiceConfig": {},
      "bundleConfigs": [],
      "bundleConfigsMethods": [],
      "simpleMethods": [
        {
          "inputInterface": ".google.pubsub.v1.CreateSchemaRequest",
          "outputInterface": ".google.pubsub.v1.Schema",
          "comments": [
            " Creates a schema.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "CreateSchema",
          "inputType": ".google.pubsub.v1.CreateSchemaRequest",
          "outputType": ".google.pubsub.v1.Schema",
          "options": {
            ".google.api.methodSignature": [
              "parent,schema,schema_id"
            ],
            ".google.api.http": {
              "post": "/v1/{parent=projects/*}/schemas",
              "body": "schema"
            }
          },
          "paramComment": [
            {
              "paramName": "parent",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the project in which to create the schema.",
                " Format is `projects/{project-id}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "schema",
              "paramType": ".google.pubsub.v1.Schema",
              "comments": [
                " Required. The schema object to create.",
                "",
                " This schema's `name` parameter is ignored. The schema object returned",
                " by CreateSchema will have a `name` made using the given `parent` and",
                " `schema_id`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "schema_id",
              "paramType": "TYPE_STRING",
              "comments": [
                " The ID to use for the schema, which will become the final component of",
                " the schema's resource name.",
                "",
                " See https://cloud.google.com/pubsub/docs/admin#resource_names for resource",
                " name constraints."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "parent"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.GetSchemaRequest",
          "outputInterface": ".google.pubsub.v1.Schema",
          "comments": [
            " Gets a schema.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "GetSchema",
          "inputType": ".google.pubsub.v1.GetSchemaRequest",
          "outputType": ".google.pubsub.v1.Schema",
          "options": {
            ".google.api.methodSignature": [
              "name"
            ],
            ".google.api.http": {
              "get": "/v1/{name=projects/*/schemas/*}"
            }
          },
          "paramComment": [
            {
              "paramName": "name",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the schema to get.",
                " Format is `projects/{project}/schemas/{schema}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "view",
              "paramType": ".google.pubsub.v1.SchemaView",
              "comments": [
                " The set of fields to return in the response. If not set, returns a Schema",
                " with `name` and `type`, but not `definition`. Set to `FULL` to retrieve all",
                " fields."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "name"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.DeleteSchemaRequest",
          "outputInterface": ".google.protobuf.Empty",
          "comments": [
            " Deletes a schema.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "DeleteSchema",
          "inputType": ".google.pubsub.v1.DeleteSchemaRequest",
          "outputType": ".google.protobuf.Empty",
          "options": {
            ".google.api.methodSignature": [
              "name"
            ],
            ".google.api.http": {
              "delete": "/v1/{name=projects/*/schemas/*}"
            }
          },
          "paramComment": [
            {
              "paramName": "name",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. Name of the schema to delete.",
                " Format is `projects/{project}/schemas/{schema}`."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "name"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.ValidateSchemaRequest",
          "outputInterface": ".google.pubsub.v1.ValidateSchemaResponse",
          "comments": [
            " Validates a schema.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ValidateSchema",
          "inputType": ".google.pubsub.v1.ValidateSchemaRequest",
          "outputType": ".google.pubsub.v1.ValidateSchemaResponse",
          "options": {
            ".google.api.methodSignature": [
              "parent,schema"
            ],
            ".google.api.http": {
              "post": "/v1/{parent=projects/*}/schemas:validate",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "parent",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the project in which to validate schemas.",
                " Format is `projects/{project-id}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "schema",
              "paramType": ".google.pubsub.v1.Schema",
              "comments": [
                " Required. The schema object to validate."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "parent"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.ValidateMessageRequest",
          "outputInterface": ".google.pubsub.v1.ValidateMessageResponse",
          "comments": [
            " Validates a message against a schema.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ValidateMessage",
          "inputType": ".google.pubsub.v1.ValidateMessageRequest",
          "outputType": ".google.pubsub.v1.ValidateMessageResponse",
          "options": {
            ".google.api.http": {
              "post": "/v1/{parent=projects/*}/schemas:validateMessage",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "parent",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the project in which to validate schemas.",
                " Format is `projects/{project-id}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "name",
              "paramType": "TYPE_STRING",
              "comments": [
                " Name of the schema against which to validate.",
                "",
                " Format is `projects/{project}/schemas/{schema}`."
              ]
            },
            {
              "paramName": "schema",
              "paramType": ".google.pubsub.v1.Schema",
              "comments": [
                " Ad-hoc schema against which to validate"
              ]
            },
            {
              "paramName": "message",
              "paramType": "TYPE_BYTES",
              "comments": [
                " Message to validate against the provided `schema_spec`."
              ]
            },
            {
              "paramName": "encoding",
              "paramType": ".google.pubsub.v1.Encoding",
              "comments": [
                " The encoding expected for messages"
              ]
            }
          ],
          "headerRequestParams": [
            [
              "parent"
            ]
          ]
        }
      ],
      "longRunning": [],
      "diregapicLRO": [],
      "streaming": [],
      "clientStreaming": [],
      "serverStreaming": [],
      "bidiStreaming": [],
      "paging": [
        {
          "pagingFieldName": "schemas",
          "pagingResponseType": ".google.pubsub.v1.Schema",
          "ignoreMapPagingMethod": false,
          "inputInterface": ".google.pubsub.v1.ListSchemasRequest",
          "outputInterface": ".google.pubsub.v1.ListSchemasResponse",
          "comments": [
            " Lists schemas in a project.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ListSchemas",
          "inputType": ".google.pubsub.v1.ListSchemasRequest",
          "outputType": ".google.pubsub.v1.ListSchemasResponse",
          "options": {
            ".google.api.methodSignature": [
              "parent"
            ],
            ".google.api.http": {
              "get": "/v1/{parent=projects/*}/schemas"
            }
          },
          "paramComment": [
            {
              "paramName": "parent",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the project in which to list schemas.",
                " Format is `projects/{project-id}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "view",
              "paramType": ".google.pubsub.v1.SchemaView",
              "comments": [
                " The set of Schema fields to return in the response. If not set, returns",
                " Schemas with `name` and `type`, but not `definition`. Set to `FULL` to",
                " retrieve all fields."
              ]
            },
            {
              "paramName": "page_size",
              "paramType": "TYPE_INT32",
              "comments": [
                " Maximum number of schemas to return."
              ]
            },
            {
              "paramName": "page_token",
              "paramType": "TYPE_STRING",
              "comments": [
                " The value returned by the last `ListSchemasResponse`; indicates that",
                " this is a continuation of a prior `ListSchemas` call, and that the",
                " system should return the next page of data."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "parent"
            ]
          ]
        }
      ],
      "hostname": "",
      "port": 0,
      "oauthScopes": [
        "https://www.googleapis.com/auth/cloud-platform",
        "https://www.googleapis.com/auth/pubsub"
      ],
      "pathTemplates": [
        {
          "name": "Project",
          "params": [
            "project"
          ],
          "pattern": [
            "projects/{project}"
          ],
          "style": [],
          "type": "cloudresourcemanager.googleapis.com/Project"
        },
        {
          "name": "project_topic",
          "params": [
            "project",
            "topic"
          ],
          "pattern": [
            "projects/{project}/topics/{topic}"
          ],
          "type": "pubsub.googleapis.com/Topic"
        },
        {
          "name": "Schema",
          "params": [
            "project",
            "schema"
          ],
          "pattern": [
            "projects/{project}/schemas/{schema}"
          ],
          "style": [],
          "type": "pubsub.googleapis.com/Schema"
        },
        {
          "name": "Snapshot",
          "params": [
            "project",
            "snapshot"
          ],
          "pattern": [
            "projects/{project}/snapshots/{snapshot}"
          ],
          "style": [],
          "type": "pubsub.googleapis.com/Snapshot"
        },
        {
          "name": "Subscription",
          "params": [
            "project",
            "subscription"
          ],
          "pattern": [
            "projects/{project}/subscriptions/{subscription}"
          ],
          "style": [],
          "type": "pubsub.googleapis.com/Subscription"
        }
      ]
    },
    {
      "method": [
        {
          "inputInterface": ".google.pubsub.v1.Subscription",
          "outputInterface": ".google.pubsub.v1.Subscription",
          "comments": [
            " Creates a subscription to a given topic. See the [resource name rules]",
            " (https://cloud.google.com/pubsub/docs/admin#resource_names).",
            " If the subscription already exists, returns `ALREADY_EXISTS`.",
            " If the corresponding topic doesn't exist, returns `NOT_FOUND`.",
            "",
            " If the name is not provided in the request, the server will assign a random",
            " name for this subscription on the same project as the topic, conforming",
            " to the [resource name format]",
            " (https://cloud.google.com/pubsub/docs/admin#resource_names). The generated",
            " name is populated in the returned Subscription object. Note that for REST",
            " API requests, you must specify a name in the request.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "CreateSubscription",
          "inputType": ".google.pubsub.v1.Subscription",
          "outputType": ".google.pubsub.v1.Subscription",
          "options": {
            ".google.api.methodSignature": [
              "name,topic,push_config,ack_deadline_seconds"
            ],
            ".google.api.http": {
              "put": "/v1/{name=projects/*/subscriptions/*}",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "name",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the subscription. It must have the format",
                " `\"projects/{project}/subscriptions/{subscription}\"`. `{subscription}` must",
                " start with a letter, and contain only letters (`[A-Za-z]`), numbers",
                " (`[0-9]`), dashes (`-`), underscores (`_`), periods (`.`), tildes (`~`),",
                " plus (`+`) or percent signs (`%`). It must be between 3 and 255 characters",
                " in length, and it must not start with `\"goog\"`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "topic",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the topic from which this subscription is receiving",
                " messages. Format is `projects/{project}/topics/{topic}`. The value of this",
                " field will be `_deleted-topic_` if the topic has been deleted."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "push_config",
              "paramType": ".google.pubsub.v1.PushConfig",
              "comments": [
                " If push delivery is used with this subscription, this field is",
                " used to configure it. An empty `pushConfig` signifies that the subscriber",
                " will pull and ack messages using API methods."
              ]
            },
            {
              "paramName": "ack_deadline_seconds",
              "paramType": "TYPE_INT32",
              "comments": [
                " The approximate amount of time (on a best-effort basis) Pub/Sub waits for",
                " the subscriber to acknowledge receipt before resending the message. In the",
                " interval after the message is delivered and before it is acknowledged, it",
                " is considered to be <i>outstanding</i>. During that time period, the",
                " message will not be redelivered (on a best-effort basis).",
                "",
                " For pull subscriptions, this value is used as the initial value for the ack",
                " deadline. To override this value for a given message, call",
                " `ModifyAckDeadline` with the corresponding `ack_id` if using",
                " non-streaming pull or send the `ack_id` in a",
                " `StreamingModifyAckDeadlineRequest` if using streaming pull.",
                " The minimum custom deadline you can specify is 10 seconds.",
                " The maximum custom deadline you can specify is 600 seconds (10 minutes).",
                " If this parameter is 0, a default value of 10 seconds is used.",
                "",
                " For push delivery, this value is also used to set the request timeout for",
                " the call to the push endpoint.",
                "",
                " If the subscriber never acknowledges the message, the Pub/Sub",
                " system will eventually redeliver the message."
              ]
            },
            {
              "paramName": "retain_acked_messages",
              "paramType": "TYPE_BOOL",
              "comments": [
                " Indicates whether to retain acknowledged messages. If true, then",
                " messages are not expunged from the subscription's backlog, even if they are",
                " acknowledged, until they fall out of the `message_retention_duration`",
                " window. This must be true if you would like to [Seek to a timestamp]",
                " (https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time)."
              ]
            },
            {
              "paramName": "message_retention_duration",
              "paramType": ".google.protobuf.Duration",
              "comments": [
                " How long to retain unacknowledged messages in the subscription's backlog,",
                " from the moment a message is published.",
                " If `retain_acked_messages` is true, then this also configures the retention",
                " of acknowledged messages, and thus configures how far back in time a `Seek`",
                " can be done. Defaults to 7 days. Cannot be more than 7 days or less than 10",
                " minutes."
              ]
            },
            {
              "paramName": "labels",
              "paramType": "TYPE_MESSAGE[]",
              "comments": [
                " See <a href=\"https://cloud.google.com/pubsub/docs/labels\"> Creating and",
                " managing labels</a>."
              ]
            },
            {
              "paramName": "enable_message_ordering",
              "paramType": "TYPE_BOOL",
              "comments": [
                " If true, messages published with the same `ordering_key` in `PubsubMessage`",
                " will be delivered to the subscribers in the order in which they",
                " are received by the Pub/Sub system. Otherwise, they may be delivered in",
                " any order."
              ]
            },
            {
              "paramName": "expiration_policy",
              "paramType": ".google.pubsub.v1.ExpirationPolicy",
              "comments": [
                " A policy that specifies the conditions for this subscription's expiration.",
                " A subscription is considered active as long as any connected subscriber is",
                " successfully consuming messages from the subscription or is issuing",
                " operations on the subscription. If `expiration_policy` is not set, a",
                " *default policy* with `ttl` of 31 days will be used. The minimum allowed",
                " value for `expiration_policy.ttl` is 1 day."
              ]
            },
            {
              "paramName": "filter",
              "paramType": "TYPE_STRING",
              "comments": [
                " An expression written in the Pub/Sub [filter",
                " language](https://cloud.google.com/pubsub/docs/filtering). If non-empty,",
                " then only `PubsubMessage`s whose `attributes` field matches the filter are",
                " delivered on this subscription. If empty, then no messages are filtered",
                " out."
              ]
            },
            {
              "paramName": "dead_letter_policy",
              "paramType": ".google.pubsub.v1.DeadLetterPolicy",
              "comments": [
                " A policy that specifies the conditions for dead lettering messages in",
                " this subscription. If dead_letter_policy is not set, dead lettering",
                " is disabled.",
                "",
                " The Cloud Pub/Sub service account associated with this subscriptions's",
                " parent project (i.e.,",
                " service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have",
                " permission to Acknowledge() messages on this subscription."
              ]
            },
            {
              "paramName": "retry_policy",
              "paramType": ".google.pubsub.v1.RetryPolicy",
              "comments": [
                " A policy that specifies how Pub/Sub retries message delivery for this",
                " subscription.",
                "",
                " If not set, the default retry policy is applied. This generally implies",
                " that messages will be retried as soon as possible for healthy subscribers.",
                " RetryPolicy will be triggered on NACKs or acknowledgement deadline",
                " exceeded events for a given message."
              ]
            },
            {
              "paramName": "detached",
              "paramType": "TYPE_BOOL",
              "comments": [
                " Indicates whether the subscription is detached from its topic. Detached",
                " subscriptions don't receive messages from their topic and don't retain any",
                " backlog. `Pull` and `StreamingPull` requests will return",
                " FAILED_PRECONDITION. If the subscription is a push subscription, pushes to",
                " the endpoint will not be made."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "name"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.GetSubscriptionRequest",
          "outputInterface": ".google.pubsub.v1.Subscription",
          "comments": [
            " Gets the configuration details of a subscription.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "GetSubscription",
          "inputType": ".google.pubsub.v1.GetSubscriptionRequest",
          "outputType": ".google.pubsub.v1.Subscription",
          "options": {
            ".google.api.methodSignature": [
              "subscription"
            ],
            ".google.api.http": {
              "get": "/v1/{subscription=projects/*/subscriptions/*}"
            }
          },
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the subscription to get.",
                " Format is `projects/{project}/subscriptions/{sub}`."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "subscription"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.UpdateSubscriptionRequest",
          "outputInterface": ".google.pubsub.v1.Subscription",
          "comments": [
            " Updates an existing subscription. Note that certain properties of a",
            " subscription, such as its topic, are not modifiable.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "UpdateSubscription",
          "inputType": ".google.pubsub.v1.UpdateSubscriptionRequest",
          "outputType": ".google.pubsub.v1.Subscription",
          "options": {
            ".google.api.http": {
              "patch": "/v1/{subscription.name=projects/*/subscriptions/*}",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": ".google.pubsub.v1.Subscription",
              "comments": [
                " Required. The updated subscription object."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "update_mask",
              "paramType": ".google.protobuf.FieldMask",
              "comments": [
                " Required. Indicates which fields in the provided subscription to update.",
                " Must be specified and non-empty."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "subscription",
              "name"
            ]
          ]
        },
        {
          "pagingFieldName": "subscriptions",
          "pagingResponseType": ".google.pubsub.v1.Subscription",
          "ignoreMapPagingMethod": false,
          "inputInterface": ".google.pubsub.v1.ListSubscriptionsRequest",
          "outputInterface": ".google.pubsub.v1.ListSubscriptionsResponse",
          "comments": [
            " Lists matching subscriptions.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ListSubscriptions",
          "inputType": ".google.pubsub.v1.ListSubscriptionsRequest",
          "outputType": ".google.pubsub.v1.ListSubscriptionsResponse",
          "options": {
            ".google.api.methodSignature": [
              "project"
            ],
            ".google.api.http": {
              "get": "/v1/{project=projects/*}/subscriptions"
            }
          },
          "paramComment": [
            {
              "paramName": "project",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the project in which to list subscriptions.",
                " Format is `projects/{project-id}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "page_size",
              "paramType": "TYPE_INT32",
              "comments": [
                " Maximum number of subscriptions to return."
              ]
            },
            {
              "paramName": "page_token",
              "paramType": "TYPE_STRING",
              "comments": [
                " The value returned by the last `ListSubscriptionsResponse`; indicates that",
                " this is a continuation of a prior `ListSubscriptions` call, and that the",
                " system should return the next page of data."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "project"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.DeleteSubscriptionRequest",
          "outputInterface": ".google.protobuf.Empty",
          "comments": [
            " Deletes an existing subscription. All messages retained in the subscription",
            " are immediately dropped. Calls to `Pull` after deletion will return",
            " `NOT_FOUND`. After a subscription is deleted, a new one may be created with",
            " the same name, but the new one has no association with the old",
            " subscription or its topic unless the same topic is specified.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "DeleteSubscription",
          "inputType": ".google.pubsub.v1.DeleteSubscriptionRequest",
          "outputType": ".google.protobuf.Empty",
          "options": {
            ".google.api.methodSignature": [
              "subscription"
            ],
            ".google.api.http": {
              "delete": "/v1/{subscription=projects/*/subscriptions/*}"
            }
          },
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The subscription to delete.",
                " Format is `projects/{project}/subscriptions/{sub}`."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "subscription"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.ModifyAckDeadlineRequest",
          "outputInterface": ".google.protobuf.Empty",
          "comments": [
            " Modifies the ack deadline for a specific message. This method is useful",
            " to indicate that more time is needed to process a message by the",
            " subscriber, or to make the message available for redelivery if the",
            " processing was interrupted. Note that this does not modify the",
            " subscription-level `ackDeadlineSeconds` used for subsequent messages.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ModifyAckDeadline",
          "inputType": ".google.pubsub.v1.ModifyAckDeadlineRequest",
          "outputType": ".google.protobuf.Empty",
          "options": {
            ".google.api.methodSignature": [
              "subscription,ack_ids,ack_deadline_seconds"
            ],
            ".google.api.http": {
              "post": "/v1/{subscription=projects/*/subscriptions/*}:modifyAckDeadline",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the subscription.",
                " Format is `projects/{project}/subscriptions/{sub}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "ack_ids",
              "paramType": "TYPE_STRING[]",
              "comments": [
                " Required. List of acknowledgment IDs."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "ack_deadline_seconds",
              "paramType": "TYPE_INT32",
              "comments": [
                " Required. The new ack deadline with respect to the time this request was",
                " sent to the Pub/Sub system. For example, if the value is 10, the new ack",
                " deadline will expire 10 seconds after the `ModifyAckDeadline` call was",
                " made. Specifying zero might immediately make the message available for",
                " delivery to another subscriber client. This typically results in an",
                " increase in the rate of message redeliveries (that is, duplicates).",
                " The minimum deadline you can specify is 0 seconds.",
                " The maximum deadline you can specify is 600 seconds (10 minutes)."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "subscription"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.AcknowledgeRequest",
          "outputInterface": ".google.protobuf.Empty",
          "comments": [
            " Acknowledges the messages associated with the `ack_ids` in the",
            " `AcknowledgeRequest`. The Pub/Sub system can remove the relevant messages",
            " from the subscription.",
            "",
            " Acknowledging a message whose ack deadline has expired may succeed,",
            " but such a message may be redelivered later. Acknowledging a message more",
            " than once will not result in an error.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "Acknowledge",
          "inputType": ".google.pubsub.v1.AcknowledgeRequest",
          "outputType": ".google.protobuf.Empty",
          "options": {
            ".google.api.methodSignature": [
              "subscription,ack_ids"
            ],
            ".google.api.http": {
              "post": "/v1/{subscription=projects/*/subscriptions/*}:acknowledge",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The subscription whose message is being acknowledged.",
                " Format is `projects/{project}/subscriptions/{sub}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "ack_ids",
              "paramType": "TYPE_STRING[]",
              "comments": [
                " Required. The acknowledgment ID for the messages being acknowledged that",
                " was returned by the Pub/Sub system in the `Pull` response. Must not be",
                " empty."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "subscription"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.PullRequest",
          "outputInterface": ".google.pubsub.v1.PullResponse",
          "comments": [
            " Pulls messages from the server. The server may return `UNAVAILABLE` if",
            " there are too many concurrent pull requests pending for the given",
            " subscription.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "Pull",
          "inputType": ".google.pubsub.v1.PullRequest",
          "outputType": ".google.pubsub.v1.PullResponse",
          "options": {
            ".google.api.methodSignature": [
              "subscription,return_immediately,max_messages"
            ],
            ".google.api.http": {
              "post": "/v1/{subscription=projects/*/subscriptions/*}:pull",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The subscription from which messages should be pulled.",
                " Format is `projects/{project}/subscriptions/{sub}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "return_immediately",
              "paramType": "TYPE_BOOL",
              "comments": [
                " Optional. If this field set to true, the system will respond immediately",
                " even if it there are no messages available to return in the `Pull`",
                " response. Otherwise, the system may wait (for a bounded amount of time)",
                " until at least one message is available, rather than returning no messages.",
                " Warning: setting this field to `true` is discouraged because it adversely",
                " impacts the performance of `Pull` operations. We recommend that users do",
                " not set this field."
              ],
              "fieldBehavior": 1
            },
            {
              "paramName": "max_messages",
              "paramType": "TYPE_INT32",
              "comments": [
                " Required. The maximum number of messages to return for this request. Must",
                " be a positive integer. The Pub/Sub system may return fewer than the number",
                " specified."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "subscription"
            ]
          ]
        },
        {
          "streaming": "BIDI_STREAMING",
          "inputInterface": ".google.pubsub.v1.StreamingPullRequest",
          "outputInterface": ".google.pubsub.v1.StreamingPullResponse",
          "comments": [
            " Establishes a stream with the server, which sends messages down to the",
            " client. The client streams acknowledgements and ack deadline modifications",
            " back to the server. The server will close the stream and return the status",
            " on any error. The server may close the stream with status `UNAVAILABLE` to",
            " reassign server-side resources, in which case, the client should",
            " re-establish the stream. Flow control can be achieved by configuring the",
            " underlying RPC channel.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "StreamingPull",
          "inputType": ".google.pubsub.v1.StreamingPullRequest",
          "outputType": ".google.pubsub.v1.StreamingPullResponse",
          "options": {},
          "clientStreaming": true,
          "serverStreaming": true,
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The subscription for which to initialize the new stream. This",
                " must be provided in the first request on the stream, and must not be set in",
                " subsequent requests from client to server.",
                " Format is `projects/{project}/subscriptions/{sub}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "ack_ids",
              "paramType": "TYPE_STRING[]",
              "comments": [
                " List of acknowledgement IDs for acknowledging previously received messages",
                " (received on this stream or a different stream). If an ack ID has expired,",
                " the corresponding message may be redelivered later. Acknowledging a message",
                " more than once will not result in an error. If the acknowledgement ID is",
                " malformed, the stream will be aborted with status `INVALID_ARGUMENT`."
              ]
            },
            {
              "paramName": "modify_deadline_seconds",
              "paramType": "TYPE_INT32[]",
              "comments": [
                " The list of new ack deadlines for the IDs listed in",
                " `modify_deadline_ack_ids`. The size of this list must be the same as the",
                " size of `modify_deadline_ack_ids`. If it differs the stream will be aborted",
                " with `INVALID_ARGUMENT`. Each element in this list is applied to the",
                " element in the same position in `modify_deadline_ack_ids`. The new ack",
                " deadline is with respect to the time this request was sent to the Pub/Sub",
                " system. Must be >= 0. For example, if the value is 10, the new ack deadline",
                " will expire 10 seconds after this request is received. If the value is 0,",
                " the message is immediately made available for another streaming or",
                " non-streaming pull request. If the value is < 0 (an error), the stream will",
                " be aborted with status `INVALID_ARGUMENT`."
              ]
            },
            {
              "paramName": "modify_deadline_ack_ids",
              "paramType": "TYPE_STRING[]",
              "comments": [
                " List of acknowledgement IDs whose deadline will be modified based on the",
                " corresponding element in `modify_deadline_seconds`. This field can be used",
                " to indicate that more time is needed to process a message by the",
                " subscriber, or to make the message available for redelivery if the",
                " processing was interrupted."
              ]
            },
            {
              "paramName": "stream_ack_deadline_seconds",
              "paramType": "TYPE_INT32",
              "comments": [
                " Required. The ack deadline to use for the stream. This must be provided in",
                " the first request on the stream, but it can also be updated on subsequent",
                " requests from client to server. The minimum deadline you can specify is 10",
                " seconds. The maximum deadline you can specify is 600 seconds (10 minutes)."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "client_id",
              "paramType": "TYPE_STRING",
              "comments": [
                " A unique identifier that is used to distinguish client instances from each",
                " other. Only needs to be provided on the initial request. When a stream",
                " disconnects and reconnects for the same stream, the client_id should be set",
                " to the same value so that state associated with the old stream can be",
                " transferred to the new stream. The same client_id should not be used for",
                " different client instances."
              ]
            },
            {
              "paramName": "max_outstanding_messages",
              "paramType": "TYPE_INT64",
              "comments": [
                " Flow control settings for the maximum number of outstanding messages. When",
                " there are `max_outstanding_messages` or more currently sent to the",
                " streaming pull client that have not yet been acked or nacked, the server",
                " stops sending more messages. The sending of messages resumes once the",
                " number of outstanding messages is less than this value. If the value is",
                " <= 0, there is no limit to the number of outstanding messages. This",
                " property can only be set on the initial StreamingPullRequest. If it is set",
                " on a subsequent request, the stream will be aborted with status",
                " `INVALID_ARGUMENT`."
              ]
            },
            {
              "paramName": "max_outstanding_bytes",
              "paramType": "TYPE_INT64",
              "comments": [
                " Flow control settings for the maximum number of outstanding bytes. When",
                " there are `max_outstanding_bytes` or more worth of messages currently sent",
                " to the streaming pull client that have not yet been acked or nacked, the",
                " server will stop sending more messages. The sending of messages resumes",
                " once the number of outstanding bytes is less than this value. If the value",
                " is <= 0, there is no limit to the number of outstanding bytes. This",
                " property can only be set on the initial StreamingPullRequest. If it is set",
                " on a subsequent request, the stream will be aborted with status",
                " `INVALID_ARGUMENT`."
              ]
            }
          ],
          "headerRequestParams": []
        },
        {
          "inputInterface": ".google.pubsub.v1.ModifyPushConfigRequest",
          "outputInterface": ".google.protobuf.Empty",
          "comments": [
            " Modifies the `PushConfig` for a specified subscription.",
            "",
            " This may be used to change a push subscription to a pull one (signified by",
            " an empty `PushConfig`) or vice versa, or change the endpoint URL and other",
            " attributes of a push subscription. Messages will accumulate for delivery",
            " continuously through the call regardless of changes to the `PushConfig`.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ModifyPushConfig",
          "inputType": ".google.pubsub.v1.ModifyPushConfigRequest",
          "outputType": ".google.protobuf.Empty",
          "options": {
            ".google.api.methodSignature": [
              "subscription,push_config"
            ],
            ".google.api.http": {
              "post": "/v1/{subscription=projects/*/subscriptions/*}:modifyPushConfig",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the subscription.",
                " Format is `projects/{project}/subscriptions/{sub}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "push_config",
              "paramType": ".google.pubsub.v1.PushConfig",
              "comments": [
                " Required. The push configuration for future deliveries.",
                "",
                " An empty `pushConfig` indicates that the Pub/Sub system should",
                " stop pushing messages from the given subscription and allow",
                " messages to be pulled and acknowledged - effectively pausing",
                " the subscription if `Pull` or `StreamingPull` is not called."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "subscription"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.GetSnapshotRequest",
          "outputInterface": ".google.pubsub.v1.Snapshot",
          "comments": [
            " Gets the configuration details of a snapshot. Snapshots are used in",
            " <a href=\"https://cloud.google.com/pubsub/docs/replay-overview\">Seek</a>",
            " operations, which allow you to manage message acknowledgments in bulk. That",
            " is, you can set the acknowledgment state of messages in an existing",
            " subscription to the state captured by a snapshot.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "GetSnapshot",
          "inputType": ".google.pubsub.v1.GetSnapshotRequest",
          "outputType": ".google.pubsub.v1.Snapshot",
          "options": {
            ".google.api.methodSignature": [
              "snapshot"
            ],
            ".google.api.http": {
              "get": "/v1/{snapshot=projects/*/snapshots/*}"
            }
          },
          "paramComment": [
            {
              "paramName": "snapshot",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the snapshot to get.",
                " Format is `projects/{project}/snapshots/{snap}`."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "snapshot"
            ]
          ]
        },
        {
          "pagingFieldName": "snapshots",
          "pagingResponseType": ".google.pubsub.v1.Snapshot",
          "ignoreMapPagingMethod": false,
          "inputInterface": ".google.pubsub.v1.ListSnapshotsRequest",
          "outputInterface": ".google.pubsub.v1.ListSnapshotsResponse",
          "comments": [
            " Lists the existing snapshots. Snapshots are used in [Seek](",
            " https://cloud.google.com/pubsub/docs/replay-overview) operations, which",
            " allow you to manage message acknowledgments in bulk. That is, you can set",
            " the acknowledgment state of messages in an existing subscription to the",
            " state captured by a snapshot.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ListSnapshots",
          "inputType": ".google.pubsub.v1.ListSnapshotsRequest",
          "outputType": ".google.pubsub.v1.ListSnapshotsResponse",
          "options": {
            ".google.api.methodSignature": [
              "project"
            ],
            ".google.api.http": {
              "get": "/v1/{project=projects/*}/snapshots"
            }
          },
          "paramComment": [
            {
              "paramName": "project",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the project in which to list snapshots.",
                " Format is `projects/{project-id}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "page_size",
              "paramType": "TYPE_INT32",
              "comments": [
                " Maximum number of snapshots to return."
              ]
            },
            {
              "paramName": "page_token",
              "paramType": "TYPE_STRING",
              "comments": [
                " The value returned by the last `ListSnapshotsResponse`; indicates that this",
                " is a continuation of a prior `ListSnapshots` call, and that the system",
                " should return the next page of data."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "project"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.CreateSnapshotRequest",
          "outputInterface": ".google.pubsub.v1.Snapshot",
          "comments": [
            " Creates a snapshot from the requested subscription. Snapshots are used in",
            " [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,",
            " which allow you to manage message acknowledgments in bulk. That is, you can",
            " set the acknowledgment state of messages in an existing subscription to the",
            " state captured by a snapshot.",
            " If the snapshot already exists, returns `ALREADY_EXISTS`.",
            " If the requested subscription doesn't exist, returns `NOT_FOUND`.",
            " If the backlog in the subscription is too old -- and the resulting snapshot",
            " would expire in less than 1 hour -- then `FAILED_PRECONDITION` is returned.",
            " See also the `Snapshot.expire_time` field. If the name is not provided in",
            " the request, the server will assign a random",
            " name for this snapshot on the same project as the subscription, conforming",
            " to the [resource name format]",
            " (https://cloud.google.com/pubsub/docs/admin#resource_names). The",
            " generated name is populated in the returned Snapshot object. Note that for",
            " REST API requests, you must specify a name in the request.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "CreateSnapshot",
          "inputType": ".google.pubsub.v1.CreateSnapshotRequest",
          "outputType": ".google.pubsub.v1.Snapshot",
          "options": {
            ".google.api.methodSignature": [
              "name,subscription"
            ],
            ".google.api.http": {
              "put": "/v1/{name=projects/*/snapshots/*}",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "name",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. User-provided name for this snapshot. If the name is not provided",
                " in the request, the server will assign a random name for this snapshot on",
                " the same project as the subscription. Note that for REST API requests, you",
                " must specify a name.  See the <a",
                " href=\"https://cloud.google.com/pubsub/docs/admin#resource_names\"> resource",
                " name rules</a>. Format is `projects/{project}/snapshots/{snap}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The subscription whose backlog the snapshot retains.",
                " Specifically, the created snapshot is guaranteed to retain:",
                "  (a) The existing backlog on the subscription. More precisely, this is",
                "      defined as the messages in the subscription's backlog that are",
                "      unacknowledged upon the successful completion of the",
                "      `CreateSnapshot` request; as well as:",
                "  (b) Any messages published to the subscription's topic following the",
                "      successful completion of the CreateSnapshot request.",
                " Format is `projects/{project}/subscriptions/{sub}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "labels",
              "paramType": "TYPE_MESSAGE[]",
              "comments": [
                " See <a href=\"https://cloud.google.com/pubsub/docs/labels\"> Creating and",
                " managing labels</a>."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "name"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.UpdateSnapshotRequest",
          "outputInterface": ".google.pubsub.v1.Snapshot",
          "comments": [
            " Updates an existing snapshot. Snapshots are used in",
            " <a href=\"https://cloud.google.com/pubsub/docs/replay-overview\">Seek</a>",
            " operations, which allow",
            " you to manage message acknowledgments in bulk. That is, you can set the",
            " acknowledgment state of messages in an existing subscription to the state",
            " captured by a snapshot.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "UpdateSnapshot",
          "inputType": ".google.pubsub.v1.UpdateSnapshotRequest",
          "outputType": ".google.pubsub.v1.Snapshot",
          "options": {
            ".google.api.http": {
              "patch": "/v1/{snapshot.name=projects/*/snapshots/*}",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "snapshot",
              "paramType": ".google.pubsub.v1.Snapshot",
              "comments": [
                " Required. The updated snapshot object."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "update_mask",
              "paramType": ".google.protobuf.FieldMask",
              "comments": [
                " Required. Indicates which fields in the provided snapshot to update.",
                " Must be specified and non-empty."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "snapshot",
              "name"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.DeleteSnapshotRequest",
          "outputInterface": ".google.protobuf.Empty",
          "comments": [
            " Removes an existing snapshot. Snapshots are used in [Seek]",
            " (https://cloud.google.com/pubsub/docs/replay-overview) operations, which",
            " allow you to manage message acknowledgments in bulk. That is, you can set",
            " the acknowledgment state of messages in an existing subscription to the",
            " state captured by a snapshot.",
            " When the snapshot is deleted, all messages retained in the snapshot",
            " are immediately dropped. After a snapshot is deleted, a new one may be",
            " created with the same name, but the new one has no association with the old",
            " snapshot or its subscription, unless the same subscription is specified.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "DeleteSnapshot",
          "inputType": ".google.pubsub.v1.DeleteSnapshotRequest",
          "outputType": ".google.protobuf.Empty",
          "options": {
            ".google.api.methodSignature": [
              "snapshot"
            ],
            ".google.api.http": {
              "delete": "/v1/{snapshot=projects/*/snapshots/*}"
            }
          },
          "paramComment": [
            {
              "paramName": "snapshot",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the snapshot to delete.",
                " Format is `projects/{project}/snapshots/{snap}`."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "snapshot"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.SeekRequest",
          "outputInterface": ".google.pubsub.v1.SeekResponse",
          "comments": [
            " Seeks an existing subscription to a point in time or to a given snapshot,",
            " whichever is provided in the request. Snapshots are used in [Seek]",
            " (https://cloud.google.com/pubsub/docs/replay-overview) operations, which",
            " allow you to manage message acknowledgments in bulk. That is, you can set",
            " the acknowledgment state of messages in an existing subscription to the",
            " state captured by a snapshot. Note that both the subscription and the",
            " snapshot must be on the same topic.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "Seek",
          "inputType": ".google.pubsub.v1.SeekRequest",
          "outputType": ".google.pubsub.v1.SeekResponse",
          "options": {
            ".google.api.http": {
              "post": "/v1/{subscription=projects/*/subscriptions/*}:seek",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The subscription to affect."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "time",
              "paramType": ".google.protobuf.Timestamp",
              "comments": [
                " The time to seek to.",
                " Messages retained in the subscription that were published before this",
                " time are marked as acknowledged, and messages retained in the",
                " subscription that were published after this time are marked as",
                " unacknowledged. Note that this operation affects only those messages",
                " retained in the subscription (configured by the combination of",
                " `message_retention_duration` and `retain_acked_messages`). For example,",
                " if `time` corresponds to a point before the message retention",
                " window (or to a point before the system's notion of the subscription",
                " creation time), only retained messages will be marked as unacknowledged,",
                " and already-expunged messages will not be restored."
              ]
            },
            {
              "paramName": "snapshot",
              "paramType": "TYPE_STRING",
              "comments": [
                " The snapshot to seek to. The snapshot's topic must be the same as that of",
                " the provided subscription.",
                " Format is `projects/{project}/snapshots/{snap}`."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "subscription"
            ]
          ]
        }
      ],
      "name": "Subscriber",
      "options": {
        ".google.api.defaultHost": "pubsub.googleapis.com",
        ".google.api.oauthScopes": "https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/pubsub"
      },
      "packageName": "google.pubsub.v1",
      "protoFile": "google/pubsub/v1/pubsub.proto",
      "comments": [
        " The service that an application uses to manipulate subscriptions and to",
        " consume messages from a subscription via the `Pull` method or by",
        " establishing a bi-directional stream using the `StreamingPull` method."
      ],
      "commentsMap": {
        "comments": {
          "Http:rules": {
            "paramName": "rules",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " A list of HTTP configuration rules that apply to individual API methods.",
              "",
              " **NOTE:** All service configuration rules follow \"last one wins\" order."
            ]
          },
          "Http:fully_decode_reserved_expansion": {
            "paramName": "fully_decode_reserved_expansion",
            "paramType": "TYPE_BOOL",
            "comments": [
              " When set to true, URL path parameters will be fully URI-decoded except in",
              " cases of single segment matches in reserved expansion, where \"%2F\" will be",
              " left encoded.",
              "",
              " The default behavior is to not decode RFC 6570 reserved characters in multi",
              " segment matches."
            ]
          },
          "HttpRule:selector": {
            "paramName": "selector",
            "paramType": "TYPE_STRING",
            "comments": [
              " Selects a method to which this rule applies.",
              "",
              " Refer to [selector][google.api.DocumentationRule.selector] for syntax details."
            ]
          },
          "HttpRule:get": {
            "paramName": "get",
            "paramType": "TYPE_STRING",
            "comments": [
              " Maps to HTTP GET. Used for listing and getting information about",
              " resources."
            ]
          },
          "HttpRule:put": {
            "paramName": "put",
            "paramType": "TYPE_STRING",
            "comments": [
              " Maps to HTTP PUT. Used for replacing a resource."
            ]
          },
          "HttpRule:post": {
            "paramName": "post",
            "paramType": "TYPE_STRING",
            "comments": [
              " Maps to HTTP POST. Used for creating a resource or performing an action."
            ]
          },
          "HttpRule:delete": {
            "paramName": "delete",
            "paramType": "TYPE_STRING",
            "comments": [
              " Maps to HTTP DELETE. Used for deleting a resource."
            ]
          },
          "HttpRule:patch": {
            "paramName": "patch",
            "paramType": "TYPE_STRING",
            "comments": [
              " Maps to HTTP PATCH. Used for updating a resource."
            ]
          },
          "HttpRule:custom": {
            "paramName": "custom",
            "paramType": ".google.api.CustomHttpPattern",
            "comments": [
              " The custom pattern is used for specifying an HTTP method that is not",
              " included in the `pattern` field, such as HEAD, or \"*\" to leave the",
              " HTTP method unspecified for this rule. The wild-card rule is useful",
              " for services that provide content to Web (HTML) clients."
            ]
          },
          "HttpRule:body": {
            "paramName": "body",
            "paramType": "TYPE_STRING",
            "comments": [
              " The name of the request field whose value is mapped to the HTTP request",
              " body, or `*` for mapping all request fields not captured by the path",
              " pattern to the HTTP body, or omitted for not having any HTTP request body.",
              "",
              " NOTE: the referred field must be present at the top-level of the request",
              " message type."
            ]
          },
          "HttpRule:response_body": {
            "paramName": "response_body",
            "paramType": "TYPE_STRING",
            "comments": [
              " Optional. The name of the response field whose value is mapped to the HTTP",
              " response body. When omitted, the entire response message will be used",
              " as the HTTP response body.",
              "",
              " NOTE: The referred field must be present at the top-level of the response",
              " message type."
            ]
          },
          "HttpRule:additional_bindings": {
            "paramName": "additional_bindings",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Additional HTTP bindings for the selector. Nested bindings must",
              " not contain an `additional_bindings` field themselves (that is,",
              " the nesting may only be one level deep)."
            ]
          },
          "CustomHttpPattern:kind": {
            "paramName": "kind",
            "paramType": "TYPE_STRING",
            "comments": [
              " The name of this custom HTTP verb."
            ]
          },
          "CustomHttpPattern:path": {
            "paramName": "path",
            "paramType": "TYPE_STRING",
            "comments": [
              " The path matched by this custom verb."
            ]
          },
          "FileDescriptorSet:file": {
            "paramName": "file",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "FileDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "FileDescriptorProto:package": {
            "paramName": "package",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "FileDescriptorProto:dependency": {
            "paramName": "dependency",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Names of files imported by this file."
            ]
          },
          "FileDescriptorProto:public_dependency": {
            "paramName": "public_dependency",
            "paramType": "TYPE_INT32[]",
            "comments": [
              " Indexes of the public imported files in the dependency list above."
            ]
          },
          "FileDescriptorProto:weak_dependency": {
            "paramName": "weak_dependency",
            "paramType": "TYPE_INT32[]",
            "comments": [
              " Indexes of the weak imported files in the dependency list.",
              " For Google-internal migration only. Do not use."
            ]
          },
          "FileDescriptorProto:message_type": {
            "paramName": "message_type",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " All top-level definitions in this file."
            ]
          },
          "FileDescriptorProto:enum_type": {
            "paramName": "enum_type",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "FileDescriptorProto:service": {
            "paramName": "service",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "FileDescriptorProto:extension": {
            "paramName": "extension",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "FileDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.FileOptions",
            "comments": []
          },
          "FileDescriptorProto:source_code_info": {
            "paramName": "source_code_info",
            "paramType": ".google.protobuf.SourceCodeInfo",
            "comments": [
              " This field contains optional information about the original source code.",
              " You may safely remove this entire field without harming runtime",
              " functionality of the descriptors -- the information is needed only by",
              " development tools."
            ]
          },
          "FileDescriptorProto:syntax": {
            "paramName": "syntax",
            "paramType": "TYPE_STRING",
            "comments": [
              " The syntax of the proto file.",
              " The supported values are \"proto2\" and \"proto3\"."
            ]
          },
          "DescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "DescriptorProto:field": {
            "paramName": "field",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:extension": {
            "paramName": "extension",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:nested_type": {
            "paramName": "nested_type",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:enum_type": {
            "paramName": "enum_type",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:extension_range": {
            "paramName": "extension_range",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:oneof_decl": {
            "paramName": "oneof_decl",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.MessageOptions",
            "comments": []
          },
          "DescriptorProto:reserved_range": {
            "paramName": "reserved_range",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "DescriptorProto:reserved_name": {
            "paramName": "reserved_name",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Reserved field names, which may not be used by fields in the same message.",
              " A given name may only be reserved once."
            ]
          },
          "ExtensionRangeOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "FieldDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "FieldDescriptorProto:number": {
            "paramName": "number",
            "paramType": "TYPE_INT32",
            "comments": []
          },
          "FieldDescriptorProto:label": {
            "paramName": "label",
            "paramType": ".google.protobuf.FieldDescriptorProto.Label",
            "comments": []
          },
          "FieldDescriptorProto:type": {
            "paramName": "type",
            "paramType": ".google.protobuf.FieldDescriptorProto.Type",
            "comments": [
              " If type_name is set, this need not be set.  If both this and type_name",
              " are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP."
            ]
          },
          "FieldDescriptorProto:type_name": {
            "paramName": "type_name",
            "paramType": "TYPE_STRING",
            "comments": [
              " For message and enum types, this is the name of the type.  If the name",
              " starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping",
              " rules are used to find the type (i.e. first the nested types within this",
              " message are searched, then within the parent, on up to the root",
              " namespace)."
            ]
          },
          "FieldDescriptorProto:extendee": {
            "paramName": "extendee",
            "paramType": "TYPE_STRING",
            "comments": [
              " For extensions, this is the name of the type being extended.  It is",
              " resolved in the same manner as type_name."
            ]
          },
          "FieldDescriptorProto:default_value": {
            "paramName": "default_value",
            "paramType": "TYPE_STRING",
            "comments": [
              " For numeric types, contains the original text representation of the value.",
              " For booleans, \"true\" or \"false\".",
              " For strings, contains the default text contents (not escaped in any way).",
              " For bytes, contains the C escaped value.  All bytes >= 128 are escaped."
            ]
          },
          "FieldDescriptorProto:oneof_index": {
            "paramName": "oneof_index",
            "paramType": "TYPE_INT32",
            "comments": [
              " If set, gives the index of a oneof in the containing type's oneof_decl",
              " list.  This field is a member of that oneof."
            ]
          },
          "FieldDescriptorProto:json_name": {
            "paramName": "json_name",
            "paramType": "TYPE_STRING",
            "comments": [
              " JSON name of this field. The value is set by protocol compiler. If the",
              " user has set a \"json_name\" option on this field, that option's value",
              " will be used. Otherwise, it's deduced from the field's name by converting",
              " it to camelCase."
            ]
          },
          "FieldDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.FieldOptions",
            "comments": []
          },
          "FieldDescriptorProto:proto3_optional": {
            "paramName": "proto3_optional",
            "paramType": "TYPE_BOOL",
            "comments": [
              " If true, this is a proto3 \"optional\". When a proto3 field is optional, it",
              " tracks presence regardless of field type.",
              "",
              " When proto3_optional is true, this field must be belong to a oneof to",
              " signal to old proto3 clients that presence is tracked for this field. This",
              " oneof is known as a \"synthetic\" oneof, and this field must be its sole",
              " member (each proto3 optional field gets its own synthetic oneof). Synthetic",
              " oneofs exist in the descriptor only, and do not generate any API. Synthetic",
              " oneofs must be ordered after all \"real\" oneofs.",
              "",
              " For message fields, proto3_optional doesn't create any semantic change,",
              " since non-repeated message fields always track presence. However it still",
              " indicates the semantic detail of whether the user wrote \"optional\" or not.",
              " This can be useful for round-tripping the .proto file. For consistency we",
              " give message fields a synthetic oneof also, even though it is not required",
              " to track presence. This is especially important because the parser can't",
              " tell if a field is a message or an enum, so it must always create a",
              " synthetic oneof.",
              "",
              " Proto2 optional fields do not set this flag, because they already indicate",
              " optional with `LABEL_OPTIONAL`."
            ]
          },
          "OneofDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "OneofDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.OneofOptions",
            "comments": []
          },
          "EnumDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "EnumDescriptorProto:value": {
            "paramName": "value",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "EnumDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.EnumOptions",
            "comments": []
          },
          "EnumDescriptorProto:reserved_range": {
            "paramName": "reserved_range",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Range of reserved numeric values. Reserved numeric values may not be used",
              " by enum values in the same enum declaration. Reserved ranges may not",
              " overlap."
            ]
          },
          "EnumDescriptorProto:reserved_name": {
            "paramName": "reserved_name",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Reserved enum value names, which may not be reused. A given name may only",
              " be reserved once."
            ]
          },
          "EnumValueDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "EnumValueDescriptorProto:number": {
            "paramName": "number",
            "paramType": "TYPE_INT32",
            "comments": []
          },
          "EnumValueDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.EnumValueOptions",
            "comments": []
          },
          "ServiceDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "ServiceDescriptorProto:method": {
            "paramName": "method",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "ServiceDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.ServiceOptions",
            "comments": []
          },
          "MethodDescriptorProto:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "MethodDescriptorProto:input_type": {
            "paramName": "input_type",
            "paramType": "TYPE_STRING",
            "comments": [
              " Input and output type names.  These are resolved in the same way as",
              " FieldDescriptorProto.type_name, but must refer to a message type."
            ]
          },
          "MethodDescriptorProto:output_type": {
            "paramName": "output_type",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "MethodDescriptorProto:options": {
            "paramName": "options",
            "paramType": ".google.protobuf.MethodOptions",
            "comments": []
          },
          "MethodDescriptorProto:client_streaming": {
            "paramName": "client_streaming",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Identifies if client streams multiple client messages"
            ]
          },
          "MethodDescriptorProto:server_streaming": {
            "paramName": "server_streaming",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Identifies if server streams multiple server messages"
            ]
          },
          "FileOptions:java_package": {
            "paramName": "java_package",
            "paramType": "TYPE_STRING",
            "comments": [
              " Sets the Java package where classes generated from this .proto will be",
              " placed.  By default, the proto package is used, but this is often",
              " inappropriate because proto packages do not normally start with backwards",
              " domain names."
            ]
          },
          "FileOptions:java_outer_classname": {
            "paramName": "java_outer_classname",
            "paramType": "TYPE_STRING",
            "comments": [
              " Controls the name of the wrapper Java class generated for the .proto file.",
              " That class will always contain the .proto file's getDescriptor() method as",
              " well as any top-level extensions defined in the .proto file.",
              " If java_multiple_files is disabled, then all the other classes from the",
              " .proto file will be nested inside the single wrapper outer class."
            ]
          },
          "FileOptions:java_multiple_files": {
            "paramName": "java_multiple_files",
            "paramType": "TYPE_BOOL",
            "comments": [
              " If enabled, then the Java code generator will generate a separate .java",
              " file for each top-level message, enum, and service defined in the .proto",
              " file.  Thus, these types will *not* be nested inside the wrapper class",
              " named by java_outer_classname.  However, the wrapper class will still be",
              " generated to contain the file's getDescriptor() method as well as any",
              " top-level extensions defined in the file."
            ]
          },
          "FileOptions:java_generate_equals_and_hash": {
            "paramName": "java_generate_equals_and_hash",
            "paramType": "TYPE_BOOL",
            "comments": [
              " This option does nothing."
            ]
          },
          "FileOptions:java_string_check_utf8": {
            "paramName": "java_string_check_utf8",
            "paramType": "TYPE_BOOL",
            "comments": [
              " If set true, then the Java2 code generator will generate code that",
              " throws an exception whenever an attempt is made to assign a non-UTF-8",
              " byte sequence to a string field.",
              " Message reflection will do the same.",
              " However, an extension field still accepts non-UTF-8 byte sequences.",
              " This option has no effect on when used with the lite runtime."
            ]
          },
          "FileOptions:optimize_for": {
            "paramName": "optimize_for",
            "paramType": ".google.protobuf.FileOptions.OptimizeMode",
            "comments": []
          },
          "FileOptions:go_package": {
            "paramName": "go_package",
            "paramType": "TYPE_STRING",
            "comments": [
              " Sets the Go package where structs generated from this .proto will be",
              " placed. If omitted, the Go package will be derived from the following:",
              "   - The basename of the package import path, if provided.",
              "   - Otherwise, the package statement in the .proto file, if present.",
              "   - Otherwise, the basename of the .proto file, without extension."
            ]
          },
          "FileOptions:cc_generic_services": {
            "paramName": "cc_generic_services",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Should generic services be generated in each language?  \"Generic\" services",
              " are not specific to any particular RPC system.  They are generated by the",
              " main code generators in each language (without additional plugins).",
              " Generic services were the only kind of service generation supported by",
              " early versions of google.protobuf.",
              "",
              " Generic services are now considered deprecated in favor of using plugins",
              " that generate code specific to your particular RPC system.  Therefore,",
              " these default to false.  Old code which depends on generic services should",
              " explicitly set them to true."
            ]
          },
          "FileOptions:java_generic_services": {
            "paramName": "java_generic_services",
            "paramType": "TYPE_BOOL",
            "comments": []
          },
          "FileOptions:py_generic_services": {
            "paramName": "py_generic_services",
            "paramType": "TYPE_BOOL",
            "comments": []
          },
          "FileOptions:php_generic_services": {
            "paramName": "php_generic_services",
            "paramType": "TYPE_BOOL",
            "comments": []
          },
          "FileOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this file deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for everything in the file, or it will be completely ignored; in the very",
              " least, this is a formalization for deprecating files."
            ]
          },
          "FileOptions:cc_enable_arenas": {
            "paramName": "cc_enable_arenas",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Enables the use of arenas for the proto messages in this file. This applies",
              " only to generated classes for C++."
            ]
          },
          "FileOptions:objc_class_prefix": {
            "paramName": "objc_class_prefix",
            "paramType": "TYPE_STRING",
            "comments": [
              " Sets the objective c class prefix which is prepended to all objective c",
              " generated classes from this .proto. There is no default."
            ]
          },
          "FileOptions:csharp_namespace": {
            "paramName": "csharp_namespace",
            "paramType": "TYPE_STRING",
            "comments": [
              " Namespace for generated classes; defaults to the package."
            ]
          },
          "FileOptions:swift_prefix": {
            "paramName": "swift_prefix",
            "paramType": "TYPE_STRING",
            "comments": [
              " By default Swift generators will take the proto package and CamelCase it",
              " replacing '.' with underscore and use that to prefix the types/symbols",
              " defined. When this options is provided, they will use this value instead",
              " to prefix the types/symbols defined."
            ]
          },
          "FileOptions:php_class_prefix": {
            "paramName": "php_class_prefix",
            "paramType": "TYPE_STRING",
            "comments": [
              " Sets the php class prefix which is prepended to all php generated classes",
              " from this .proto. Default is empty."
            ]
          },
          "FileOptions:php_namespace": {
            "paramName": "php_namespace",
            "paramType": "TYPE_STRING",
            "comments": [
              " Use this option to change the namespace of php generated classes. Default",
              " is empty. When this option is empty, the package name will be used for",
              " determining the namespace."
            ]
          },
          "FileOptions:php_metadata_namespace": {
            "paramName": "php_metadata_namespace",
            "paramType": "TYPE_STRING",
            "comments": [
              " Use this option to change the namespace of php generated metadata classes.",
              " Default is empty. When this option is empty, the proto file name will be",
              " used for determining the namespace."
            ]
          },
          "FileOptions:ruby_package": {
            "paramName": "ruby_package",
            "paramType": "TYPE_STRING",
            "comments": [
              " Use this option to change the package of ruby generated classes. Default",
              " is empty. When this option is not set, the package name will be used for",
              " determining the ruby package."
            ]
          },
          "FileOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here.",
              " See the documentation for the \"Options\" section above."
            ]
          },
          "MessageOptions:message_set_wire_format": {
            "paramName": "message_set_wire_format",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Set true to use the old proto1 MessageSet wire format for extensions.",
              " This is provided for backwards-compatibility with the MessageSet wire",
              " format.  You should not use this for any other reason:  It's less",
              " efficient, has fewer features, and is more complicated.",
              "",
              " The message must be defined exactly as follows:",
              "   message Foo {",
              "     option message_set_wire_format = true;",
              "     extensions 4 to max;",
              "   }",
              " Note that the message cannot have any defined fields; MessageSets only",
              " have extensions.",
              "",
              " All extensions of your type must be singular messages; e.g. they cannot",
              " be int32s, enums, or repeated messages.",
              "",
              " Because this is an option, the above two restrictions are not enforced by",
              " the protocol compiler."
            ]
          },
          "MessageOptions:no_standard_descriptor_accessor": {
            "paramName": "no_standard_descriptor_accessor",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Disables the generation of the standard \"descriptor()\" accessor, which can",
              " conflict with a field of the same name.  This is meant to make migration",
              " from proto1 easier; new code should avoid fields named \"descriptor\"."
            ]
          },
          "MessageOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this message deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for the message, or it will be completely ignored; in the very least,",
              " this is a formalization for deprecating messages."
            ]
          },
          "MessageOptions:map_entry": {
            "paramName": "map_entry",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Whether the message is an automatically generated map entry type for the",
              " maps field.",
              "",
              " For maps fields:",
              "     map<KeyType, ValueType> map_field = 1;",
              " The parsed descriptor looks like:",
              "     message MapFieldEntry {",
              "         option map_entry = true;",
              "         optional KeyType key = 1;",
              "         optional ValueType value = 2;",
              "     }",
              "     repeated MapFieldEntry map_field = 1;",
              "",
              " Implementations may choose not to generate the map_entry=true message, but",
              " use a native map in the target language to hold the keys and values.",
              " The reflection APIs in such implementations still need to work as",
              " if the field is a repeated message field.",
              "",
              " NOTE: Do not set the option in .proto files. Always use the maps syntax",
              " instead. The option should only be implicitly set by the proto compiler",
              " parser."
            ]
          },
          "MessageOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "FieldOptions:ctype": {
            "paramName": "ctype",
            "paramType": ".google.protobuf.FieldOptions.CType",
            "comments": [
              " The ctype option instructs the C++ code generator to use a different",
              " representation of the field than it normally would.  See the specific",
              " options below.  This option is not yet implemented in the open source",
              " release -- sorry, we'll try to include it in a future version!"
            ]
          },
          "FieldOptions:packed": {
            "paramName": "packed",
            "paramType": "TYPE_BOOL",
            "comments": [
              " The packed option can be enabled for repeated primitive fields to enable",
              " a more efficient representation on the wire. Rather than repeatedly",
              " writing the tag and type for each element, the entire array is encoded as",
              " a single length-delimited blob. In proto3, only explicit setting it to",
              " false will avoid using packed encoding."
            ]
          },
          "FieldOptions:jstype": {
            "paramName": "jstype",
            "paramType": ".google.protobuf.FieldOptions.JSType",
            "comments": [
              " The jstype option determines the JavaScript type used for values of the",
              " field.  The option is permitted only for 64 bit integral and fixed types",
              " (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING",
              " is represented as JavaScript string, which avoids loss of precision that",
              " can happen when a large value is converted to a floating point JavaScript.",
              " Specifying JS_NUMBER for the jstype causes the generated JavaScript code to",
              " use the JavaScript \"number\" type.  The behavior of the default option",
              " JS_NORMAL is implementation dependent.",
              "",
              " This option is an enum to permit additional types to be added, e.g.",
              " goog.math.Integer."
            ]
          },
          "FieldOptions:lazy": {
            "paramName": "lazy",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Should this field be parsed lazily?  Lazy applies only to message-type",
              " fields.  It means that when the outer message is initially parsed, the",
              " inner message's contents will not be parsed but instead stored in encoded",
              " form.  The inner message will actually be parsed when it is first accessed.",
              "",
              " This is only a hint.  Implementations are free to choose whether to use",
              " eager or lazy parsing regardless of the value of this option.  However,",
              " setting this option true suggests that the protocol author believes that",
              " using lazy parsing on this field is worth the additional bookkeeping",
              " overhead typically needed to implement it.",
              "",
              " This option does not affect the public interface of any generated code;",
              " all method signatures remain the same.  Furthermore, thread-safety of the",
              " interface is not affected by this option; const methods remain safe to",
              " call from multiple threads concurrently, while non-const methods continue",
              " to require exclusive access.",
              "",
              "",
              " Note that implementations may choose not to check required fields within",
              " a lazy sub-message.  That is, calling IsInitialized() on the outer message",
              " may return true even if the inner message has missing required fields.",
              " This is necessary because otherwise the inner message would have to be",
              " parsed in order to perform the check, defeating the purpose of lazy",
              " parsing.  An implementation which chooses not to check required fields",
              " must be consistent about it.  That is, for any particular sub-message, the",
              " implementation must either *always* check its required fields, or *never*",
              " check its required fields, regardless of whether or not the message has",
              " been parsed.",
              "",
              " As of 2021, lazy does no correctness checks on the byte stream during",
              " parsing.  This may lead to crashes if and when an invalid byte stream is",
              " finally parsed upon access.",
              "",
              " TODO(b/211906113):  Enable validation on lazy fields."
            ]
          },
          "FieldOptions:unverified_lazy": {
            "paramName": "unverified_lazy",
            "paramType": "TYPE_BOOL",
            "comments": [
              " unverified_lazy does no correctness checks on the byte stream. This should",
              " only be used where lazy with verification is prohibitive for performance",
              " reasons."
            ]
          },
          "FieldOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this field deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for accessors, or it will be completely ignored; in the very least, this",
              " is a formalization for deprecating fields."
            ]
          },
          "FieldOptions:weak": {
            "paramName": "weak",
            "paramType": "TYPE_BOOL",
            "comments": [
              " For Google-internal migration only. Do not use."
            ]
          },
          "FieldOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "OneofOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "EnumOptions:allow_alias": {
            "paramName": "allow_alias",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Set this option to true to allow mapping different tag names to the same",
              " value."
            ]
          },
          "EnumOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this enum deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for the enum, or it will be completely ignored; in the very least, this",
              " is a formalization for deprecating enums."
            ]
          },
          "EnumOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "EnumValueOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this enum value deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for the enum value, or it will be completely ignored; in the very least,",
              " this is a formalization for deprecating enum values."
            ]
          },
          "EnumValueOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "ServiceOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this service deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for the service, or it will be completely ignored; in the very least,",
              " this is a formalization for deprecating services."
            ]
          },
          "ServiceOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "MethodOptions:deprecated": {
            "paramName": "deprecated",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Is this method deprecated?",
              " Depending on the target platform, this can emit Deprecated annotations",
              " for the method, or it will be completely ignored; in the very least,",
              " this is a formalization for deprecating methods."
            ]
          },
          "MethodOptions:idempotency_level": {
            "paramName": "idempotency_level",
            "paramType": ".google.protobuf.MethodOptions.IdempotencyLevel",
            "comments": []
          },
          "MethodOptions:uninterpreted_option": {
            "paramName": "uninterpreted_option",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The parser stores options it doesn't recognize here. See above."
            ]
          },
          "UninterpretedOption:name": {
            "paramName": "name",
            "paramType": "TYPE_MESSAGE[]",
            "comments": []
          },
          "UninterpretedOption:identifier_value": {
            "paramName": "identifier_value",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value of the uninterpreted option, in whatever type the tokenizer",
              " identified it as during parsing. Exactly one of these should be set."
            ]
          },
          "UninterpretedOption:positive_int_value": {
            "paramName": "positive_int_value",
            "paramType": "TYPE_UINT64",
            "comments": []
          },
          "UninterpretedOption:negative_int_value": {
            "paramName": "negative_int_value",
            "paramType": "TYPE_INT64",
            "comments": []
          },
          "UninterpretedOption:double_value": {
            "paramName": "double_value",
            "paramType": "TYPE_DOUBLE",
            "comments": []
          },
          "UninterpretedOption:string_value": {
            "paramName": "string_value",
            "paramType": "TYPE_BYTES",
            "comments": []
          },
          "UninterpretedOption:aggregate_value": {
            "paramName": "aggregate_value",
            "paramType": "TYPE_STRING",
            "comments": []
          },
          "SourceCodeInfo:location": {
            "paramName": "location",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " A Location identifies a piece of source code in a .proto file which",
              " corresponds to a particular definition.  This information is intended",
              " to be useful to IDEs, code indexers, documentation generators, and similar",
              " tools.",
              "",
              " For example, say we have a file like:",
              "   message Foo {",
              "     optional string foo = 1;",
              "   }",
              " Let's look at just the field definition:",
              "   optional string foo = 1;",
              "   ^       ^^     ^^  ^  ^^^",
              "   a       bc     de  f  ghi",
              " We have the following locations:",
              "   span   path               represents",
              "   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.",
              "   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).",
              "   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).",
              "   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).",
              "   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).",
              "",
              " Notes:",
              " - A location may refer to a repeated field itself (i.e. not to any",
              "   particular index within it).  This is used whenever a set of elements are",
              "   logically enclosed in a single code segment.  For example, an entire",
              "   extend block (possibly containing multiple extension definitions) will",
              "   have an outer location whose path refers to the \"extensions\" repeated",
              "   field without an index.",
              " - Multiple locations may have the same path.  This happens when a single",
              "   logical declaration is spread out across multiple places.  The most",
              "   obvious example is the \"extend\" block again -- there may be multiple",
              "   extend blocks in the same scope, each of which will have the same path.",
              " - A location's span is not always a subset of its parent's span.  For",
              "   example, the \"extendee\" of an extension declaration appears at the",
              "   beginning of the \"extend\" block and is shared by all extensions within",
              "   the block.",
              " - Just because a location's span is a subset of some other location's span",
              "   does not mean that it is a descendant.  For example, a \"group\" defines",
              "   both a type and a field in a single declaration.  Thus, the locations",
              "   corresponding to the type and field and their components will overlap.",
              " - Code which tries to interpret locations should probably be designed to",
              "   ignore those that it doesn't understand, as more types of locations could",
              "   be recorded in the future."
            ]
          },
          "GeneratedCodeInfo:annotation": {
            "paramName": "annotation",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " An Annotation connects some span of text in generated code to an element",
              " of its generating .proto file."
            ]
          },
          "ResourceDescriptor:type": {
            "paramName": "type",
            "paramType": "TYPE_STRING",
            "comments": [
              " The resource type. It must be in the format of",
              " {service_name}/{resource_type_kind}. The `resource_type_kind` must be",
              " singular and must not include version numbers.",
              "",
              " Example: `storage.googleapis.com/Bucket`",
              "",
              " The value of the resource_type_kind must follow the regular expression",
              " /[A-Za-z][a-zA-Z0-9]+/. It should start with an upper case character and",
              " should use PascalCase (UpperCamelCase). The maximum number of",
              " characters allowed for the `resource_type_kind` is 100."
            ]
          },
          "ResourceDescriptor:pattern": {
            "paramName": "pattern",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Optional. The relative resource name pattern associated with this resource",
              " type. The DNS prefix of the full resource name shouldn't be specified here.",
              "",
              " The path pattern must follow the syntax, which aligns with HTTP binding",
              " syntax:",
              "",
              "     Template = Segment { \"/\" Segment } ;",
              "     Segment = LITERAL | Variable ;",
              "     Variable = \"{\" LITERAL \"}\" ;",
              "",
              " Examples:",
              "",
              "     - \"projects/{project}/topics/{topic}\"",
              "     - \"projects/{project}/knowledgeBases/{knowledge_base}\"",
              "",
              " The components in braces correspond to the IDs for each resource in the",
              " hierarchy. It is expected that, if multiple patterns are provided,",
              " the same component name (e.g. \"project\") refers to IDs of the same",
              " type of resource."
            ]
          },
          "ResourceDescriptor:name_field": {
            "paramName": "name_field",
            "paramType": "TYPE_STRING",
            "comments": [
              " Optional. The field on the resource that designates the resource name",
              " field. If omitted, this is assumed to be \"name\"."
            ]
          },
          "ResourceDescriptor:history": {
            "paramName": "history",
            "paramType": ".google.api.ResourceDescriptor.History",
            "comments": [
              " Optional. The historical or future-looking state of the resource pattern.",
              "",
              " Example:",
              "",
              "     // The InspectTemplate message originally only supported resource",
              "     // names with organization, and project was added later.",
              "     message InspectTemplate {",
              "       option (google.api.resource) = {",
              "         type: \"dlp.googleapis.com/InspectTemplate\"",
              "         pattern:",
              "         \"organizations/{organization}/inspectTemplates/{inspect_template}\"",
              "         pattern: \"projects/{project}/inspectTemplates/{inspect_template}\"",
              "         history: ORIGINALLY_SINGLE_PATTERN",
              "       };",
              "     }"
            ]
          },
          "ResourceDescriptor:plural": {
            "paramName": "plural",
            "paramType": "TYPE_STRING",
            "comments": [
              " The plural name used in the resource name and permission names, such as",
              " 'projects' for the resource name of 'projects/{project}' and the permission",
              " name of 'cloudresourcemanager.googleapis.com/projects.get'. It is the same",
              " concept of the `plural` field in k8s CRD spec",
              " https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/",
              "",
              " Note: The plural form is required even for singleton resources. See",
              " https://aip.dev/156"
            ]
          },
          "ResourceDescriptor:singular": {
            "paramName": "singular",
            "paramType": "TYPE_STRING",
            "comments": [
              " The same concept of the `singular` field in k8s CRD spec",
              " https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/",
              " Such as \"project\" for the `resourcemanager.googleapis.com/Project` type."
            ]
          },
          "ResourceDescriptor:style": {
            "paramName": "style",
            "paramType": "TYPE_ENUM[]",
            "comments": [
              " Style flag(s) for this resource.",
              " These indicate that a resource is expected to conform to a given",
              " style. See the specific style flags for additional information."
            ]
          },
          "ResourceReference:type": {
            "paramName": "type",
            "paramType": "TYPE_STRING",
            "comments": [
              " The resource type that the annotated field references.",
              "",
              " Example:",
              "",
              "     message Subscription {",
              "       string topic = 2 [(google.api.resource_reference) = {",
              "         type: \"pubsub.googleapis.com/Topic\"",
              "       }];",
              "     }",
              "",
              " Occasionally, a field may reference an arbitrary resource. In this case,",
              " APIs use the special value * in their resource reference.",
              "",
              " Example:",
              "",
              "     message GetIamPolicyRequest {",
              "       string resource = 2 [(google.api.resource_reference) = {",
              "         type: \"*\"",
              "       }];",
              "     }"
            ]
          },
          "ResourceReference:child_type": {
            "paramName": "child_type",
            "paramType": "TYPE_STRING",
            "comments": [
              " The resource type of a child collection that the annotated field",
              " references. This is useful for annotating the `parent` field that",
              " doesn't have a fixed resource type.",
              "",
              " Example:",
              "",
              "     message ListLogEntriesRequest {",
              "       string parent = 1 [(google.api.resource_reference) = {",
              "         child_type: \"logging.googleapis.com/LogEntry\"",
              "       };",
              "     }"
            ]
          },
          "Duration:seconds": {
            "paramName": "seconds",
            "paramType": "TYPE_INT64",
            "comments": [
              " Signed seconds of the span of time. Must be from -315,576,000,000",
              " to +315,576,000,000 inclusive. Note: these bounds are computed from:",
              " 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
            ]
          },
          "Duration:nanos": {
            "paramName": "nanos",
            "paramType": "TYPE_INT32",
            "comments": [
              " Signed fractions of a second at nanosecond resolution of the span",
              " of time. Durations less than one second are represented with a 0",
              " `seconds` field and a positive or negative `nanos` field. For durations",
              " of one second or more, a non-zero value for the `nanos` field must be",
              " of the same sign as the `seconds` field. Must be from -999,999,999",
              " to +999,999,999 inclusive."
            ]
          },
          "FieldMask:paths": {
            "paramName": "paths",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " The set of field mask paths."
            ]
          },
          "Timestamp:seconds": {
            "paramName": "seconds",
            "paramType": "TYPE_INT64",
            "comments": [
              " Represents seconds of UTC time since Unix epoch",
              " 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to",
              " 9999-12-31T23:59:59Z inclusive."
            ]
          },
          "Timestamp:nanos": {
            "paramName": "nanos",
            "paramType": "TYPE_INT32",
            "comments": [
              " Non-negative fractions of a second at nanosecond resolution. Negative",
              " second values with fractions must still have non-negative nanos values",
              " that count forward in time. Must be from 0 to 999,999,999",
              " inclusive."
            ]
          },
          "SchemaService": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Service for doing schema-related operations."
            ]
          },
          "SchemaService:CreateSchema": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Creates a schema.",
              ""
            ]
          },
          "SchemaService:GetSchema": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Gets a schema.",
              ""
            ]
          },
          "SchemaService:ListSchemas": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Lists schemas in a project.",
              ""
            ]
          },
          "SchemaService:DeleteSchema": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Deletes a schema.",
              ""
            ]
          },
          "SchemaService:ValidateSchema": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Validates a schema.",
              ""
            ]
          },
          "SchemaService:ValidateMessage": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Validates a message against a schema.",
              ""
            ]
          },
          "Schema:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. Name of the schema.",
              " Format is `projects/{project}/schemas/{schema}`."
            ],
            "fieldBehavior": 2
          },
          "Schema:type": {
            "paramName": "type",
            "paramType": ".google.pubsub.v1.Schema.Type",
            "comments": [
              " The type of the schema definition."
            ]
          },
          "Schema:definition": {
            "paramName": "definition",
            "paramType": "TYPE_STRING",
            "comments": [
              " The definition of the schema. This should contain a string representing",
              " the full definition of the schema that is a valid schema definition of",
              " the type specified in `type`."
            ]
          },
          "CreateSchemaRequest:parent": {
            "paramName": "parent",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to create the schema.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "CreateSchemaRequest:schema": {
            "paramName": "schema",
            "paramType": ".google.pubsub.v1.Schema",
            "comments": [
              " Required. The schema object to create.",
              "",
              " This schema's `name` parameter is ignored. The schema object returned",
              " by CreateSchema will have a `name` made using the given `parent` and",
              " `schema_id`."
            ],
            "fieldBehavior": 2
          },
          "CreateSchemaRequest:schema_id": {
            "paramName": "schema_id",
            "paramType": "TYPE_STRING",
            "comments": [
              " The ID to use for the schema, which will become the final component of",
              " the schema's resource name.",
              "",
              " See https://cloud.google.com/pubsub/docs/admin#resource_names for resource",
              " name constraints."
            ]
          },
          "GetSchemaRequest:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the schema to get.",
              " Format is `projects/{project}/schemas/{schema}`."
            ],
            "fieldBehavior": 2
          },
          "GetSchemaRequest:view": {
            "paramName": "view",
            "paramType": ".google.pubsub.v1.SchemaView",
            "comments": [
              " The set of fields to return in the response. If not set, returns a Schema",
              " with `name` and `type`, but not `definition`. Set to `FULL` to retrieve all",
              " fields."
            ]
          },
          "ListSchemasRequest:parent": {
            "paramName": "parent",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to list schemas.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "ListSchemasRequest:view": {
            "paramName": "view",
            "paramType": ".google.pubsub.v1.SchemaView",
            "comments": [
              " The set of Schema fields to return in the response. If not set, returns",
              " Schemas with `name` and `type`, but not `definition`. Set to `FULL` to",
              " retrieve all fields."
            ]
          },
          "ListSchemasRequest:page_size": {
            "paramName": "page_size",
            "paramType": "TYPE_INT32",
            "comments": [
              " Maximum number of schemas to return."
            ]
          },
          "ListSchemasRequest:page_token": {
            "paramName": "page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value returned by the last `ListSchemasResponse`; indicates that",
              " this is a continuation of a prior `ListSchemas` call, and that the",
              " system should return the next page of data."
            ]
          },
          "ListSchemasResponse:schemas": {
            "paramName": "schemas",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The resulting schemas."
            ]
          },
          "ListSchemasResponse:next_page_token": {
            "paramName": "next_page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " If not empty, indicates that there may be more schemas that match the",
              " request; this value should be passed in a new `ListSchemasRequest`."
            ]
          },
          "DeleteSchemaRequest:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. Name of the schema to delete.",
              " Format is `projects/{project}/schemas/{schema}`."
            ],
            "fieldBehavior": 2
          },
          "ValidateSchemaRequest:parent": {
            "paramName": "parent",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to validate schemas.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "ValidateSchemaRequest:schema": {
            "paramName": "schema",
            "paramType": ".google.pubsub.v1.Schema",
            "comments": [
              " Required. The schema object to validate."
            ],
            "fieldBehavior": 2
          },
          "ValidateMessageRequest:parent": {
            "paramName": "parent",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to validate schemas.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "ValidateMessageRequest:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Name of the schema against which to validate.",
              "",
              " Format is `projects/{project}/schemas/{schema}`."
            ]
          },
          "ValidateMessageRequest:schema": {
            "paramName": "schema",
            "paramType": ".google.pubsub.v1.Schema",
            "comments": [
              " Ad-hoc schema against which to validate"
            ]
          },
          "ValidateMessageRequest:message": {
            "paramName": "message",
            "paramType": "TYPE_BYTES",
            "comments": [
              " Message to validate against the provided `schema_spec`."
            ]
          },
          "ValidateMessageRequest:encoding": {
            "paramName": "encoding",
            "paramType": ".google.pubsub.v1.Encoding",
            "comments": [
              " The encoding expected for messages"
            ]
          },
          "Publisher": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " The service that an application uses to manipulate topics, and to send",
              " messages to a topic."
            ]
          },
          "Publisher:CreateTopic": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Creates the given topic with the given name. See the [resource name rules]",
              " (https://cloud.google.com/pubsub/docs/admin#resource_names).",
              ""
            ]
          },
          "Publisher:UpdateTopic": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Updates an existing topic. Note that certain properties of a",
              " topic are not modifiable.",
              ""
            ]
          },
          "Publisher:Publish": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Adds one or more messages to the topic. Returns `NOT_FOUND` if the topic",
              " does not exist.",
              ""
            ]
          },
          "Publisher:GetTopic": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Gets the configuration of a topic.",
              ""
            ]
          },
          "Publisher:ListTopics": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Lists matching topics.",
              ""
            ]
          },
          "Publisher:ListTopicSubscriptions": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Lists the names of the attached subscriptions on this topic.",
              ""
            ]
          },
          "Publisher:ListTopicSnapshots": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Lists the names of the snapshots on this topic. Snapshots are used in",
              " [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,",
              " which allow you to manage message acknowledgments in bulk. That is, you can",
              " set the acknowledgment state of messages in an existing subscription to the",
              " state captured by a snapshot.",
              ""
            ]
          },
          "Publisher:DeleteTopic": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Deletes the topic with the given name. Returns `NOT_FOUND` if the topic",
              " does not exist. After a topic is deleted, a new topic may be created with",
              " the same name; this is an entirely new topic with none of the old",
              " configuration or subscriptions. Existing subscriptions to this topic are",
              " not deleted, but their `topic` field is set to `_deleted-topic_`.",
              ""
            ]
          },
          "Publisher:DetachSubscription": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Detaches a subscription from this topic. All messages retained in the",
              " subscription are dropped. Subsequent `Pull` and `StreamingPull` requests",
              " will return FAILED_PRECONDITION. If the subscription is a push",
              " subscription, pushes to the endpoint will stop.",
              ""
            ]
          },
          "MessageStoragePolicy:allowed_persistence_regions": {
            "paramName": "allowed_persistence_regions",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " A list of IDs of GCP regions where messages that are published to the topic",
              " may be persisted in storage. Messages published by publishers running in",
              " non-allowed GCP regions (or running outside of GCP altogether) will be",
              " routed for storage in one of the allowed regions. An empty list means that",
              " no regions are allowed, and is not a valid configuration."
            ]
          },
          "SchemaSettings:schema": {
            "paramName": "schema",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the schema that messages published should be",
              " validated against. Format is `projects/{project}/schemas/{schema}`. The",
              " value of this field will be `_deleted-schema_` if the schema has been",
              " deleted."
            ],
            "fieldBehavior": 2
          },
          "SchemaSettings:encoding": {
            "paramName": "encoding",
            "paramType": ".google.pubsub.v1.Encoding",
            "comments": [
              " The encoding of messages validated against `schema`."
            ]
          },
          "Topic:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the topic. It must have the format",
              " `\"projects/{project}/topics/{topic}\"`. `{topic}` must start with a letter,",
              " and contain only letters (`[A-Za-z]`), numbers (`[0-9]`), dashes (`-`),",
              " underscores (`_`), periods (`.`), tildes (`~`), plus (`+`) or percent",
              " signs (`%`). It must be between 3 and 255 characters in length, and it",
              " must not start with `\"goog\"`."
            ],
            "fieldBehavior": 2
          },
          "Topic:labels": {
            "paramName": "labels",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " See [Creating and managing labels]",
              " (https://cloud.google.com/pubsub/docs/labels)."
            ]
          },
          "Topic:message_storage_policy": {
            "paramName": "message_storage_policy",
            "paramType": ".google.pubsub.v1.MessageStoragePolicy",
            "comments": [
              " Policy constraining the set of Google Cloud Platform regions where messages",
              " published to the topic may be stored. If not present, then no constraints",
              " are in effect."
            ]
          },
          "Topic:kms_key_name": {
            "paramName": "kms_key_name",
            "paramType": "TYPE_STRING",
            "comments": [
              " The resource name of the Cloud KMS CryptoKey to be used to protect access",
              " to messages published on this topic.",
              "",
              " The expected format is `projects/*/locations/*/keyRings/*/cryptoKeys/*`."
            ]
          },
          "Topic:schema_settings": {
            "paramName": "schema_settings",
            "paramType": ".google.pubsub.v1.SchemaSettings",
            "comments": [
              " Settings for validating messages published against a schema."
            ]
          },
          "Topic:satisfies_pzs": {
            "paramName": "satisfies_pzs",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Reserved for future use. This field is set only in responses from the",
              " server; it is ignored if it is set in any requests."
            ]
          },
          "PubsubMessage:data": {
            "paramName": "data",
            "paramType": "TYPE_BYTES",
            "comments": [
              " The message data field. If this field is empty, the message must contain",
              " at least one attribute."
            ]
          },
          "PubsubMessage:attributes": {
            "paramName": "attributes",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Attributes for this message. If this field is empty, the message must",
              " contain non-empty data. This can be used to filter messages on the",
              " subscription."
            ]
          },
          "PubsubMessage:message_id": {
            "paramName": "message_id",
            "paramType": "TYPE_STRING",
            "comments": [
              " ID of this message, assigned by the server when the message is published.",
              " Guaranteed to be unique within the topic. This value may be read by a",
              " subscriber that receives a `PubsubMessage` via a `Pull` call or a push",
              " delivery. It must not be populated by the publisher in a `Publish` call."
            ]
          },
          "PubsubMessage:publish_time": {
            "paramName": "publish_time",
            "paramType": ".google.protobuf.Timestamp",
            "comments": [
              " The time at which the message was published, populated by the server when",
              " it receives the `Publish` call. It must not be populated by the",
              " publisher in a `Publish` call."
            ]
          },
          "PubsubMessage:ordering_key": {
            "paramName": "ordering_key",
            "paramType": "TYPE_STRING",
            "comments": [
              " If non-empty, identifies related messages for which publish order should be",
              " respected. If a `Subscription` has `enable_message_ordering` set to `true`,",
              " messages published with the same non-empty `ordering_key` value will be",
              " delivered to subscribers in the order in which they are received by the",
              " Pub/Sub system. All `PubsubMessage`s published in a given `PublishRequest`",
              " must specify the same `ordering_key` value."
            ]
          },
          "GetTopicRequest:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the topic to get.",
              " Format is `projects/{project}/topics/{topic}`."
            ],
            "fieldBehavior": 2
          },
          "UpdateTopicRequest:topic": {
            "paramName": "topic",
            "paramType": ".google.pubsub.v1.Topic",
            "comments": [
              " Required. The updated topic object."
            ],
            "fieldBehavior": 2
          },
          "UpdateTopicRequest:update_mask": {
            "paramName": "update_mask",
            "paramType": ".google.protobuf.FieldMask",
            "comments": [
              " Required. Indicates which fields in the provided topic to update. Must be",
              " specified and non-empty. Note that if `update_mask` contains",
              " \"message_storage_policy\" but the `message_storage_policy` is not set in",
              " the `topic` provided above, then the updated value is determined by the",
              " policy configured at the project or organization level."
            ],
            "fieldBehavior": 2
          },
          "PublishRequest:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The messages in the request will be published on this topic.",
              " Format is `projects/{project}/topics/{topic}`."
            ],
            "fieldBehavior": 2
          },
          "PublishRequest:messages": {
            "paramName": "messages",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Required. The messages to publish."
            ],
            "fieldBehavior": 2
          },
          "PublishResponse:message_ids": {
            "paramName": "message_ids",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " The server-assigned ID of each published message, in the same order as",
              " the messages in the request. IDs are guaranteed to be unique within",
              " the topic."
            ]
          },
          "ListTopicsRequest:project": {
            "paramName": "project",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to list topics.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "ListTopicsRequest:page_size": {
            "paramName": "page_size",
            "paramType": "TYPE_INT32",
            "comments": [
              " Maximum number of topics to return."
            ]
          },
          "ListTopicsRequest:page_token": {
            "paramName": "page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value returned by the last `ListTopicsResponse`; indicates that this is",
              " a continuation of a prior `ListTopics` call, and that the system should",
              " return the next page of data."
            ]
          },
          "ListTopicsResponse:topics": {
            "paramName": "topics",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The resulting topics."
            ]
          },
          "ListTopicsResponse:next_page_token": {
            "paramName": "next_page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " If not empty, indicates that there may be more topics that match the",
              " request; this value should be passed in a new `ListTopicsRequest`."
            ]
          },
          "ListTopicSubscriptionsRequest:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the topic that subscriptions are attached to.",
              " Format is `projects/{project}/topics/{topic}`."
            ],
            "fieldBehavior": 2
          },
          "ListTopicSubscriptionsRequest:page_size": {
            "paramName": "page_size",
            "paramType": "TYPE_INT32",
            "comments": [
              " Maximum number of subscription names to return."
            ]
          },
          "ListTopicSubscriptionsRequest:page_token": {
            "paramName": "page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value returned by the last `ListTopicSubscriptionsResponse`; indicates",
              " that this is a continuation of a prior `ListTopicSubscriptions` call, and",
              " that the system should return the next page of data."
            ]
          },
          "ListTopicSubscriptionsResponse:subscriptions": {
            "paramName": "subscriptions",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " The names of subscriptions attached to the topic specified in the request."
            ]
          },
          "ListTopicSubscriptionsResponse:next_page_token": {
            "paramName": "next_page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " If not empty, indicates that there may be more subscriptions that match",
              " the request; this value should be passed in a new",
              " `ListTopicSubscriptionsRequest` to get more subscriptions."
            ]
          },
          "ListTopicSnapshotsRequest:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the topic that snapshots are attached to.",
              " Format is `projects/{project}/topics/{topic}`."
            ],
            "fieldBehavior": 2
          },
          "ListTopicSnapshotsRequest:page_size": {
            "paramName": "page_size",
            "paramType": "TYPE_INT32",
            "comments": [
              " Maximum number of snapshot names to return."
            ]
          },
          "ListTopicSnapshotsRequest:page_token": {
            "paramName": "page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value returned by the last `ListTopicSnapshotsResponse`; indicates",
              " that this is a continuation of a prior `ListTopicSnapshots` call, and",
              " that the system should return the next page of data."
            ]
          },
          "ListTopicSnapshotsResponse:snapshots": {
            "paramName": "snapshots",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " The names of the snapshots that match the request."
            ]
          },
          "ListTopicSnapshotsResponse:next_page_token": {
            "paramName": "next_page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " If not empty, indicates that there may be more snapshots that match",
              " the request; this value should be passed in a new",
              " `ListTopicSnapshotsRequest` to get more snapshots."
            ]
          },
          "DeleteTopicRequest:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. Name of the topic to delete.",
              " Format is `projects/{project}/topics/{topic}`."
            ],
            "fieldBehavior": 2
          },
          "DetachSubscriptionRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription to detach.",
              " Format is `projects/{project}/subscriptions/{subscription}`."
            ],
            "fieldBehavior": 2
          },
          "Subscriber": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " The service that an application uses to manipulate subscriptions and to",
              " consume messages from a subscription via the `Pull` method or by",
              " establishing a bi-directional stream using the `StreamingPull` method."
            ]
          },
          "Subscriber:CreateSubscription": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Creates a subscription to a given topic. See the [resource name rules]",
              " (https://cloud.google.com/pubsub/docs/admin#resource_names).",
              " If the subscription already exists, returns `ALREADY_EXISTS`.",
              " If the corresponding topic doesn't exist, returns `NOT_FOUND`.",
              "",
              " If the name is not provided in the request, the server will assign a random",
              " name for this subscription on the same project as the topic, conforming",
              " to the [resource name format]",
              " (https://cloud.google.com/pubsub/docs/admin#resource_names). The generated",
              " name is populated in the returned Subscription object. Note that for REST",
              " API requests, you must specify a name in the request.",
              ""
            ]
          },
          "Subscriber:GetSubscription": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Gets the configuration details of a subscription.",
              ""
            ]
          },
          "Subscriber:UpdateSubscription": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Updates an existing subscription. Note that certain properties of a",
              " subscription, such as its topic, are not modifiable.",
              ""
            ]
          },
          "Subscriber:ListSubscriptions": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Lists matching subscriptions.",
              ""
            ]
          },
          "Subscriber:DeleteSubscription": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Deletes an existing subscription. All messages retained in the subscription",
              " are immediately dropped. Calls to `Pull` after deletion will return",
              " `NOT_FOUND`. After a subscription is deleted, a new one may be created with",
              " the same name, but the new one has no association with the old",
              " subscription or its topic unless the same topic is specified.",
              ""
            ]
          },
          "Subscriber:ModifyAckDeadline": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Modifies the ack deadline for a specific message. This method is useful",
              " to indicate that more time is needed to process a message by the",
              " subscriber, or to make the message available for redelivery if the",
              " processing was interrupted. Note that this does not modify the",
              " subscription-level `ackDeadlineSeconds` used for subsequent messages.",
              ""
            ]
          },
          "Subscriber:Acknowledge": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Acknowledges the messages associated with the `ack_ids` in the",
              " `AcknowledgeRequest`. The Pub/Sub system can remove the relevant messages",
              " from the subscription.",
              "",
              " Acknowledging a message whose ack deadline has expired may succeed,",
              " but such a message may be redelivered later. Acknowledging a message more",
              " than once will not result in an error.",
              ""
            ]
          },
          "Subscriber:Pull": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Pulls messages from the server. The server may return `UNAVAILABLE` if",
              " there are too many concurrent pull requests pending for the given",
              " subscription.",
              ""
            ]
          },
          "Subscriber:StreamingPull": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Establishes a stream with the server, which sends messages down to the",
              " client. The client streams acknowledgements and ack deadline modifications",
              " back to the server. The server will close the stream and return the status",
              " on any error. The server may close the stream with status `UNAVAILABLE` to",
              " reassign server-side resources, in which case, the client should",
              " re-establish the stream. Flow control can be achieved by configuring the",
              " underlying RPC channel.",
              ""
            ]
          },
          "Subscriber:ModifyPushConfig": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Modifies the `PushConfig` for a specified subscription.",
              "",
              " This may be used to change a push subscription to a pull one (signified by",
              " an empty `PushConfig`) or vice versa, or change the endpoint URL and other",
              " attributes of a push subscription. Messages will accumulate for delivery",
              " continuously through the call regardless of changes to the `PushConfig`.",
              ""
            ]
          },
          "Subscriber:GetSnapshot": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Gets the configuration details of a snapshot. Snapshots are used in",
              " <a href=\"https://cloud.google.com/pubsub/docs/replay-overview\">Seek</a>",
              " operations, which allow you to manage message acknowledgments in bulk. That",
              " is, you can set the acknowledgment state of messages in an existing",
              " subscription to the state captured by a snapshot.",
              ""
            ]
          },
          "Subscriber:ListSnapshots": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Lists the existing snapshots. Snapshots are used in [Seek](",
              " https://cloud.google.com/pubsub/docs/replay-overview) operations, which",
              " allow you to manage message acknowledgments in bulk. That is, you can set",
              " the acknowledgment state of messages in an existing subscription to the",
              " state captured by a snapshot.",
              ""
            ]
          },
          "Subscriber:CreateSnapshot": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Creates a snapshot from the requested subscription. Snapshots are used in",
              " [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,",
              " which allow you to manage message acknowledgments in bulk. That is, you can",
              " set the acknowledgment state of messages in an existing subscription to the",
              " state captured by a snapshot.",
              " If the snapshot already exists, returns `ALREADY_EXISTS`.",
              " If the requested subscription doesn't exist, returns `NOT_FOUND`.",
              " If the backlog in the subscription is too old -- and the resulting snapshot",
              " would expire in less than 1 hour -- then `FAILED_PRECONDITION` is returned.",
              " See also the `Snapshot.expire_time` field. If the name is not provided in",
              " the request, the server will assign a random",
              " name for this snapshot on the same project as the subscription, conforming",
              " to the [resource name format]",
              " (https://cloud.google.com/pubsub/docs/admin#resource_names). The",
              " generated name is populated in the returned Snapshot object. Note that for",
              " REST API requests, you must specify a name in the request.",
              ""
            ]
          },
          "Subscriber:UpdateSnapshot": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Updates an existing snapshot. Snapshots are used in",
              " <a href=\"https://cloud.google.com/pubsub/docs/replay-overview\">Seek</a>",
              " operations, which allow",
              " you to manage message acknowledgments in bulk. That is, you can set the",
              " acknowledgment state of messages in an existing subscription to the state",
              " captured by a snapshot.",
              ""
            ]
          },
          "Subscriber:DeleteSnapshot": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Removes an existing snapshot. Snapshots are used in [Seek]",
              " (https://cloud.google.com/pubsub/docs/replay-overview) operations, which",
              " allow you to manage message acknowledgments in bulk. That is, you can set",
              " the acknowledgment state of messages in an existing subscription to the",
              " state captured by a snapshot.",
              " When the snapshot is deleted, all messages retained in the snapshot",
              " are immediately dropped. After a snapshot is deleted, a new one may be",
              " created with the same name, but the new one has no association with the old",
              " snapshot or its subscription, unless the same subscription is specified.",
              ""
            ]
          },
          "Subscriber:Seek": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Seeks an existing subscription to a point in time or to a given snapshot,",
              " whichever is provided in the request. Snapshots are used in [Seek]",
              " (https://cloud.google.com/pubsub/docs/replay-overview) operations, which",
              " allow you to manage message acknowledgments in bulk. That is, you can set",
              " the acknowledgment state of messages in an existing subscription to the",
              " state captured by a snapshot. Note that both the subscription and the",
              " snapshot must be on the same topic.",
              ""
            ]
          },
          "Subscription:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the subscription. It must have the format",
              " `\"projects/{project}/subscriptions/{subscription}\"`. `{subscription}` must",
              " start with a letter, and contain only letters (`[A-Za-z]`), numbers",
              " (`[0-9]`), dashes (`-`), underscores (`_`), periods (`.`), tildes (`~`),",
              " plus (`+`) or percent signs (`%`). It must be between 3 and 255 characters",
              " in length, and it must not start with `\"goog\"`."
            ],
            "fieldBehavior": 2
          },
          "Subscription:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the topic from which this subscription is receiving",
              " messages. Format is `projects/{project}/topics/{topic}`. The value of this",
              " field will be `_deleted-topic_` if the topic has been deleted."
            ],
            "fieldBehavior": 2
          },
          "Subscription:push_config": {
            "paramName": "push_config",
            "paramType": ".google.pubsub.v1.PushConfig",
            "comments": [
              " If push delivery is used with this subscription, this field is",
              " used to configure it. An empty `pushConfig` signifies that the subscriber",
              " will pull and ack messages using API methods."
            ]
          },
          "Subscription:ack_deadline_seconds": {
            "paramName": "ack_deadline_seconds",
            "paramType": "TYPE_INT32",
            "comments": [
              " The approximate amount of time (on a best-effort basis) Pub/Sub waits for",
              " the subscriber to acknowledge receipt before resending the message. In the",
              " interval after the message is delivered and before it is acknowledged, it",
              " is considered to be <i>outstanding</i>. During that time period, the",
              " message will not be redelivered (on a best-effort basis).",
              "",
              " For pull subscriptions, this value is used as the initial value for the ack",
              " deadline. To override this value for a given message, call",
              " `ModifyAckDeadline` with the corresponding `ack_id` if using",
              " non-streaming pull or send the `ack_id` in a",
              " `StreamingModifyAckDeadlineRequest` if using streaming pull.",
              " The minimum custom deadline you can specify is 10 seconds.",
              " The maximum custom deadline you can specify is 600 seconds (10 minutes).",
              " If this parameter is 0, a default value of 10 seconds is used.",
              "",
              " For push delivery, this value is also used to set the request timeout for",
              " the call to the push endpoint.",
              "",
              " If the subscriber never acknowledges the message, the Pub/Sub",
              " system will eventually redeliver the message."
            ]
          },
          "Subscription:retain_acked_messages": {
            "paramName": "retain_acked_messages",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Indicates whether to retain acknowledged messages. If true, then",
              " messages are not expunged from the subscription's backlog, even if they are",
              " acknowledged, until they fall out of the `message_retention_duration`",
              " window. This must be true if you would like to [Seek to a timestamp]",
              " (https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time)."
            ]
          },
          "Subscription:message_retention_duration": {
            "paramName": "message_retention_duration",
            "paramType": ".google.protobuf.Duration",
            "comments": [
              " How long to retain unacknowledged messages in the subscription's backlog,",
              " from the moment a message is published.",
              " If `retain_acked_messages` is true, then this also configures the retention",
              " of acknowledged messages, and thus configures how far back in time a `Seek`",
              " can be done. Defaults to 7 days. Cannot be more than 7 days or less than 10",
              " minutes."
            ]
          },
          "Subscription:labels": {
            "paramName": "labels",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " See <a href=\"https://cloud.google.com/pubsub/docs/labels\"> Creating and",
              " managing labels</a>."
            ]
          },
          "Subscription:enable_message_ordering": {
            "paramName": "enable_message_ordering",
            "paramType": "TYPE_BOOL",
            "comments": [
              " If true, messages published with the same `ordering_key` in `PubsubMessage`",
              " will be delivered to the subscribers in the order in which they",
              " are received by the Pub/Sub system. Otherwise, they may be delivered in",
              " any order."
            ]
          },
          "Subscription:expiration_policy": {
            "paramName": "expiration_policy",
            "paramType": ".google.pubsub.v1.ExpirationPolicy",
            "comments": [
              " A policy that specifies the conditions for this subscription's expiration.",
              " A subscription is considered active as long as any connected subscriber is",
              " successfully consuming messages from the subscription or is issuing",
              " operations on the subscription. If `expiration_policy` is not set, a",
              " *default policy* with `ttl` of 31 days will be used. The minimum allowed",
              " value for `expiration_policy.ttl` is 1 day."
            ]
          },
          "Subscription:filter": {
            "paramName": "filter",
            "paramType": "TYPE_STRING",
            "comments": [
              " An expression written in the Pub/Sub [filter",
              " language](https://cloud.google.com/pubsub/docs/filtering). If non-empty,",
              " then only `PubsubMessage`s whose `attributes` field matches the filter are",
              " delivered on this subscription. If empty, then no messages are filtered",
              " out."
            ]
          },
          "Subscription:dead_letter_policy": {
            "paramName": "dead_letter_policy",
            "paramType": ".google.pubsub.v1.DeadLetterPolicy",
            "comments": [
              " A policy that specifies the conditions for dead lettering messages in",
              " this subscription. If dead_letter_policy is not set, dead lettering",
              " is disabled.",
              "",
              " The Cloud Pub/Sub service account associated with this subscriptions's",
              " parent project (i.e.,",
              " service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have",
              " permission to Acknowledge() messages on this subscription."
            ]
          },
          "Subscription:retry_policy": {
            "paramName": "retry_policy",
            "paramType": ".google.pubsub.v1.RetryPolicy",
            "comments": [
              " A policy that specifies how Pub/Sub retries message delivery for this",
              " subscription.",
              "",
              " If not set, the default retry policy is applied. This generally implies",
              " that messages will be retried as soon as possible for healthy subscribers.",
              " RetryPolicy will be triggered on NACKs or acknowledgement deadline",
              " exceeded events for a given message."
            ]
          },
          "Subscription:detached": {
            "paramName": "detached",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Indicates whether the subscription is detached from its topic. Detached",
              " subscriptions don't receive messages from their topic and don't retain any",
              " backlog. `Pull` and `StreamingPull` requests will return",
              " FAILED_PRECONDITION. If the subscription is a push subscription, pushes to",
              " the endpoint will not be made."
            ]
          },
          "RetryPolicy:minimum_backoff": {
            "paramName": "minimum_backoff",
            "paramType": ".google.protobuf.Duration",
            "comments": [
              " The minimum delay between consecutive deliveries of a given message.",
              " Value should be between 0 and 600 seconds. Defaults to 10 seconds."
            ]
          },
          "RetryPolicy:maximum_backoff": {
            "paramName": "maximum_backoff",
            "paramType": ".google.protobuf.Duration",
            "comments": [
              " The maximum delay between consecutive deliveries of a given message.",
              " Value should be between 0 and 600 seconds. Defaults to 600 seconds."
            ]
          },
          "DeadLetterPolicy:dead_letter_topic": {
            "paramName": "dead_letter_topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " The name of the topic to which dead letter messages should be published.",
              " Format is `projects/{project}/topics/{topic}`.The Cloud Pub/Sub service",
              " account associated with the enclosing subscription's parent project (i.e.,",
              " service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have",
              " permission to Publish() to this topic.",
              "",
              " The operation will fail if the topic does not exist.",
              " Users should ensure that there is a subscription attached to this topic",
              " since messages published to a topic with no subscriptions are lost."
            ]
          },
          "DeadLetterPolicy:max_delivery_attempts": {
            "paramName": "max_delivery_attempts",
            "paramType": "TYPE_INT32",
            "comments": [
              " The maximum number of delivery attempts for any message. The value must be",
              " between 5 and 100.",
              "",
              " The number of delivery attempts is defined as 1 + (the sum of number of",
              " NACKs and number of times the acknowledgement deadline has been exceeded",
              " for the message).",
              "",
              " A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that",
              " client libraries may automatically extend ack_deadlines.",
              "",
              " This field will be honored on a best effort basis.",
              "",
              " If this parameter is 0, a default value of 5 is used."
            ]
          },
          "ExpirationPolicy:ttl": {
            "paramName": "ttl",
            "paramType": ".google.protobuf.Duration",
            "comments": [
              " Specifies the \"time-to-live\" duration for an associated resource. The",
              " resource expires if it is not active for a period of `ttl`. The definition",
              " of \"activity\" depends on the type of the associated resource. The minimum",
              " and maximum allowed values for `ttl` depend on the type of the associated",
              " resource, as well. If `ttl` is not set, the associated resource never",
              " expires."
            ]
          },
          "PushConfig:push_endpoint": {
            "paramName": "push_endpoint",
            "paramType": "TYPE_STRING",
            "comments": [
              " A URL locating the endpoint to which messages should be pushed.",
              " For example, a Webhook endpoint might use `https://example.com/push`."
            ]
          },
          "PushConfig:attributes": {
            "paramName": "attributes",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Endpoint configuration attributes that can be used to control different",
              " aspects of the message delivery.",
              "",
              " The only currently supported attribute is `x-goog-version`, which you can",
              " use to change the format of the pushed message. This attribute",
              " indicates the version of the data expected by the endpoint. This",
              " controls the shape of the pushed message (i.e., its fields and metadata).",
              "",
              " If not present during the `CreateSubscription` call, it will default to",
              " the version of the Pub/Sub API used to make such call. If not present in a",
              " `ModifyPushConfig` call, its value will not be changed. `GetSubscription`",
              " calls will always return a valid version, even if the subscription was",
              " created without this attribute.",
              "",
              " The only supported values for the `x-goog-version` attribute are:",
              "",
              " * `v1beta1`: uses the push format defined in the v1beta1 Pub/Sub API.",
              " * `v1` or `v1beta2`: uses the push format defined in the v1 Pub/Sub API.",
              "",
              " For example:",
              " <pre><code>attributes { \"x-goog-version\": \"v1\" } </code></pre>"
            ]
          },
          "PushConfig:oidc_token": {
            "paramName": "oidc_token",
            "paramType": ".google.pubsub.v1.PushConfig.OidcToken",
            "comments": [
              " If specified, Pub/Sub will generate and attach an OIDC JWT token as an",
              " `Authorization` header in the HTTP request for every pushed message."
            ]
          },
          "ReceivedMessage:ack_id": {
            "paramName": "ack_id",
            "paramType": "TYPE_STRING",
            "comments": [
              " This ID can be used to acknowledge the received message."
            ]
          },
          "ReceivedMessage:message": {
            "paramName": "message",
            "paramType": ".google.pubsub.v1.PubsubMessage",
            "comments": [
              " The message."
            ]
          },
          "ReceivedMessage:delivery_attempt": {
            "paramName": "delivery_attempt",
            "paramType": "TYPE_INT32",
            "comments": [
              " The approximate number of times that Cloud Pub/Sub has attempted to deliver",
              " the associated message to a subscriber.",
              "",
              " More precisely, this is 1 + (number of NACKs) +",
              " (number of ack_deadline exceeds) for this message.",
              "",
              " A NACK is any call to ModifyAckDeadline with a 0 deadline. An ack_deadline",
              " exceeds event is whenever a message is not acknowledged within",
              " ack_deadline. Note that ack_deadline is initially",
              " Subscription.ackDeadlineSeconds, but may get extended automatically by",
              " the client library.",
              "",
              " Upon the first delivery of a given message, `delivery_attempt` will have a",
              " value of 1. The value is calculated at best effort and is approximate.",
              "",
              " If a DeadLetterPolicy is not set on the subscription, this will be 0."
            ]
          },
          "GetSubscriptionRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the subscription to get.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "UpdateSubscriptionRequest:subscription": {
            "paramName": "subscription",
            "paramType": ".google.pubsub.v1.Subscription",
            "comments": [
              " Required. The updated subscription object."
            ],
            "fieldBehavior": 2
          },
          "UpdateSubscriptionRequest:update_mask": {
            "paramName": "update_mask",
            "paramType": ".google.protobuf.FieldMask",
            "comments": [
              " Required. Indicates which fields in the provided subscription to update.",
              " Must be specified and non-empty."
            ],
            "fieldBehavior": 2
          },
          "ListSubscriptionsRequest:project": {
            "paramName": "project",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to list subscriptions.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "ListSubscriptionsRequest:page_size": {
            "paramName": "page_size",
            "paramType": "TYPE_INT32",
            "comments": [
              " Maximum number of subscriptions to return."
            ]
          },
          "ListSubscriptionsRequest:page_token": {
            "paramName": "page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value returned by the last `ListSubscriptionsResponse`; indicates that",
              " this is a continuation of a prior `ListSubscriptions` call, and that the",
              " system should return the next page of data."
            ]
          },
          "ListSubscriptionsResponse:subscriptions": {
            "paramName": "subscriptions",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The subscriptions that match the request."
            ]
          },
          "ListSubscriptionsResponse:next_page_token": {
            "paramName": "next_page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " If not empty, indicates that there may be more subscriptions that match",
              " the request; this value should be passed in a new",
              " `ListSubscriptionsRequest` to get more subscriptions."
            ]
          },
          "DeleteSubscriptionRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription to delete.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "ModifyPushConfigRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the subscription.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "ModifyPushConfigRequest:push_config": {
            "paramName": "push_config",
            "paramType": ".google.pubsub.v1.PushConfig",
            "comments": [
              " Required. The push configuration for future deliveries.",
              "",
              " An empty `pushConfig` indicates that the Pub/Sub system should",
              " stop pushing messages from the given subscription and allow",
              " messages to be pulled and acknowledged - effectively pausing",
              " the subscription if `Pull` or `StreamingPull` is not called."
            ],
            "fieldBehavior": 2
          },
          "PullRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription from which messages should be pulled.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "PullRequest:return_immediately": {
            "paramName": "return_immediately",
            "paramType": "TYPE_BOOL",
            "comments": [
              " Optional. If this field set to true, the system will respond immediately",
              " even if it there are no messages available to return in the `Pull`",
              " response. Otherwise, the system may wait (for a bounded amount of time)",
              " until at least one message is available, rather than returning no messages.",
              " Warning: setting this field to `true` is discouraged because it adversely",
              " impacts the performance of `Pull` operations. We recommend that users do",
              " not set this field."
            ],
            "fieldBehavior": 1
          },
          "PullRequest:max_messages": {
            "paramName": "max_messages",
            "paramType": "TYPE_INT32",
            "comments": [
              " Required. The maximum number of messages to return for this request. Must",
              " be a positive integer. The Pub/Sub system may return fewer than the number",
              " specified."
            ],
            "fieldBehavior": 2
          },
          "PullResponse:received_messages": {
            "paramName": "received_messages",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Received Pub/Sub messages. The list will be empty if there are no more",
              " messages available in the backlog. For JSON, the response can be entirely",
              " empty. The Pub/Sub system may return fewer than the `maxMessages` requested",
              " even if there are more messages available in the backlog."
            ]
          },
          "ModifyAckDeadlineRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the subscription.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "ModifyAckDeadlineRequest:ack_ids": {
            "paramName": "ack_ids",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Required. List of acknowledgment IDs."
            ],
            "fieldBehavior": 2
          },
          "ModifyAckDeadlineRequest:ack_deadline_seconds": {
            "paramName": "ack_deadline_seconds",
            "paramType": "TYPE_INT32",
            "comments": [
              " Required. The new ack deadline with respect to the time this request was",
              " sent to the Pub/Sub system. For example, if the value is 10, the new ack",
              " deadline will expire 10 seconds after the `ModifyAckDeadline` call was",
              " made. Specifying zero might immediately make the message available for",
              " delivery to another subscriber client. This typically results in an",
              " increase in the rate of message redeliveries (that is, duplicates).",
              " The minimum deadline you can specify is 0 seconds.",
              " The maximum deadline you can specify is 600 seconds (10 minutes)."
            ],
            "fieldBehavior": 2
          },
          "AcknowledgeRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription whose message is being acknowledged.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "AcknowledgeRequest:ack_ids": {
            "paramName": "ack_ids",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Required. The acknowledgment ID for the messages being acknowledged that",
              " was returned by the Pub/Sub system in the `Pull` response. Must not be",
              " empty."
            ],
            "fieldBehavior": 2
          },
          "StreamingPullRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription for which to initialize the new stream. This",
              " must be provided in the first request on the stream, and must not be set in",
              " subsequent requests from client to server.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "StreamingPullRequest:ack_ids": {
            "paramName": "ack_ids",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " List of acknowledgement IDs for acknowledging previously received messages",
              " (received on this stream or a different stream). If an ack ID has expired,",
              " the corresponding message may be redelivered later. Acknowledging a message",
              " more than once will not result in an error. If the acknowledgement ID is",
              " malformed, the stream will be aborted with status `INVALID_ARGUMENT`."
            ]
          },
          "StreamingPullRequest:modify_deadline_seconds": {
            "paramName": "modify_deadline_seconds",
            "paramType": "TYPE_INT32[]",
            "comments": [
              " The list of new ack deadlines for the IDs listed in",
              " `modify_deadline_ack_ids`. The size of this list must be the same as the",
              " size of `modify_deadline_ack_ids`. If it differs the stream will be aborted",
              " with `INVALID_ARGUMENT`. Each element in this list is applied to the",
              " element in the same position in `modify_deadline_ack_ids`. The new ack",
              " deadline is with respect to the time this request was sent to the Pub/Sub",
              " system. Must be >= 0. For example, if the value is 10, the new ack deadline",
              " will expire 10 seconds after this request is received. If the value is 0,",
              " the message is immediately made available for another streaming or",
              " non-streaming pull request. If the value is < 0 (an error), the stream will",
              " be aborted with status `INVALID_ARGUMENT`."
            ]
          },
          "StreamingPullRequest:modify_deadline_ack_ids": {
            "paramName": "modify_deadline_ack_ids",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " List of acknowledgement IDs whose deadline will be modified based on the",
              " corresponding element in `modify_deadline_seconds`. This field can be used",
              " to indicate that more time is needed to process a message by the",
              " subscriber, or to make the message available for redelivery if the",
              " processing was interrupted."
            ]
          },
          "StreamingPullRequest:stream_ack_deadline_seconds": {
            "paramName": "stream_ack_deadline_seconds",
            "paramType": "TYPE_INT32",
            "comments": [
              " Required. The ack deadline to use for the stream. This must be provided in",
              " the first request on the stream, but it can also be updated on subsequent",
              " requests from client to server. The minimum deadline you can specify is 10",
              " seconds. The maximum deadline you can specify is 600 seconds (10 minutes)."
            ],
            "fieldBehavior": 2
          },
          "StreamingPullRequest:client_id": {
            "paramName": "client_id",
            "paramType": "TYPE_STRING",
            "comments": [
              " A unique identifier that is used to distinguish client instances from each",
              " other. Only needs to be provided on the initial request. When a stream",
              " disconnects and reconnects for the same stream, the client_id should be set",
              " to the same value so that state associated with the old stream can be",
              " transferred to the new stream. The same client_id should not be used for",
              " different client instances."
            ]
          },
          "StreamingPullRequest:max_outstanding_messages": {
            "paramName": "max_outstanding_messages",
            "paramType": "TYPE_INT64",
            "comments": [
              " Flow control settings for the maximum number of outstanding messages. When",
              " there are `max_outstanding_messages` or more currently sent to the",
              " streaming pull client that have not yet been acked or nacked, the server",
              " stops sending more messages. The sending of messages resumes once the",
              " number of outstanding messages is less than this value. If the value is",
              " <= 0, there is no limit to the number of outstanding messages. This",
              " property can only be set on the initial StreamingPullRequest. If it is set",
              " on a subsequent request, the stream will be aborted with status",
              " `INVALID_ARGUMENT`."
            ]
          },
          "StreamingPullRequest:max_outstanding_bytes": {
            "paramName": "max_outstanding_bytes",
            "paramType": "TYPE_INT64",
            "comments": [
              " Flow control settings for the maximum number of outstanding bytes. When",
              " there are `max_outstanding_bytes` or more worth of messages currently sent",
              " to the streaming pull client that have not yet been acked or nacked, the",
              " server will stop sending more messages. The sending of messages resumes",
              " once the number of outstanding bytes is less than this value. If the value",
              " is <= 0, there is no limit to the number of outstanding bytes. This",
              " property can only be set on the initial StreamingPullRequest. If it is set",
              " on a subsequent request, the stream will be aborted with status",
              " `INVALID_ARGUMENT`."
            ]
          },
          "StreamingPullResponse:received_messages": {
            "paramName": "received_messages",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Received Pub/Sub messages. This will not be empty."
            ]
          },
          "CreateSnapshotRequest:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. User-provided name for this snapshot. If the name is not provided",
              " in the request, the server will assign a random name for this snapshot on",
              " the same project as the subscription. Note that for REST API requests, you",
              " must specify a name.  See the <a",
              " href=\"https://cloud.google.com/pubsub/docs/admin#resource_names\"> resource",
              " name rules</a>. Format is `projects/{project}/snapshots/{snap}`."
            ],
            "fieldBehavior": 2
          },
          "CreateSnapshotRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription whose backlog the snapshot retains.",
              " Specifically, the created snapshot is guaranteed to retain:",
              "  (a) The existing backlog on the subscription. More precisely, this is",
              "      defined as the messages in the subscription's backlog that are",
              "      unacknowledged upon the successful completion of the",
              "      `CreateSnapshot` request; as well as:",
              "  (b) Any messages published to the subscription's topic following the",
              "      successful completion of the CreateSnapshot request.",
              " Format is `projects/{project}/subscriptions/{sub}`."
            ],
            "fieldBehavior": 2
          },
          "CreateSnapshotRequest:labels": {
            "paramName": "labels",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " See <a href=\"https://cloud.google.com/pubsub/docs/labels\"> Creating and",
              " managing labels</a>."
            ]
          },
          "UpdateSnapshotRequest:snapshot": {
            "paramName": "snapshot",
            "paramType": ".google.pubsub.v1.Snapshot",
            "comments": [
              " Required. The updated snapshot object."
            ],
            "fieldBehavior": 2
          },
          "UpdateSnapshotRequest:update_mask": {
            "paramName": "update_mask",
            "paramType": ".google.protobuf.FieldMask",
            "comments": [
              " Required. Indicates which fields in the provided snapshot to update.",
              " Must be specified and non-empty."
            ],
            "fieldBehavior": 2
          },
          "Snapshot:name": {
            "paramName": "name",
            "paramType": "TYPE_STRING",
            "comments": [
              " The name of the snapshot."
            ]
          },
          "Snapshot:topic": {
            "paramName": "topic",
            "paramType": "TYPE_STRING",
            "comments": [
              " The name of the topic from which this snapshot is retaining messages."
            ]
          },
          "Snapshot:expire_time": {
            "paramName": "expire_time",
            "paramType": ".google.protobuf.Timestamp",
            "comments": [
              " The snapshot is guaranteed to exist up until this time.",
              " A newly-created snapshot expires no later than 7 days from the time of its",
              " creation. Its exact lifetime is determined at creation by the existing",
              " backlog in the source subscription. Specifically, the lifetime of the",
              " snapshot is `7 days - (age of oldest unacked message in the subscription)`.",
              " For example, consider a subscription whose oldest unacked message is 3 days",
              " old. If a snapshot is created from this subscription, the snapshot -- which",
              " will always capture this 3-day-old backlog as long as the snapshot",
              " exists -- will expire in 4 days. The service will refuse to create a",
              " snapshot that would expire in less than 1 hour after creation."
            ]
          },
          "Snapshot:labels": {
            "paramName": "labels",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " See [Creating and managing labels]",
              " (https://cloud.google.com/pubsub/docs/labels)."
            ]
          },
          "GetSnapshotRequest:snapshot": {
            "paramName": "snapshot",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the snapshot to get.",
              " Format is `projects/{project}/snapshots/{snap}`."
            ],
            "fieldBehavior": 2
          },
          "ListSnapshotsRequest:project": {
            "paramName": "project",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the project in which to list snapshots.",
              " Format is `projects/{project-id}`."
            ],
            "fieldBehavior": 2
          },
          "ListSnapshotsRequest:page_size": {
            "paramName": "page_size",
            "paramType": "TYPE_INT32",
            "comments": [
              " Maximum number of snapshots to return."
            ]
          },
          "ListSnapshotsRequest:page_token": {
            "paramName": "page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " The value returned by the last `ListSnapshotsResponse`; indicates that this",
              " is a continuation of a prior `ListSnapshots` call, and that the system",
              " should return the next page of data."
            ]
          },
          "ListSnapshotsResponse:snapshots": {
            "paramName": "snapshots",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The resulting snapshots."
            ]
          },
          "ListSnapshotsResponse:next_page_token": {
            "paramName": "next_page_token",
            "paramType": "TYPE_STRING",
            "comments": [
              " If not empty, indicates that there may be more snapshot that match the",
              " request; this value should be passed in a new `ListSnapshotsRequest`."
            ]
          },
          "DeleteSnapshotRequest:snapshot": {
            "paramName": "snapshot",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The name of the snapshot to delete.",
              " Format is `projects/{project}/snapshots/{snap}`."
            ],
            "fieldBehavior": 2
          },
          "SeekRequest:subscription": {
            "paramName": "subscription",
            "paramType": "TYPE_STRING",
            "comments": [
              " Required. The subscription to affect."
            ],
            "fieldBehavior": 2
          },
          "SeekRequest:time": {
            "paramName": "time",
            "paramType": ".google.protobuf.Timestamp",
            "comments": [
              " The time to seek to.",
              " Messages retained in the subscription that were published before this",
              " time are marked as acknowledged, and messages retained in the",
              " subscription that were published after this time are marked as",
              " unacknowledged. Note that this operation affects only those messages",
              " retained in the subscription (configured by the combination of",
              " `message_retention_duration` and `retain_acked_messages`). For example,",
              " if `time` corresponds to a point before the message retention",
              " window (or to a point before the system's notion of the subscription",
              " creation time), only retained messages will be marked as unacknowledged,",
              " and already-expunged messages will not be restored."
            ]
          },
          "SeekRequest:snapshot": {
            "paramName": "snapshot",
            "paramType": "TYPE_STRING",
            "comments": [
              " The snapshot to seek to. The snapshot's topic must be the same as that of",
              " the provided subscription.",
              " Format is `projects/{project}/snapshots/{snap}`."
            ]
          },
          "GetPolicyOptions:requested_policy_version": {
            "paramName": "requested_policy_version",
            "paramType": "TYPE_INT32",
            "comments": [
              " Optional. The policy format version to be returned.",
              "",
              " Valid values are 0, 1, and 3. Requests specifying an invalid value will be",
              " rejected.",
              "",
              " Requests for policies with any conditional bindings must specify version 3.",
              " Policies without any conditional bindings may specify any valid value or",
              " leave the field unset."
            ]
          },
          "Expr:expression": {
            "paramName": "expression",
            "paramType": "TYPE_STRING",
            "comments": [
              " Textual representation of an expression in Common Expression Language",
              " syntax."
            ]
          },
          "Expr:title": {
            "paramName": "title",
            "paramType": "TYPE_STRING",
            "comments": [
              " Optional. Title for the expression, i.e. a short string describing",
              " its purpose. This can be used e.g. in UIs which allow to enter the",
              " expression."
            ]
          },
          "Expr:description": {
            "paramName": "description",
            "paramType": "TYPE_STRING",
            "comments": [
              " Optional. Description of the expression. This is a longer text which",
              " describes the expression, e.g. when hovered over it in a UI."
            ]
          },
          "Expr:location": {
            "paramName": "location",
            "paramType": "TYPE_STRING",
            "comments": [
              " Optional. String indicating the location of the expression for error",
              " reporting, e.g. a file name and a position in the file."
            ]
          },
          "Policy:version": {
            "paramName": "version",
            "paramType": "TYPE_INT32",
            "comments": [
              " Specifies the format of the policy.",
              "",
              " Valid values are `0`, `1`, and `3`. Requests that specify an invalid value",
              " are rejected.",
              "",
              " Any operation that affects conditional role bindings must specify version",
              " `3`. This requirement applies to the following operations:",
              "",
              " * Getting a policy that includes a conditional role binding",
              " * Adding a conditional role binding to a policy",
              " * Changing a conditional role binding in a policy",
              " * Removing any role binding, with or without a condition, from a policy",
              "   that includes conditions",
              "",
              " **Important:** If you use IAM Conditions, you must include the `etag` field",
              " whenever you call `setIamPolicy`. If you omit this field, then IAM allows",
              " you to overwrite a version `3` policy with a version `1` policy, and all of",
              " the conditions in the version `3` policy are lost.",
              "",
              " If a policy does not include any conditions, operations on that policy may",
              " specify any valid version or leave the field unset.",
              "",
              " To learn which resources support conditions in their IAM policies, see the",
              " [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies)."
            ]
          },
          "Policy:bindings": {
            "paramName": "bindings",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Associates a list of `members`, or principals, with a `role`. Optionally,",
              " may specify a `condition` that determines how and when the `bindings` are",
              " applied. Each of the `bindings` must contain at least one principal.",
              "",
              " The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250",
              " of these principals can be Google groups. Each occurrence of a principal",
              " counts towards these limits. For example, if the `bindings` grant 50",
              " different roles to `user:alice@example.com`, and not to any other",
              " principal, then you can add another 1,450 principals to the `bindings` in",
              " the `Policy`."
            ]
          },
          "Policy:audit_configs": {
            "paramName": "audit_configs",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " Specifies cloud audit logging configuration for this policy."
            ]
          },
          "Policy:etag": {
            "paramName": "etag",
            "paramType": "TYPE_BYTES",
            "comments": [
              " `etag` is used for optimistic concurrency control as a way to help",
              " prevent simultaneous updates of a policy from overwriting each other.",
              " It is strongly suggested that systems make use of the `etag` in the",
              " read-modify-write cycle to perform policy updates in order to avoid race",
              " conditions: An `etag` is returned in the response to `getIamPolicy`, and",
              " systems are expected to put that etag in the request to `setIamPolicy` to",
              " ensure that their change will be applied to the same version of the policy.",
              "",
              " **Important:** If you use IAM Conditions, you must include the `etag` field",
              " whenever you call `setIamPolicy`. If you omit this field, then IAM allows",
              " you to overwrite a version `3` policy with a version `1` policy, and all of",
              " the conditions in the version `3` policy are lost."
            ]
          },
          "Binding:role": {
            "paramName": "role",
            "paramType": "TYPE_STRING",
            "comments": [
              " Role that is assigned to the list of `members`, or principals.",
              " For example, `roles/viewer`, `roles/editor`, or `roles/owner`."
            ]
          },
          "Binding:members": {
            "paramName": "members",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Specifies the principals requesting access for a Cloud Platform resource.",
              " `members` can have the following values:",
              "",
              " * `allUsers`: A special identifier that represents anyone who is",
              "    on the internet; with or without a Google account.",
              "",
              " * `allAuthenticatedUsers`: A special identifier that represents anyone",
              "    who is authenticated with a Google account or a service account.",
              "",
              " * `user:{emailid}`: An email address that represents a specific Google",
              "    account. For example, `alice@example.com` .",
              "",
              "",
              " * `serviceAccount:{emailid}`: An email address that represents a service",
              "    account. For example, `my-other-app@appspot.gserviceaccount.com`.",
              "",
              " * `group:{emailid}`: An email address that represents a Google group.",
              "    For example, `admins@example.com`.",
              "",
              " * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique",
              "    identifier) representing a user that has been recently deleted. For",
              "    example, `alice@example.com?uid=123456789012345678901`. If the user is",
              "    recovered, this value reverts to `user:{emailid}` and the recovered user",
              "    retains the role in the binding.",
              "",
              " * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus",
              "    unique identifier) representing a service account that has been recently",
              "    deleted. For example,",
              "    `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`.",
              "    If the service account is undeleted, this value reverts to",
              "    `serviceAccount:{emailid}` and the undeleted service account retains the",
              "    role in the binding.",
              "",
              " * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique",
              "    identifier) representing a Google group that has been recently",
              "    deleted. For example, `admins@example.com?uid=123456789012345678901`. If",
              "    the group is recovered, this value reverts to `group:{emailid}` and the",
              "    recovered group retains the role in the binding.",
              "",
              "",
              " * `domain:{domain}`: The G Suite domain (primary) that represents all the",
              "    users of that domain. For example, `google.com` or `example.com`.",
              "",
              ""
            ]
          },
          "Binding:condition": {
            "paramName": "condition",
            "paramType": ".google.type.Expr",
            "comments": [
              " The condition that is associated with this binding.",
              "",
              " If the condition evaluates to `true`, then this binding applies to the",
              " current request.",
              "",
              " If the condition evaluates to `false`, then this binding does not apply to",
              " the current request. However, a different role binding might grant the same",
              " role to one or more of the principals in this binding.",
              "",
              " To learn which resources support conditions in their IAM policies, see the",
              " [IAM",
              " documentation](https://cloud.google.com/iam/help/conditions/resource-policies)."
            ]
          },
          "AuditConfig:service": {
            "paramName": "service",
            "paramType": "TYPE_STRING",
            "comments": [
              " Specifies a service that will be enabled for audit logging.",
              " For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.",
              " `allServices` is a special value that covers all services."
            ]
          },
          "AuditConfig:audit_log_configs": {
            "paramName": "audit_log_configs",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The configuration for logging of each type of permission."
            ]
          },
          "AuditLogConfig:log_type": {
            "paramName": "log_type",
            "paramType": ".google.iam.v1.AuditLogConfig.LogType",
            "comments": [
              " The log type that this config enables."
            ]
          },
          "AuditLogConfig:exempted_members": {
            "paramName": "exempted_members",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " Specifies the identities that do not cause logging for this type of",
              " permission.",
              " Follows the same format of [Binding.members][google.iam.v1.Binding.members]."
            ]
          },
          "PolicyDelta:binding_deltas": {
            "paramName": "binding_deltas",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The delta for Bindings between two policies."
            ]
          },
          "PolicyDelta:audit_config_deltas": {
            "paramName": "audit_config_deltas",
            "paramType": "TYPE_MESSAGE[]",
            "comments": [
              " The delta for AuditConfigs between two policies."
            ]
          },
          "BindingDelta:action": {
            "paramName": "action",
            "paramType": ".google.iam.v1.BindingDelta.Action",
            "comments": [
              " The action that was performed on a Binding.",
              " Required"
            ]
          },
          "BindingDelta:role": {
            "paramName": "role",
            "paramType": "TYPE_STRING",
            "comments": [
              " Role that is assigned to `members`.",
              " For example, `roles/viewer`, `roles/editor`, or `roles/owner`.",
              " Required"
            ]
          },
          "BindingDelta:member": {
            "paramName": "member",
            "paramType": "TYPE_STRING",
            "comments": [
              " A single identity requesting access for a Cloud Platform resource.",
              " Follows the same format of Binding.members.",
              " Required"
            ]
          },
          "BindingDelta:condition": {
            "paramName": "condition",
            "paramType": ".google.type.Expr",
            "comments": [
              " The condition that is associated with this binding."
            ]
          },
          "AuditConfigDelta:action": {
            "paramName": "action",
            "paramType": ".google.iam.v1.AuditConfigDelta.Action",
            "comments": [
              " The action that was performed on an audit configuration in a policy.",
              " Required"
            ]
          },
          "AuditConfigDelta:service": {
            "paramName": "service",
            "paramType": "TYPE_STRING",
            "comments": [
              " Specifies a service that was configured for Cloud Audit Logging.",
              " For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.",
              " `allServices` is a special value that covers all services.",
              " Required"
            ]
          },
          "AuditConfigDelta:exempted_member": {
            "paramName": "exempted_member",
            "paramType": "TYPE_STRING",
            "comments": [
              " A single identity that is exempted from \"data access\" audit",
              " logging for the `service` specified above.",
              " Follows the same format of Binding.members."
            ]
          },
          "AuditConfigDelta:log_type": {
            "paramName": "log_type",
            "paramType": "TYPE_STRING",
            "comments": [
              " Specifies the log_type that was be enabled. ADMIN_ACTIVITY is always",
              " enabled, and cannot be configured.",
              " Required"
            ]
          },
          "IAMPolicy": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " ## API Overview",
              "",
              " Manages Identity and Access Management (IAM) policies.",
              "",
              " Any implementation of an API that offers access control features",
              " implements the google.iam.v1.IAMPolicy interface.",
              "",
              " ## Data model",
              "",
              " Access control is applied when a principal (user or service account), takes",
              " some action on a resource exposed by a service. Resources, identified by",
              " URI-like names, are the unit of access control specification. Service",
              " implementations can choose the granularity of access control and the",
              " supported permissions for their resources.",
              " For example one database service may allow access control to be",
              " specified only at the Table level, whereas another might allow access control",
              " to also be specified at the Column level.",
              "",
              " ## Policy Structure",
              "",
              " See google.iam.v1.Policy",
              "",
              " This is intentionally not a CRUD style API because access control policies",
              " are created and deleted implicitly with the resources to which they are",
              " attached."
            ]
          },
          "IAMPolicy:SetIamPolicy": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Sets the access control policy on the specified resource. Replaces any",
              " existing policy.",
              ""
            ]
          },
          "IAMPolicy:GetIamPolicy": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Gets the access control policy for a resource.",
              " Returns an empty policy if the resource exists and does not have a policy",
              " set.",
              ""
            ]
          },
          "IAMPolicy:TestIamPermissions": {
            "paramName": "",
            "paramType": "",
            "comments": [
              " Returns permissions that a caller has on the specified resource.",
              " If the resource does not exist, this will return an empty set of",
              " permissions, not a NOT_FOUND error.",
              "",
              " Note: This operation is designed to be used for building permission-aware",
              " UIs and command-line tools, not for authorization checking. This operation",
              " may \"fail open\" without warning.",
              ""
            ]
          },
          "SetIamPolicyRequest:resource": {
            "paramName": "resource",
            "paramType": "TYPE_STRING",
            "comments": [
              " REQUIRED: The resource for which the policy is being specified.",
              " See the operation documentation for the appropriate value for this field."
            ],
            "fieldBehavior": 2
          },
          "SetIamPolicyRequest:policy": {
            "paramName": "policy",
            "paramType": ".google.iam.v1.Policy",
            "comments": [
              " REQUIRED: The complete policy to be applied to the `resource`. The size of",
              " the policy is limited to a few 10s of KB. An empty policy is a",
              " valid policy but certain Cloud Platform services (such as Projects)",
              " might reject them."
            ],
            "fieldBehavior": 2
          },
          "GetIamPolicyRequest:resource": {
            "paramName": "resource",
            "paramType": "TYPE_STRING",
            "comments": [
              " REQUIRED: The resource for which the policy is being requested.",
              " See the operation documentation for the appropriate value for this field."
            ],
            "fieldBehavior": 2
          },
          "GetIamPolicyRequest:options": {
            "paramName": "options",
            "paramType": ".google.iam.v1.GetPolicyOptions",
            "comments": [
              " OPTIONAL: A `GetPolicyOptions` object for specifying options to",
              " `GetIamPolicy`. This field is only used by Cloud IAM."
            ]
          },
          "TestIamPermissionsRequest:resource": {
            "paramName": "resource",
            "paramType": "TYPE_STRING",
            "comments": [
              " REQUIRED: The resource for which the policy detail is being requested.",
              " See the operation documentation for the appropriate value for this field."
            ],
            "fieldBehavior": 2
          },
          "TestIamPermissionsRequest:permissions": {
            "paramName": "permissions",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " The set of permissions to check for the `resource`. Permissions with",
              " wildcards (such as '*' or 'storage.*') are not allowed. For more",
              " information see",
              " [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions)."
            ],
            "fieldBehavior": 2
          },
          "TestIamPermissionsResponse:permissions": {
            "paramName": "permissions",
            "paramType": "TYPE_STRING[]",
            "comments": [
              " A subset of `TestPermissionsRequest.permissions` that the caller is",
              " allowed."
            ]
          }
        }
      },
      "retryableCodeMap": {
        "uniqueCodesNamesMap": {
          "": "non_idempotent",
          "deadline_exceeded_unavailable": "idempotent"
        },
        "prettyCodesNamesMap": {
          "non_idempotent": [],
          "idempotent": [
            "DEADLINE_EXCEEDED",
            "UNAVAILABLE"
          ]
        },
        "uniqueParamsNamesMap": {
          "94312e9926796a52a8fcbbedaac41972e07ccd1c": "default"
        },
        "prettyParamNamesMap": {
          "default": {
            "initial_retry_delay_millis": 100,
            "retry_delay_multiplier": 1.3,
            "max_retry_delay_millis": 60000,
            "initial_rpc_timeout_millis": 60000,
            "rpc_timeout_multiplier": 1,
            "max_rpc_timeout_millis": 60000,
            "total_timeout_millis": 600000
          }
        },
        "codeEnumMapping": {
          "0": "OK",
          "1": "CANCELLED",
          "2": "UNKNOWN",
          "3": "INVALID_ARGUMENT",
          "4": "DEADLINE_EXCEEDED",
          "5": "NOT_FOUND",
          "6": "ALREADY_EXISTS",
          "7": "PERMISSION_DENIED",
          "8": "RESOURCE_EXHAUSTED",
          "9": "FAILED_PRECONDITION",
          "10": "ABORTED",
          "11": "OUT_OF_RANGE",
          "12": "UNIMPLEMENTED",
          "13": "INTERNAL",
          "14": "UNAVAILABLE",
          "15": "DATA_LOSS",
          "16": "UNAUTHENTICATED"
        }
      },
      "grpcServiceConfig": {},
      "bundleConfigs": [],
      "bundleConfigsMethods": [],
      "simpleMethods": [
        {
          "inputInterface": ".google.pubsub.v1.Subscription",
          "outputInterface": ".google.pubsub.v1.Subscription",
          "comments": [
            " Creates a subscription to a given topic. See the [resource name rules]",
            " (https://cloud.google.com/pubsub/docs/admin#resource_names).",
            " If the subscription already exists, returns `ALREADY_EXISTS`.",
            " If the corresponding topic doesn't exist, returns `NOT_FOUND`.",
            "",
            " If the name is not provided in the request, the server will assign a random",
            " name for this subscription on the same project as the topic, conforming",
            " to the [resource name format]",
            " (https://cloud.google.com/pubsub/docs/admin#resource_names). The generated",
            " name is populated in the returned Subscription object. Note that for REST",
            " API requests, you must specify a name in the request.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "CreateSubscription",
          "inputType": ".google.pubsub.v1.Subscription",
          "outputType": ".google.pubsub.v1.Subscription",
          "options": {
            ".google.api.methodSignature": [
              "name,topic,push_config,ack_deadline_seconds"
            ],
            ".google.api.http": {
              "put": "/v1/{name=projects/*/subscriptions/*}",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "name",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the subscription. It must have the format",
                " `\"projects/{project}/subscriptions/{subscription}\"`. `{subscription}` must",
                " start with a letter, and contain only letters (`[A-Za-z]`), numbers",
                " (`[0-9]`), dashes (`-`), underscores (`_`), periods (`.`), tildes (`~`),",
                " plus (`+`) or percent signs (`%`). It must be between 3 and 255 characters",
                " in length, and it must not start with `\"goog\"`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "topic",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the topic from which this subscription is receiving",
                " messages. Format is `projects/{project}/topics/{topic}`. The value of this",
                " field will be `_deleted-topic_` if the topic has been deleted."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "push_config",
              "paramType": ".google.pubsub.v1.PushConfig",
              "comments": [
                " If push delivery is used with this subscription, this field is",
                " used to configure it. An empty `pushConfig` signifies that the subscriber",
                " will pull and ack messages using API methods."
              ]
            },
            {
              "paramName": "ack_deadline_seconds",
              "paramType": "TYPE_INT32",
              "comments": [
                " The approximate amount of time (on a best-effort basis) Pub/Sub waits for",
                " the subscriber to acknowledge receipt before resending the message. In the",
                " interval after the message is delivered and before it is acknowledged, it",
                " is considered to be <i>outstanding</i>. During that time period, the",
                " message will not be redelivered (on a best-effort basis).",
                "",
                " For pull subscriptions, this value is used as the initial value for the ack",
                " deadline. To override this value for a given message, call",
                " `ModifyAckDeadline` with the corresponding `ack_id` if using",
                " non-streaming pull or send the `ack_id` in a",
                " `StreamingModifyAckDeadlineRequest` if using streaming pull.",
                " The minimum custom deadline you can specify is 10 seconds.",
                " The maximum custom deadline you can specify is 600 seconds (10 minutes).",
                " If this parameter is 0, a default value of 10 seconds is used.",
                "",
                " For push delivery, this value is also used to set the request timeout for",
                " the call to the push endpoint.",
                "",
                " If the subscriber never acknowledges the message, the Pub/Sub",
                " system will eventually redeliver the message."
              ]
            },
            {
              "paramName": "retain_acked_messages",
              "paramType": "TYPE_BOOL",
              "comments": [
                " Indicates whether to retain acknowledged messages. If true, then",
                " messages are not expunged from the subscription's backlog, even if they are",
                " acknowledged, until they fall out of the `message_retention_duration`",
                " window. This must be true if you would like to [Seek to a timestamp]",
                " (https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time)."
              ]
            },
            {
              "paramName": "message_retention_duration",
              "paramType": ".google.protobuf.Duration",
              "comments": [
                " How long to retain unacknowledged messages in the subscription's backlog,",
                " from the moment a message is published.",
                " If `retain_acked_messages` is true, then this also configures the retention",
                " of acknowledged messages, and thus configures how far back in time a `Seek`",
                " can be done. Defaults to 7 days. Cannot be more than 7 days or less than 10",
                " minutes."
              ]
            },
            {
              "paramName": "labels",
              "paramType": "TYPE_MESSAGE[]",
              "comments": [
                " See <a href=\"https://cloud.google.com/pubsub/docs/labels\"> Creating and",
                " managing labels</a>."
              ]
            },
            {
              "paramName": "enable_message_ordering",
              "paramType": "TYPE_BOOL",
              "comments": [
                " If true, messages published with the same `ordering_key` in `PubsubMessage`",
                " will be delivered to the subscribers in the order in which they",
                " are received by the Pub/Sub system. Otherwise, they may be delivered in",
                " any order."
              ]
            },
            {
              "paramName": "expiration_policy",
              "paramType": ".google.pubsub.v1.ExpirationPolicy",
              "comments": [
                " A policy that specifies the conditions for this subscription's expiration.",
                " A subscription is considered active as long as any connected subscriber is",
                " successfully consuming messages from the subscription or is issuing",
                " operations on the subscription. If `expiration_policy` is not set, a",
                " *default policy* with `ttl` of 31 days will be used. The minimum allowed",
                " value for `expiration_policy.ttl` is 1 day."
              ]
            },
            {
              "paramName": "filter",
              "paramType": "TYPE_STRING",
              "comments": [
                " An expression written in the Pub/Sub [filter",
                " language](https://cloud.google.com/pubsub/docs/filtering). If non-empty,",
                " then only `PubsubMessage`s whose `attributes` field matches the filter are",
                " delivered on this subscription. If empty, then no messages are filtered",
                " out."
              ]
            },
            {
              "paramName": "dead_letter_policy",
              "paramType": ".google.pubsub.v1.DeadLetterPolicy",
              "comments": [
                " A policy that specifies the conditions for dead lettering messages in",
                " this subscription. If dead_letter_policy is not set, dead lettering",
                " is disabled.",
                "",
                " The Cloud Pub/Sub service account associated with this subscriptions's",
                " parent project (i.e.,",
                " service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have",
                " permission to Acknowledge() messages on this subscription."
              ]
            },
            {
              "paramName": "retry_policy",
              "paramType": ".google.pubsub.v1.RetryPolicy",
              "comments": [
                " A policy that specifies how Pub/Sub retries message delivery for this",
                " subscription.",
                "",
                " If not set, the default retry policy is applied. This generally implies",
                " that messages will be retried as soon as possible for healthy subscribers.",
                " RetryPolicy will be triggered on NACKs or acknowledgement deadline",
                " exceeded events for a given message."
              ]
            },
            {
              "paramName": "detached",
              "paramType": "TYPE_BOOL",
              "comments": [
                " Indicates whether the subscription is detached from its topic. Detached",
                " subscriptions don't receive messages from their topic and don't retain any",
                " backlog. `Pull` and `StreamingPull` requests will return",
                " FAILED_PRECONDITION. If the subscription is a push subscription, pushes to",
                " the endpoint will not be made."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "name"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.GetSubscriptionRequest",
          "outputInterface": ".google.pubsub.v1.Subscription",
          "comments": [
            " Gets the configuration details of a subscription.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "GetSubscription",
          "inputType": ".google.pubsub.v1.GetSubscriptionRequest",
          "outputType": ".google.pubsub.v1.Subscription",
          "options": {
            ".google.api.methodSignature": [
              "subscription"
            ],
            ".google.api.http": {
              "get": "/v1/{subscription=projects/*/subscriptions/*}"
            }
          },
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the subscription to get.",
                " Format is `projects/{project}/subscriptions/{sub}`."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "subscription"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.UpdateSubscriptionRequest",
          "outputInterface": ".google.pubsub.v1.Subscription",
          "comments": [
            " Updates an existing subscription. Note that certain properties of a",
            " subscription, such as its topic, are not modifiable.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "UpdateSubscription",
          "inputType": ".google.pubsub.v1.UpdateSubscriptionRequest",
          "outputType": ".google.pubsub.v1.Subscription",
          "options": {
            ".google.api.http": {
              "patch": "/v1/{subscription.name=projects/*/subscriptions/*}",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": ".google.pubsub.v1.Subscription",
              "comments": [
                " Required. The updated subscription object."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "update_mask",
              "paramType": ".google.protobuf.FieldMask",
              "comments": [
                " Required. Indicates which fields in the provided subscription to update.",
                " Must be specified and non-empty."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "subscription",
              "name"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.DeleteSubscriptionRequest",
          "outputInterface": ".google.protobuf.Empty",
          "comments": [
            " Deletes an existing subscription. All messages retained in the subscription",
            " are immediately dropped. Calls to `Pull` after deletion will return",
            " `NOT_FOUND`. After a subscription is deleted, a new one may be created with",
            " the same name, but the new one has no association with the old",
            " subscription or its topic unless the same topic is specified.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "DeleteSubscription",
          "inputType": ".google.pubsub.v1.DeleteSubscriptionRequest",
          "outputType": ".google.protobuf.Empty",
          "options": {
            ".google.api.methodSignature": [
              "subscription"
            ],
            ".google.api.http": {
              "delete": "/v1/{subscription=projects/*/subscriptions/*}"
            }
          },
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The subscription to delete.",
                " Format is `projects/{project}/subscriptions/{sub}`."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "subscription"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.ModifyAckDeadlineRequest",
          "outputInterface": ".google.protobuf.Empty",
          "comments": [
            " Modifies the ack deadline for a specific message. This method is useful",
            " to indicate that more time is needed to process a message by the",
            " subscriber, or to make the message available for redelivery if the",
            " processing was interrupted. Note that this does not modify the",
            " subscription-level `ackDeadlineSeconds` used for subsequent messages.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ModifyAckDeadline",
          "inputType": ".google.pubsub.v1.ModifyAckDeadlineRequest",
          "outputType": ".google.protobuf.Empty",
          "options": {
            ".google.api.methodSignature": [
              "subscription,ack_ids,ack_deadline_seconds"
            ],
            ".google.api.http": {
              "post": "/v1/{subscription=projects/*/subscriptions/*}:modifyAckDeadline",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the subscription.",
                " Format is `projects/{project}/subscriptions/{sub}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "ack_ids",
              "paramType": "TYPE_STRING[]",
              "comments": [
                " Required. List of acknowledgment IDs."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "ack_deadline_seconds",
              "paramType": "TYPE_INT32",
              "comments": [
                " Required. The new ack deadline with respect to the time this request was",
                " sent to the Pub/Sub system. For example, if the value is 10, the new ack",
                " deadline will expire 10 seconds after the `ModifyAckDeadline` call was",
                " made. Specifying zero might immediately make the message available for",
                " delivery to another subscriber client. This typically results in an",
                " increase in the rate of message redeliveries (that is, duplicates).",
                " The minimum deadline you can specify is 0 seconds.",
                " The maximum deadline you can specify is 600 seconds (10 minutes)."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "subscription"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.AcknowledgeRequest",
          "outputInterface": ".google.protobuf.Empty",
          "comments": [
            " Acknowledges the messages associated with the `ack_ids` in the",
            " `AcknowledgeRequest`. The Pub/Sub system can remove the relevant messages",
            " from the subscription.",
            "",
            " Acknowledging a message whose ack deadline has expired may succeed,",
            " but such a message may be redelivered later. Acknowledging a message more",
            " than once will not result in an error.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "Acknowledge",
          "inputType": ".google.pubsub.v1.AcknowledgeRequest",
          "outputType": ".google.protobuf.Empty",
          "options": {
            ".google.api.methodSignature": [
              "subscription,ack_ids"
            ],
            ".google.api.http": {
              "post": "/v1/{subscription=projects/*/subscriptions/*}:acknowledge",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The subscription whose message is being acknowledged.",
                " Format is `projects/{project}/subscriptions/{sub}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "ack_ids",
              "paramType": "TYPE_STRING[]",
              "comments": [
                " Required. The acknowledgment ID for the messages being acknowledged that",
                " was returned by the Pub/Sub system in the `Pull` response. Must not be",
                " empty."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "subscription"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.PullRequest",
          "outputInterface": ".google.pubsub.v1.PullResponse",
          "comments": [
            " Pulls messages from the server. The server may return `UNAVAILABLE` if",
            " there are too many concurrent pull requests pending for the given",
            " subscription.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "Pull",
          "inputType": ".google.pubsub.v1.PullRequest",
          "outputType": ".google.pubsub.v1.PullResponse",
          "options": {
            ".google.api.methodSignature": [
              "subscription,return_immediately,max_messages"
            ],
            ".google.api.http": {
              "post": "/v1/{subscription=projects/*/subscriptions/*}:pull",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The subscription from which messages should be pulled.",
                " Format is `projects/{project}/subscriptions/{sub}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "return_immediately",
              "paramType": "TYPE_BOOL",
              "comments": [
                " Optional. If this field set to true, the system will respond immediately",
                " even if it there are no messages available to return in the `Pull`",
                " response. Otherwise, the system may wait (for a bounded amount of time)",
                " until at least one message is available, rather than returning no messages.",
                " Warning: setting this field to `true` is discouraged because it adversely",
                " impacts the performance of `Pull` operations. We recommend that users do",
                " not set this field."
              ],
              "fieldBehavior": 1
            },
            {
              "paramName": "max_messages",
              "paramType": "TYPE_INT32",
              "comments": [
                " Required. The maximum number of messages to return for this request. Must",
                " be a positive integer. The Pub/Sub system may return fewer than the number",
                " specified."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "subscription"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.ModifyPushConfigRequest",
          "outputInterface": ".google.protobuf.Empty",
          "comments": [
            " Modifies the `PushConfig` for a specified subscription.",
            "",
            " This may be used to change a push subscription to a pull one (signified by",
            " an empty `PushConfig`) or vice versa, or change the endpoint URL and other",
            " attributes of a push subscription. Messages will accumulate for delivery",
            " continuously through the call regardless of changes to the `PushConfig`.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ModifyPushConfig",
          "inputType": ".google.pubsub.v1.ModifyPushConfigRequest",
          "outputType": ".google.protobuf.Empty",
          "options": {
            ".google.api.methodSignature": [
              "subscription,push_config"
            ],
            ".google.api.http": {
              "post": "/v1/{subscription=projects/*/subscriptions/*}:modifyPushConfig",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the subscription.",
                " Format is `projects/{project}/subscriptions/{sub}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "push_config",
              "paramType": ".google.pubsub.v1.PushConfig",
              "comments": [
                " Required. The push configuration for future deliveries.",
                "",
                " An empty `pushConfig` indicates that the Pub/Sub system should",
                " stop pushing messages from the given subscription and allow",
                " messages to be pulled and acknowledged - effectively pausing",
                " the subscription if `Pull` or `StreamingPull` is not called."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "subscription"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.GetSnapshotRequest",
          "outputInterface": ".google.pubsub.v1.Snapshot",
          "comments": [
            " Gets the configuration details of a snapshot. Snapshots are used in",
            " <a href=\"https://cloud.google.com/pubsub/docs/replay-overview\">Seek</a>",
            " operations, which allow you to manage message acknowledgments in bulk. That",
            " is, you can set the acknowledgment state of messages in an existing",
            " subscription to the state captured by a snapshot.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "GetSnapshot",
          "inputType": ".google.pubsub.v1.GetSnapshotRequest",
          "outputType": ".google.pubsub.v1.Snapshot",
          "options": {
            ".google.api.methodSignature": [
              "snapshot"
            ],
            ".google.api.http": {
              "get": "/v1/{snapshot=projects/*/snapshots/*}"
            }
          },
          "paramComment": [
            {
              "paramName": "snapshot",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the snapshot to get.",
                " Format is `projects/{project}/snapshots/{snap}`."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "snapshot"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.CreateSnapshotRequest",
          "outputInterface": ".google.pubsub.v1.Snapshot",
          "comments": [
            " Creates a snapshot from the requested subscription. Snapshots are used in",
            " [Seek](https://cloud.google.com/pubsub/docs/replay-overview) operations,",
            " which allow you to manage message acknowledgments in bulk. That is, you can",
            " set the acknowledgment state of messages in an existing subscription to the",
            " state captured by a snapshot.",
            " If the snapshot already exists, returns `ALREADY_EXISTS`.",
            " If the requested subscription doesn't exist, returns `NOT_FOUND`.",
            " If the backlog in the subscription is too old -- and the resulting snapshot",
            " would expire in less than 1 hour -- then `FAILED_PRECONDITION` is returned.",
            " See also the `Snapshot.expire_time` field. If the name is not provided in",
            " the request, the server will assign a random",
            " name for this snapshot on the same project as the subscription, conforming",
            " to the [resource name format]",
            " (https://cloud.google.com/pubsub/docs/admin#resource_names). The",
            " generated name is populated in the returned Snapshot object. Note that for",
            " REST API requests, you must specify a name in the request.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "CreateSnapshot",
          "inputType": ".google.pubsub.v1.CreateSnapshotRequest",
          "outputType": ".google.pubsub.v1.Snapshot",
          "options": {
            ".google.api.methodSignature": [
              "name,subscription"
            ],
            ".google.api.http": {
              "put": "/v1/{name=projects/*/snapshots/*}",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "name",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. User-provided name for this snapshot. If the name is not provided",
                " in the request, the server will assign a random name for this snapshot on",
                " the same project as the subscription. Note that for REST API requests, you",
                " must specify a name.  See the <a",
                " href=\"https://cloud.google.com/pubsub/docs/admin#resource_names\"> resource",
                " name rules</a>. Format is `projects/{project}/snapshots/{snap}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The subscription whose backlog the snapshot retains.",
                " Specifically, the created snapshot is guaranteed to retain:",
                "  (a) The existing backlog on the subscription. More precisely, this is",
                "      defined as the messages in the subscription's backlog that are",
                "      unacknowledged upon the successful completion of the",
                "      `CreateSnapshot` request; as well as:",
                "  (b) Any messages published to the subscription's topic following the",
                "      successful completion of the CreateSnapshot request.",
                " Format is `projects/{project}/subscriptions/{sub}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "labels",
              "paramType": "TYPE_MESSAGE[]",
              "comments": [
                " See <a href=\"https://cloud.google.com/pubsub/docs/labels\"> Creating and",
                " managing labels</a>."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "name"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.UpdateSnapshotRequest",
          "outputInterface": ".google.pubsub.v1.Snapshot",
          "comments": [
            " Updates an existing snapshot. Snapshots are used in",
            " <a href=\"https://cloud.google.com/pubsub/docs/replay-overview\">Seek</a>",
            " operations, which allow",
            " you to manage message acknowledgments in bulk. That is, you can set the",
            " acknowledgment state of messages in an existing subscription to the state",
            " captured by a snapshot.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "UpdateSnapshot",
          "inputType": ".google.pubsub.v1.UpdateSnapshotRequest",
          "outputType": ".google.pubsub.v1.Snapshot",
          "options": {
            ".google.api.http": {
              "patch": "/v1/{snapshot.name=projects/*/snapshots/*}",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "snapshot",
              "paramType": ".google.pubsub.v1.Snapshot",
              "comments": [
                " Required. The updated snapshot object."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "update_mask",
              "paramType": ".google.protobuf.FieldMask",
              "comments": [
                " Required. Indicates which fields in the provided snapshot to update.",
                " Must be specified and non-empty."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "snapshot",
              "name"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.DeleteSnapshotRequest",
          "outputInterface": ".google.protobuf.Empty",
          "comments": [
            " Removes an existing snapshot. Snapshots are used in [Seek]",
            " (https://cloud.google.com/pubsub/docs/replay-overview) operations, which",
            " allow you to manage message acknowledgments in bulk. That is, you can set",
            " the acknowledgment state of messages in an existing subscription to the",
            " state captured by a snapshot.",
            " When the snapshot is deleted, all messages retained in the snapshot",
            " are immediately dropped. After a snapshot is deleted, a new one may be",
            " created with the same name, but the new one has no association with the old",
            " snapshot or its subscription, unless the same subscription is specified.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "DeleteSnapshot",
          "inputType": ".google.pubsub.v1.DeleteSnapshotRequest",
          "outputType": ".google.protobuf.Empty",
          "options": {
            ".google.api.methodSignature": [
              "snapshot"
            ],
            ".google.api.http": {
              "delete": "/v1/{snapshot=projects/*/snapshots/*}"
            }
          },
          "paramComment": [
            {
              "paramName": "snapshot",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the snapshot to delete.",
                " Format is `projects/{project}/snapshots/{snap}`."
              ],
              "fieldBehavior": 2
            }
          ],
          "headerRequestParams": [
            [
              "snapshot"
            ]
          ]
        },
        {
          "inputInterface": ".google.pubsub.v1.SeekRequest",
          "outputInterface": ".google.pubsub.v1.SeekResponse",
          "comments": [
            " Seeks an existing subscription to a point in time or to a given snapshot,",
            " whichever is provided in the request. Snapshots are used in [Seek]",
            " (https://cloud.google.com/pubsub/docs/replay-overview) operations, which",
            " allow you to manage message acknowledgments in bulk. That is, you can set",
            " the acknowledgment state of messages in an existing subscription to the",
            " state captured by a snapshot. Note that both the subscription and the",
            " snapshot must be on the same topic.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "Seek",
          "inputType": ".google.pubsub.v1.SeekRequest",
          "outputType": ".google.pubsub.v1.SeekResponse",
          "options": {
            ".google.api.http": {
              "post": "/v1/{subscription=projects/*/subscriptions/*}:seek",
              "body": "*"
            }
          },
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The subscription to affect."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "time",
              "paramType": ".google.protobuf.Timestamp",
              "comments": [
                " The time to seek to.",
                " Messages retained in the subscription that were published before this",
                " time are marked as acknowledged, and messages retained in the",
                " subscription that were published after this time are marked as",
                " unacknowledged. Note that this operation affects only those messages",
                " retained in the subscription (configured by the combination of",
                " `message_retention_duration` and `retain_acked_messages`). For example,",
                " if `time` corresponds to a point before the message retention",
                " window (or to a point before the system's notion of the subscription",
                " creation time), only retained messages will be marked as unacknowledged,",
                " and already-expunged messages will not be restored."
              ]
            },
            {
              "paramName": "snapshot",
              "paramType": "TYPE_STRING",
              "comments": [
                " The snapshot to seek to. The snapshot's topic must be the same as that of",
                " the provided subscription.",
                " Format is `projects/{project}/snapshots/{snap}`."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "subscription"
            ]
          ]
        }
      ],
      "longRunning": [],
      "diregapicLRO": [],
      "streaming": [
        {
          "streaming": "BIDI_STREAMING",
          "inputInterface": ".google.pubsub.v1.StreamingPullRequest",
          "outputInterface": ".google.pubsub.v1.StreamingPullResponse",
          "comments": [
            " Establishes a stream with the server, which sends messages down to the",
            " client. The client streams acknowledgements and ack deadline modifications",
            " back to the server. The server will close the stream and return the status",
            " on any error. The server may close the stream with status `UNAVAILABLE` to",
            " reassign server-side resources, in which case, the client should",
            " re-establish the stream. Flow control can be achieved by configuring the",
            " underlying RPC channel.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "StreamingPull",
          "inputType": ".google.pubsub.v1.StreamingPullRequest",
          "outputType": ".google.pubsub.v1.StreamingPullResponse",
          "options": {},
          "clientStreaming": true,
          "serverStreaming": true,
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The subscription for which to initialize the new stream. This",
                " must be provided in the first request on the stream, and must not be set in",
                " subsequent requests from client to server.",
                " Format is `projects/{project}/subscriptions/{sub}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "ack_ids",
              "paramType": "TYPE_STRING[]",
              "comments": [
                " List of acknowledgement IDs for acknowledging previously received messages",
                " (received on this stream or a different stream). If an ack ID has expired,",
                " the corresponding message may be redelivered later. Acknowledging a message",
                " more than once will not result in an error. If the acknowledgement ID is",
                " malformed, the stream will be aborted with status `INVALID_ARGUMENT`."
              ]
            },
            {
              "paramName": "modify_deadline_seconds",
              "paramType": "TYPE_INT32[]",
              "comments": [
                " The list of new ack deadlines for the IDs listed in",
                " `modify_deadline_ack_ids`. The size of this list must be the same as the",
                " size of `modify_deadline_ack_ids`. If it differs the stream will be aborted",
                " with `INVALID_ARGUMENT`. Each element in this list is applied to the",
                " element in the same position in `modify_deadline_ack_ids`. The new ack",
                " deadline is with respect to the time this request was sent to the Pub/Sub",
                " system. Must be >= 0. For example, if the value is 10, the new ack deadline",
                " will expire 10 seconds after this request is received. If the value is 0,",
                " the message is immediately made available for another streaming or",
                " non-streaming pull request. If the value is < 0 (an error), the stream will",
                " be aborted with status `INVALID_ARGUMENT`."
              ]
            },
            {
              "paramName": "modify_deadline_ack_ids",
              "paramType": "TYPE_STRING[]",
              "comments": [
                " List of acknowledgement IDs whose deadline will be modified based on the",
                " corresponding element in `modify_deadline_seconds`. This field can be used",
                " to indicate that more time is needed to process a message by the",
                " subscriber, or to make the message available for redelivery if the",
                " processing was interrupted."
              ]
            },
            {
              "paramName": "stream_ack_deadline_seconds",
              "paramType": "TYPE_INT32",
              "comments": [
                " Required. The ack deadline to use for the stream. This must be provided in",
                " the first request on the stream, but it can also be updated on subsequent",
                " requests from client to server. The minimum deadline you can specify is 10",
                " seconds. The maximum deadline you can specify is 600 seconds (10 minutes)."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "client_id",
              "paramType": "TYPE_STRING",
              "comments": [
                " A unique identifier that is used to distinguish client instances from each",
                " other. Only needs to be provided on the initial request. When a stream",
                " disconnects and reconnects for the same stream, the client_id should be set",
                " to the same value so that state associated with the old stream can be",
                " transferred to the new stream. The same client_id should not be used for",
                " different client instances."
              ]
            },
            {
              "paramName": "max_outstanding_messages",
              "paramType": "TYPE_INT64",
              "comments": [
                " Flow control settings for the maximum number of outstanding messages. When",
                " there are `max_outstanding_messages` or more currently sent to the",
                " streaming pull client that have not yet been acked or nacked, the server",
                " stops sending more messages. The sending of messages resumes once the",
                " number of outstanding messages is less than this value. If the value is",
                " <= 0, there is no limit to the number of outstanding messages. This",
                " property can only be set on the initial StreamingPullRequest. If it is set",
                " on a subsequent request, the stream will be aborted with status",
                " `INVALID_ARGUMENT`."
              ]
            },
            {
              "paramName": "max_outstanding_bytes",
              "paramType": "TYPE_INT64",
              "comments": [
                " Flow control settings for the maximum number of outstanding bytes. When",
                " there are `max_outstanding_bytes` or more worth of messages currently sent",
                " to the streaming pull client that have not yet been acked or nacked, the",
                " server will stop sending more messages. The sending of messages resumes",
                " once the number of outstanding bytes is less than this value. If the value",
                " is <= 0, there is no limit to the number of outstanding bytes. This",
                " property can only be set on the initial StreamingPullRequest. If it is set",
                " on a subsequent request, the stream will be aborted with status",
                " `INVALID_ARGUMENT`."
              ]
            }
          ],
          "headerRequestParams": []
        }
      ],
      "clientStreaming": [],
      "serverStreaming": [],
      "bidiStreaming": [
        {
          "streaming": "BIDI_STREAMING",
          "inputInterface": ".google.pubsub.v1.StreamingPullRequest",
          "outputInterface": ".google.pubsub.v1.StreamingPullResponse",
          "comments": [
            " Establishes a stream with the server, which sends messages down to the",
            " client. The client streams acknowledgements and ack deadline modifications",
            " back to the server. The server will close the stream and return the status",
            " on any error. The server may close the stream with status `UNAVAILABLE` to",
            " reassign server-side resources, in which case, the client should",
            " re-establish the stream. Flow control can be achieved by configuring the",
            " underlying RPC channel.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "StreamingPull",
          "inputType": ".google.pubsub.v1.StreamingPullRequest",
          "outputType": ".google.pubsub.v1.StreamingPullResponse",
          "options": {},
          "clientStreaming": true,
          "serverStreaming": true,
          "paramComment": [
            {
              "paramName": "subscription",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The subscription for which to initialize the new stream. This",
                " must be provided in the first request on the stream, and must not be set in",
                " subsequent requests from client to server.",
                " Format is `projects/{project}/subscriptions/{sub}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "ack_ids",
              "paramType": "TYPE_STRING[]",
              "comments": [
                " List of acknowledgement IDs for acknowledging previously received messages",
                " (received on this stream or a different stream). If an ack ID has expired,",
                " the corresponding message may be redelivered later. Acknowledging a message",
                " more than once will not result in an error. If the acknowledgement ID is",
                " malformed, the stream will be aborted with status `INVALID_ARGUMENT`."
              ]
            },
            {
              "paramName": "modify_deadline_seconds",
              "paramType": "TYPE_INT32[]",
              "comments": [
                " The list of new ack deadlines for the IDs listed in",
                " `modify_deadline_ack_ids`. The size of this list must be the same as the",
                " size of `modify_deadline_ack_ids`. If it differs the stream will be aborted",
                " with `INVALID_ARGUMENT`. Each element in this list is applied to the",
                " element in the same position in `modify_deadline_ack_ids`. The new ack",
                " deadline is with respect to the time this request was sent to the Pub/Sub",
                " system. Must be >= 0. For example, if the value is 10, the new ack deadline",
                " will expire 10 seconds after this request is received. If the value is 0,",
                " the message is immediately made available for another streaming or",
                " non-streaming pull request. If the value is < 0 (an error), the stream will",
                " be aborted with status `INVALID_ARGUMENT`."
              ]
            },
            {
              "paramName": "modify_deadline_ack_ids",
              "paramType": "TYPE_STRING[]",
              "comments": [
                " List of acknowledgement IDs whose deadline will be modified based on the",
                " corresponding element in `modify_deadline_seconds`. This field can be used",
                " to indicate that more time is needed to process a message by the",
                " subscriber, or to make the message available for redelivery if the",
                " processing was interrupted."
              ]
            },
            {
              "paramName": "stream_ack_deadline_seconds",
              "paramType": "TYPE_INT32",
              "comments": [
                " Required. The ack deadline to use for the stream. This must be provided in",
                " the first request on the stream, but it can also be updated on subsequent",
                " requests from client to server. The minimum deadline you can specify is 10",
                " seconds. The maximum deadline you can specify is 600 seconds (10 minutes)."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "client_id",
              "paramType": "TYPE_STRING",
              "comments": [
                " A unique identifier that is used to distinguish client instances from each",
                " other. Only needs to be provided on the initial request. When a stream",
                " disconnects and reconnects for the same stream, the client_id should be set",
                " to the same value so that state associated with the old stream can be",
                " transferred to the new stream. The same client_id should not be used for",
                " different client instances."
              ]
            },
            {
              "paramName": "max_outstanding_messages",
              "paramType": "TYPE_INT64",
              "comments": [
                " Flow control settings for the maximum number of outstanding messages. When",
                " there are `max_outstanding_messages` or more currently sent to the",
                " streaming pull client that have not yet been acked or nacked, the server",
                " stops sending more messages. The sending of messages resumes once the",
                " number of outstanding messages is less than this value. If the value is",
                " <= 0, there is no limit to the number of outstanding messages. This",
                " property can only be set on the initial StreamingPullRequest. If it is set",
                " on a subsequent request, the stream will be aborted with status",
                " `INVALID_ARGUMENT`."
              ]
            },
            {
              "paramName": "max_outstanding_bytes",
              "paramType": "TYPE_INT64",
              "comments": [
                " Flow control settings for the maximum number of outstanding bytes. When",
                " there are `max_outstanding_bytes` or more worth of messages currently sent",
                " to the streaming pull client that have not yet been acked or nacked, the",
                " server will stop sending more messages. The sending of messages resumes",
                " once the number of outstanding bytes is less than this value. If the value",
                " is <= 0, there is no limit to the number of outstanding bytes. This",
                " property can only be set on the initial StreamingPullRequest. If it is set",
                " on a subsequent request, the stream will be aborted with status",
                " `INVALID_ARGUMENT`."
              ]
            }
          ],
          "headerRequestParams": []
        }
      ],
      "paging": [
        {
          "pagingFieldName": "subscriptions",
          "pagingResponseType": ".google.pubsub.v1.Subscription",
          "ignoreMapPagingMethod": false,
          "inputInterface": ".google.pubsub.v1.ListSubscriptionsRequest",
          "outputInterface": ".google.pubsub.v1.ListSubscriptionsResponse",
          "comments": [
            " Lists matching subscriptions.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ListSubscriptions",
          "inputType": ".google.pubsub.v1.ListSubscriptionsRequest",
          "outputType": ".google.pubsub.v1.ListSubscriptionsResponse",
          "options": {
            ".google.api.methodSignature": [
              "project"
            ],
            ".google.api.http": {
              "get": "/v1/{project=projects/*}/subscriptions"
            }
          },
          "paramComment": [
            {
              "paramName": "project",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the project in which to list subscriptions.",
                " Format is `projects/{project-id}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "page_size",
              "paramType": "TYPE_INT32",
              "comments": [
                " Maximum number of subscriptions to return."
              ]
            },
            {
              "paramName": "page_token",
              "paramType": "TYPE_STRING",
              "comments": [
                " The value returned by the last `ListSubscriptionsResponse`; indicates that",
                " this is a continuation of a prior `ListSubscriptions` call, and that the",
                " system should return the next page of data."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "project"
            ]
          ]
        },
        {
          "pagingFieldName": "snapshots",
          "pagingResponseType": ".google.pubsub.v1.Snapshot",
          "ignoreMapPagingMethod": false,
          "inputInterface": ".google.pubsub.v1.ListSnapshotsRequest",
          "outputInterface": ".google.pubsub.v1.ListSnapshotsResponse",
          "comments": [
            " Lists the existing snapshots. Snapshots are used in [Seek](",
            " https://cloud.google.com/pubsub/docs/replay-overview) operations, which",
            " allow you to manage message acknowledgments in bulk. That is, you can set",
            " the acknowledgment state of messages in an existing subscription to the",
            " state captured by a snapshot.",
            ""
          ],
          "methodConfig": {},
          "retryableCodesName": "non_idempotent",
          "retryParamsName": "default",
          "name": "ListSnapshots",
          "inputType": ".google.pubsub.v1.ListSnapshotsRequest",
          "outputType": ".google.pubsub.v1.ListSnapshotsResponse",
          "options": {
            ".google.api.methodSignature": [
              "project"
            ],
            ".google.api.http": {
              "get": "/v1/{project=projects/*}/snapshots"
            }
          },
          "paramComment": [
            {
              "paramName": "project",
              "paramType": "TYPE_STRING",
              "comments": [
                " Required. The name of the project in which to list snapshots.",
                " Format is `projects/{project-id}`."
              ],
              "fieldBehavior": 2
            },
            {
              "paramName": "page_size",
              "paramType": "TYPE_INT32",
              "comments": [
                " Maximum number of snapshots to return."
              ]
            },
            {
              "paramName": "page_token",
              "paramType": "TYPE_STRING",
              "comments": [
                " The value returned by the last `ListSnapshotsResponse`; indicates that this",
                " is a continuation of a prior `ListSnapshots` call, and that the system",
                " should return the next page of data."
              ]
            }
          ],
          "headerRequestParams": [
            [
              "project"
            ]
          ]
        }
      ],
      "hostname": "",
      "port": 0,
      "oauthScopes": [
        "https://www.googleapis.com/auth/cloud-platform",
        "https://www.googleapis.com/auth/pubsub"
      ],
      "pathTemplates": [
        {
          "name": "Project",
          "params": [
            "project"
          ],
          "pattern": [
            "projects/{project}"
          ],
          "style": [],
          "type": "cloudresourcemanager.googleapis.com/Project"
        },
        {
          "name": "project_topic",
          "params": [
            "project",
            "topic"
          ],
          "pattern": [
            "projects/{project}/topics/{topic}"
          ],
          "type": "pubsub.googleapis.com/Topic"
        },
        {
          "name": "Schema",
          "params": [
            "project",
            "schema"
          ],
          "pattern": [
            "projects/{project}/schemas/{schema}"
          ],
          "style": [],
          "type": "pubsub.googleapis.com/Schema"
        },
        {
          "name": "Snapshot",
          "params": [
            "project",
            "snapshot"
          ],
          "pattern": [
            "projects/{project}/snapshots/{snapshot}"
          ],
          "style": [],
          "type": "pubsub.googleapis.com/Snapshot"
        },
        {
          "name": "Subscription",
          "params": [
            "project",
            "subscription"
          ],
          "pattern": [
            "projects/{project}/subscriptions/{subscription}"
          ],
          "style": [],
          "type": "pubsub.googleapis.com/Subscription"
        }
      ]
    }
  ],
  "diregapic": false,
  "handwrittenLayer": false,
  "legacyProtoLoad": false
}
