// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **



'use strict';

function main(destinationName, destinationBucket, sourceBucket, sourceObject) {
  // [START storage_v2_generated_Storage_RewriteObject_async]
  /**
   * This snippet has been automatically generated and should be regarded as a code template only.
   * It will require modifications to work.
   * It may require correct/in-range values for request initialization.
   * TODO(developer): Uncomment these variables before running the sample.
   */
  /**
   *  Required. Immutable. The name of the destination object.
   *  See the
   *  Naming Guidelines (https://cloud.google.com/storage/docs/objects#naming).
   *  Example: `test.txt`
   *  The `name` field by itself does not uniquely identify a Cloud Storage
   *  object. A Cloud Storage object is uniquely identified by the tuple of
   *  (bucket, object, generation).
   */
  // const destinationName = 'abc123'
  /**
   *  Required. Immutable. The name of the bucket containing the destination
   *  object.
   */
  // const destinationBucket = 'abc123'
  /**
   *  The name of the Cloud KMS key that will be used to encrypt the destination
   *  object. The Cloud KMS key must be located in same location as the object.
   *  If the parameter is not specified, the request uses the destination
   *  bucket's default encryption key, if any, or else the Google-managed
   *  encryption key.
   */
  // const destinationKmsKey = 'abc123'
  /**
   *  Properties of the destination, post-rewrite object.
   *  The `name`, `bucket` and `kms_key` fields must not be populated (these
   *  values are specified in the `destination_name`, `destination_bucket`, and
   *  `destination_kms_key` fields).
   *  If `destination` is present it will be used to construct the destination
   *  object's metadata; otherwise the destination object's metadata will be
   *  copied from the source object.
   */
  // const destination = {}
  /**
   *  Required. Name of the bucket in which to find the source object.
   */
  // const sourceBucket = 'abc123'
  /**
   *  Required. Name of the source object.
   */
  // const sourceObject = 'abc123'
  /**
   *  If present, selects a specific revision of the source object (as opposed to
   *  the latest version, the default).
   */
  // const sourceGeneration = 1234
  /**
   *  Include this field (from the previous rewrite response) on each rewrite
   *  request after the first one, until the rewrite response 'done' flag is
   *  true. Calls that provide a rewriteToken can omit all other request fields,
   *  but if included those fields must match the values provided in the first
   *  rewrite request.
   */
  // const rewriteToken = 'abc123'
  /**
   *  Apply a predefined set of access controls to the destination object.
   *  Valid values are "authenticatedRead", "bucketOwnerFullControl",
   *  "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
   */
  // const destinationPredefinedAcl = 'abc123'
  /**
   *  Makes the operation conditional on whether the object's current generation
   *  matches the given value. Setting to 0 makes the operation succeed only if
   *  there are no live versions of the object.
   */
  // const ifGenerationMatch = 1234
  /**
   *  Makes the operation conditional on whether the object's live generation
   *  does not match the given value. If no live object exists, the precondition
   *  fails. Setting to 0 makes the operation succeed only if there is a live
   *  version of the object.
   */
  // const ifGenerationNotMatch = 1234
  /**
   *  Makes the operation conditional on whether the destination object's current
   *  metageneration matches the given value.
   */
  // const ifMetagenerationMatch = 1234
  /**
   *  Makes the operation conditional on whether the destination object's current
   *  metageneration does not match the given value.
   */
  // const ifMetagenerationNotMatch = 1234
  /**
   *  Makes the operation conditional on whether the source object's live
   *  generation matches the given value.
   */
  // const ifSourceGenerationMatch = 1234
  /**
   *  Makes the operation conditional on whether the source object's live
   *  generation does not match the given value.
   */
  // const ifSourceGenerationNotMatch = 1234
  /**
   *  Makes the operation conditional on whether the source object's current
   *  metageneration matches the given value.
   */
  // const ifSourceMetagenerationMatch = 1234
  /**
   *  Makes the operation conditional on whether the source object's current
   *  metageneration does not match the given value.
   */
  // const ifSourceMetagenerationNotMatch = 1234
  /**
   *  The maximum number of bytes that will be rewritten per rewrite request.
   *  Most callers
   *  shouldn't need to specify this parameter - it is primarily in place to
   *  support testing. If specified the value must be an integral multiple of
   *  1 MiB (1048576). Also, this only applies to requests where the source and
   *  destination span locations and/or storage classes. Finally, this value must
   *  not change across rewrite calls else you'll get an error that the
   *  `rewriteToken` is invalid.
   */
  // const maxBytesRewrittenPerCall = 1234
  /**
   *  The algorithm used to encrypt the source object, if any. Used if the source
   *  object was encrypted with a Customer-Supplied Encryption Key.
   */
  // const copySourceEncryptionAlgorithm = 'abc123'
  /**
   *  The raw bytes (not base64-encoded) AES-256 encryption key used to encrypt
   *  the source object, if it was encrypted with a Customer-Supplied Encryption
   *  Key.
   */
  // const copySourceEncryptionKeyBytes = Buffer.from('string')
  /**
   *  The raw bytes (not base64-encoded) SHA256 hash of the encryption key used
   *  to encrypt the source object, if it was encrypted with a Customer-Supplied
   *  Encryption Key.
   */
  // const copySourceEncryptionKeySha256Bytes = Buffer.from('string')
  /**
   *  A set of parameters common to Storage API requests concerning an object.
   */
  // const commonObjectRequestParams = {}
  /**
   *  The checksums of the complete object. This will be used to validate the
   *  destination object after rewriting.
   */
  // const objectChecksums = {}

  // Imports the Storage library
  const {StorageClient} = require('storage').v2;

  // Instantiates a client
  const storageClient = new StorageClient();

  async function callRewriteObject() {
    // Construct request
    const request = {
      destinationName,
      destinationBucket,
      sourceBucket,
      sourceObject,
    };

    // Run request
    const response = await storageClient.rewriteObject(request);
    console.log(response);
  }

  callRewriteObject();
  // [END storage_v2_generated_Storage_RewriteObject_async]
}

process.on('unhandledRejection', err => {
  console.error(err.message);
  process.exitCode = 1;
});
main(...process.argv.slice(2));
