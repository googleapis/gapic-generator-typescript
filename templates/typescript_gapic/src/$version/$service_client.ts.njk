{#-

Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

-#}
{% import "../../_license.njk" as license -%}
{{license.license(commonParameters.copyrightYear)}}
{%- if not api.legacyProtoLoad %}
/* global window */
{%- endif %}
{% import "../../_util.njk" as util -%}
{% import "../../_iam.njk" as iam -%}
{% import "../../_locations.njk" as location -%}
{% import "../../_operations.njk" as operations -%}
{% import "../../_namer.njk" as namer -%}
{{- namer.initialize(id, service) -}}
import * as gax from 'google-gax';
import {Callback, CallOptions, Descriptors, ClientOptions
{%- if service.longRunning.length > 0 or service.diregapicLRO.length > 0 %}, LROperation{%- endif -%}
{%- if service.paging.length > 0 %}, PaginationCallback, GaxCall{%- endif -%}
{%- if service.streaming.length > 0 %}, GoogleError{%- endif -%}
{%- if service.IAMPolicyMixin > 0 %}, IamClient, IamProtos{%- endif -%}
{%- if service.LocationMixin > 0 %}, LocationsClient, LocationProtos{%- endif -%}
} from 'google-gax';
{% if service.paging.length > 0 %}
import { Transform } from 'stream';
import { RequestType } from 'google-gax/build/src/apitypes';
{%- endif %}
{%- if service.streaming.length > 0 %}
import { PassThrough } from 'stream';
{%- endif %}
import * as protos from '../../protos/protos';
{%- if api.legacyProtoLoad %}
import * as path from 'path';
{%- else %}
import jsonProtos = require('../../protos/protos.json');
{%- endif %}
/**
 * Client JSON configuration object, loaded from
 * `src/{{ api.naming.version }}/{{ service.name.toSnakeCase() }}_client_config.json`.
 * This file defines retry strategy and timeouts for all API methods in this library.
 */
import * as gapicConfig from './{{ service.name.toSnakeCase() }}_client_config.json';
{% if service.longRunning.length > 0 or service.LongRunningOperationsMixin > 0 -%}
import { operationsProtos } from 'google-gax';
{%- endif %}
const version = require('../../../package.json').version;

/**
{{- util.printCommentsForService(service) }}
 * @class
 * @memberof {{ api.naming.version }}
 {%- if service.options and service.options.deprecated %}
 * @deprecated {{service.name}} is deprecated and may be removed in a future version.
 {%- endif %}
 */
export class {{ service.name }}Client {
  private _terminated = false;
  private _opts: ClientOptions;
  private _providedCustomServicePath: boolean;
  private _gaxModule: typeof gax{% if not api.legacyProtoLoad %} | typeof gax.fallback{% endif %};
  private _gaxGrpc: gax.GrpcClient{% if not api.legacyProtoLoad %} | gax.fallback.GrpcClient{% endif %};
  private _protos: {};
  private _defaults: {[method: string]: gax.CallSettings};
  auth: gax.GoogleAuth;
  descriptors: Descriptors = {
    page: {},
    stream: {},
    longrunning: {},
    batching: {},
  };
  warn: (code: string, message: string, warnType?: string) => void;
  innerApiCalls: {[name: string]: Function};
  {%- if service.IAMPolicyMixin > 0 %}
  iamClient: IamClient;
  {%- endif %}
  {%- if service.LocationMixin > 0 %}
  locationsClient: LocationsClient;
  {%- endif -%}
  {%- if service.pathTemplates.length > 0 %}
  pathTemplates: {[name: string]: gax.PathTemplate};
  {%- endif %}
{%- if service.longRunning.length > 0 or service.LongRunningOperationsMixin > 0 %}
  operationsClient: gax.OperationsClient;
{%- endif %}
  {{ service.name.toCamelCase() }}Stub?: Promise<{[name: string]: Function}>;

  /**
   * Construct an instance of {{ service.name }}Client.
   *
   * @param {object} [options] - The configuration object.
   * The options accepted by the constructor are described in detail
   * in [this document](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#creating-the-client-instance).
   * The common options are:
   * @param {object} [options.credentials] - Credentials object.
   * @param {string} [options.credentials.client_email]
   * @param {string} [options.credentials.private_key]
   * @param {string} [options.email] - Account email address. Required when
   *     using a .pem or .p12 keyFilename.
   * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or
   *     .p12 key downloaded from the Google Developers Console. If you provide
   *     a path to a JSON file, the projectId option below is not necessary.
   *     NOTE: .pem and .p12 require you to specify options.email as well.
   * @param {number} [options.port] - The port on which to connect to
   *     the remote host.
   * @param {string} [options.projectId] - The project ID from the Google
   *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check
   *     the environment variable GCLOUD_PROJECT for your project ID. If your
   *     app is running in an environment which supports
   *     {@link https://developers.google.com/identity/protocols/application-default-credentials Application Default Credentials},
   *     your project ID will be detected automatically.
   * @param {string} [options.apiEndpoint] - The domain name of the
   *     API remote host.
   * @param {gax.ClientConfig} [options.clientConfig] - Client configuration override.
   *     Follows the structure of {@link gapicConfig}.
{%- if not api.legacyProtoLoad %}
   * @param {boolean} [options.fallback] - Use HTTP fallback mode.
   *     In fallback mode, a special browser-compatible transport implementation is used
   *     instead of gRPC transport. In browser context (if the `window` object is defined)
   *     the fallback mode is enabled automatically; set `options.fallback` to `false`
   *     if you need to override this behavior.
{%- endif %}
   */
  constructor(opts?: ClientOptions) {
    // Ensure that options include all the required fields.
    const staticMembers = this.constructor as typeof {{ service.name }}Client;
    const servicePath = opts?.servicePath || opts?.apiEndpoint || staticMembers.{{ id.get("servicePath") }};
    this._providedCustomServicePath = !!(opts?.servicePath || opts?.apiEndpoint);
    const port = opts?.port || staticMembers.{{ id.get("port") }};
    const clientConfig = opts?.clientConfig ?? {};
    {%- if api.rest %}
    // Implicitely set 'rest' value for the apis use rest as transport (eg. googleapis-discovery apis).
    if (!opts) {
      opts = {fallback: 'rest'};
    } else {
      opts.fallback = opts.fallback ?? 'rest';
    }
    {%- endif %}
    {%- if api.legacyProtoLoad %}
    opts = Object.assign({servicePath, port, clientConfig}, opts);
    {%- else %}
    const fallback = opts?.fallback ?? (typeof window !== 'undefined' && typeof window?.fetch === 'function');
    opts = Object.assign({servicePath, port, clientConfig, fallback}, opts);
    {%- endif %}

    // If scopes are unset in options and we're connecting to a non-default endpoint, set scopes just in case.
    if (servicePath !== staticMembers.{{ id.get("servicePath") }} && !('scopes' in opts)) {
      opts['scopes'] = staticMembers.{{ id.get("scopes") }};
    }

    // Choose either gRPC or proto-over-HTTP implementation of google-gax.
    this._gaxModule = {% if not api.legacyProtoLoad %}opts.fallback ? gax.fallback : {% endif %}gax;

    // Create a `gaxGrpc` object, with any grpc-specific options sent to the client.
    this._gaxGrpc = new this._gaxModule.GrpcClient(opts);

    // Save options to use in {{ id.get("initialize") }}() method.
    this._opts = opts;

    // Save the auth object to the client, for use by other methods.
    this.auth = (this._gaxGrpc.auth as gax.GoogleAuth);

{%- if not api.diregapic %}

    // Set useJWTAccessWithScope on the auth object.
    this.auth.useJWTAccessWithScope = true;
{%- endif %}

    // Set defaultServicePath on the auth object.
    this.auth.defaultServicePath = staticMembers.{{ id.get("servicePath") }};

    // Set the default scopes in auth client if needed.
    if (servicePath === staticMembers.{{ id.get("servicePath") }}) {
      this.auth.defaultScopes = staticMembers.{{ id.get("scopes") }};
    }
  {%- if service.IAMPolicyMixin > 0 %}
    this.iamClient = new IamClient(this._gaxGrpc, opts);
  {% endif %}

  {%- if service.LocationMixin > 0 %}
    this.locationsClient = new LocationsClient(this._gaxGrpc, opts);
  {% endif %}

    // Determine the client header string.
    const clientHeader = [
      `gax/${this._gaxModule.version}`,
      `gapic/${version}`,
    ];
    if (typeof process !== 'undefined' && 'versions' in process) {
      clientHeader.push(`gl-node/${process.versions.node}`);
    } else {
      clientHeader.push(`gl-web/${this._gaxModule.version}`);
    }
{%- if api.legacyProtoLoad %}
    clientHeader.push(`grpc/${this._gaxGrpc.grpcVersion}`);
{%- else %}
    if (!opts.fallback) {
      clientHeader.push(`grpc/${this._gaxGrpc.grpcVersion}`);
    } else if (opts.fallback === 'rest' ) {
      clientHeader.push(`rest/${this._gaxGrpc.grpcVersion}`);
    }
{%- endif %}
    if (opts.libName && opts.libVersion) {
      clientHeader.push(`${opts.libName}/${opts.libVersion}`);
    }
    // Load the applicable protos.
{%- if api.legacyProtoLoad %}
    this._protos = this._gaxGrpc.loadProto(
      path.join(__dirname, '..', '..', 'protos'),
      '{{ service.protoFile }}'
    );
{%- else %}
    this._protos = this._gaxGrpc.loadProtoJSON(jsonProtos);
{%- endif %}

{%- if service.pathTemplates.length > 0 %}

    // This API contains "path templates"; forward-slash-separated
    // identifiers to uniquely identify resources within the API.
    // Create useful helper objects for these.
    this.pathTemplates = {
{%- for template in service.pathTemplates %}
      {{ template.name.toCamelCase() }}PathTemplate: new this._gaxModule.PathTemplate(
        '{{ template.pattern }}'
      ),
{%- endfor %}
    };
{%- endif %}

{%- if service.paging.length > 0 %}

    // Some of the methods on this service return "paged" results,
    // (e.g. 50 results at a time, with tokens to get subsequent
    // pages). Denote the keys used for pagination and results.
    this.descriptors.page = {
{%- set pagingJoiner = joiner() %}
{%- for method in service.paging %}
      {%- if not method.ignoreMapPagingMethod %}
      {{- pagingJoiner() }}
      {{ method.name.toCamelCase() }}:
          new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', '{{ method.pagingFieldName.toCamelCase() }}')
      {%- endif %}
{%- endfor %}
    };
{%- endif %}

{%- if service.streaming.length > 0 %}

    // Some of the methods on this service provide streaming responses.
    // Provide descriptors for these.
    this.descriptors.stream = {
{%- set streamingJoiner = joiner() %}
{%- for method in service.streaming %}
      {{- streamingJoiner() }}
      {{ method.name.toCamelCase() }}: new this._gaxModule.StreamDescriptor(gax.StreamType.{{ method.streaming }}, opts.fallback === 'rest')
{%- endfor %}
    };
{%- endif %}
{%- if (service.longRunning.length > 0) or (service.bundleConfigs.length > 0) %}
{%- if api.legacyProtoLoad %}

    let protoFilesRoot = new this._gaxModule.GoogleProtoFilesRoot();
    protoFilesRoot = this._gaxModule.protobuf.loadSync(
      path.join(__dirname, '..', '..', 'protos', '{{ service.protoFile }}'),
      protoFilesRoot) as (typeof protoFilesRoot);
{%- else %}

    const protoFilesRoot = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
{%- endif %}
{% endif %}
{%- if service.longRunning.length > 0 or service.LongRunningOperationsMixin > 0%}
    // This API contains "long-running operations", which return a
    // an Operation object that allows for tracking of the operation,
    // rather than holding a request open.

    this.operationsClient = this._gaxModule.lro({
      auth: this.auth,
      grpc: 'grpc' in this._gaxGrpc ? this._gaxGrpc.grpc : undefined
    }).operationsClient(opts);

{%- for method in service.longRunning %}
    const {{ method.name.toCamelCase() }}Response = protoFilesRoot.lookup(
      '{{ method.longRunningResponseType }}') as gax.protobuf.Type;
    const {{ method.name.toCamelCase() }}Metadata = protoFilesRoot.lookup(
      '{{ method.longRunningMetadataType }}') as gax.protobuf.Type;
{%- endfor %}

    this.descriptors.longrunning = {
{%- set longRunningJoiner = joiner() %}
{%- for method in service.longRunning %}
      {{- longRunningJoiner() }}
      {{ method.name.toCamelCase() }}: new this._gaxModule.LongrunningDescriptor(
        this.operationsClient,
        {{ method.name.toCamelCase() }}Response.decode.bind({{ method.name.toCamelCase() }}Response),
        {{ method.name.toCamelCase() }}Metadata.decode.bind({{ method.name.toCamelCase() }}Metadata))
{%- endfor %}
    };
{%- endif %}

{%- if service.bundleConfigs.length > 0 %}
    // Some methods on this API support automatically batching
    // requests; denote this.

    this.descriptors.batching = {
{%- for method in service.bundleConfigsMethods %}
      {{ method.name.toCamelCase() }}: new this._gaxModule.BundleDescriptor(
        '{{ method.bundleConfig.batchDescriptor.batched_field }}',
        [
{%- set pagingJoiner = joiner() -%}
{%- for field in method.bundleConfig.batchDescriptor.discriminator_fields -%}
        {{- pagingJoiner() -}}
        '{{ field }}'
{%- endfor -%}
        ],
{%- if method.bundleConfig.batchDescriptor.subresponse_field === 'null' %}
        null,
{%- else %}
        '{{- method.bundleConfig.batchDescriptor.subresponse_field }}',
{%- endif %}
        gax.createByteLengthFunction(
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          protoFilesRoot.lookupType('{{ method.bundleConfig.repeatedField }}') as any
        )
      ),
    };
{%- endfor %}
{%- endif %}

    // Put together the default options sent with requests.
    this._defaults = this._gaxGrpc.constructSettings(
        '{{ api.naming.protoPackage }}.{{ service.name }}', gapicConfig as gax.ClientConfig,
        opts.clientConfig || {}, {'x-goog-api-client': clientHeader.join(' ')});

    // Set up a dictionary of "inner API calls"; the core implementation
    // of calling the API is handled in `google-gax`, with this code
    // merely providing the destination and request information.
    this.innerApiCalls = {};

    // Add a warn function to the client constructor so it can be easily tested.
    this.warn = gax.warn;
  }

  /**
   * Initialize the client.
   * Performs asynchronous operations (such as authentication) and prepares the client.
   * This function will be called automatically when any class method is called for the
   * first time, but if you need to initialize it before calling an actual method,
   * feel free to call {{ id.get("initialize") }}() directly.
   *
   * You can await on this method if you want to make sure the client is initialized.
   *
   * @returns {Promise} A promise that resolves to an authenticated service stub.
   */
  {{ id.get("initialize") }}() {
    // If the client stub promise is already initialized, return immediately.
    if (this.{{ service.name.toCamelCase() }}Stub) {
      {%- if service.options and service.options.deprecated %}
      this.warn('DEP${{service.name}}', '{{service.name}} is deprecated and may be removed in a future version.', 'DeprecationWarning');
      {%- endif %}
      return this.{{ service.name.toCamelCase() }}Stub;
    }

    // Put together the "service stub" for
    // {{api.naming.protoPackage}}.{{ service.name }}.
    this.{{ service.name.toCamelCase() }}Stub = this._gaxGrpc.createStub(
{%- if not api.legacyProtoLoad %}
        this._opts.fallback ?
          (this._protos as protobuf.Root).lookupService('{{api.naming.protoPackage}}.{{ service.name }}') :
{%- endif %}
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (this._protos as any).{{api.naming.protoPackage}}.{{ service.name }},
        this._opts, this._providedCustomServicePath) as Promise<{[method: string]: Function}>;

    // Iterate over each of the methods that the service provides
    // and create an API call method for each.
    const {{ service.name.toCamelCase() }}StubMethods =
        [
{%- set stubMethodsJoiner = joiner(', ') -%}
{%- for method in service.method -%}
      {%- if not method.ignoreMapPagingMethod %}
      {{- stubMethodsJoiner() -}}
      '{{ method.name.toCamelCase() }}'
      {%- endif %}
{%- endfor -%}
    ];
    for (const methodName of {{ service.name.toCamelCase() }}StubMethods) {
      const callPromise = this.{{ service.name.toCamelCase() }}Stub.then(
        stub => (...args: Array<{}>) => {
          if (this._terminated) {
            {%- if service.streaming.length > 0 %}
            if (methodName in this.descriptors.stream) {
              const stream = new PassThrough();
              setImmediate(() => {
                stream.emit('error', new GoogleError('The client has already been closed.'));
              });
              return stream;
            }
            {%- endif %}
            return Promise.reject('The client has already been closed.');
          }
          const func = stub[methodName];
          return func.apply(stub, args);
        },
        (err: Error|null|undefined) => () => {
          throw err;
        });

      const descriptor =
{%- if service.paging.length > 0 %}
        this.descriptors.page[methodName] ||
{%- endif %}
{%- if service.streaming.length > 0 %}
        this.descriptors.stream[methodName] ||
{%- endif %}
{%- if service.longRunning.length > 0 %}
        this.descriptors.longrunning[methodName] ||
{%- endif %}
{%- if service.bundleConfigs.length > 0 %}
        this.descriptors.batching?.[methodName] ||
{%- endif %}
        undefined;
      const apiCall = this._gaxModule.createApiCall(
        callPromise,
        this._defaults[methodName],
        descriptor
      );

      this.innerApiCalls[methodName] = apiCall;
    }
    {%- if service.options and service.options.deprecated %}
    this.warn('DEP${{service.name}}', '{{service.name}} is deprecated and may be removed in a future version.', 'DeprecationWarning');
    {%- endif %}

    return this.{{ service.name.toCamelCase() }}Stub;
  }

  /**
   * The DNS address for this API service.
   * @returns {string} The DNS address for this service.
   */
  static get {{ id.get("servicePath") }}() {
    return '{{ api.hostName }}';
  }

  /**
   * The DNS address for this API service - same as {{ id.get("servicePath") }}(),
   * exists for compatibility reasons.
   * @returns {string} The DNS address for this service.
   */
  static get {{ id.get("apiEndpoint") }}() {
    return '{{ api.hostName }}';
  }

  /**
   * The port for this API service.
   * @returns {number} The default port for this service.
   */
  static get {{ id.get("port") }}() {
    return {{ api.port }};
  }

  /**
   * The scopes needed to make gRPC calls for every method defined
   * in this service.
   * @returns {string[]} List of default scopes.
   */
  static get {{ id.get("scopes") }}() {
{%- if (service.oauthScopes.length == 0) %}
    return [];
{%- else %}
    return [
{%- set scopesJoiner = joiner() %}
{%- for scope in service.oauthScopes %}
      {{- scopesJoiner() }}
      '{{ scope }}'
{%- endfor %}
    ];
{%- endif %}
  }

  {{ id.get("getProjectId") }}(): Promise<string>;
  {{ id.get("getProjectId") }}(callback: Callback<string, undefined, undefined>): void;
  /**
   * Return the project ID used by this class.
   * @returns {Promise} A promise that resolves to string containing the project ID.
   */
  {{ id.get("getProjectId") }}(callback?: Callback<string, undefined, undefined>):
      Promise<string>|void {
    if (callback) {
      this.auth.getProjectId(callback);
      return;
    }
    return this.auth.getProjectId();
  }

  // -------------------
  // -- Service calls --
  // -------------------

{%- for method in service.simpleMethods %}
/**
{{- util.printComments(method, service) }}
 {%- if not api.handwrittenLayer %}
 * @example <caption>include:samples/generated/{{api.naming.version}}/{{service.name.toSnakeCase()}}.{{method.name.toSnakeCase()}}.js</caption>
 * region_tag:{{ api.hostName.split(".")[0] }}_{{ api.naming.version }}_generated_{{ service.name }}_{{ method.name }}_async
 {%- endif %}
 {%- if method.options and method.options.deprecated %}
 * @deprecated {{method.name}} is deprecated and may be removed in a future version.
 {%- endif %}
 */
  {{ method.name.toCamelCase() }}(
      request?: {{ util.toInterface(method.inputInterface) }},
      options?: CallOptions):
{%- if method.isDiregapicLRO %}
      Promise<[
        LROperation<{{ util.toInterface(method.outputInterface) }}, null>,
        {{ util.toInterface(method.outputInterface) }}|undefined, {}|undefined
      ]>;
{%- else %}
      Promise<[
        {{ util.toInterface(method.outputInterface) }},
        {{ util.toInterface(method.inputInterface) }}|undefined, {}|undefined
      ]>;
{%- endif %}
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      options: CallOptions,
      callback: Callback<
          {{ util.toInterface(method.outputInterface) }},
          {{ util.toInterface(method.inputInterface) }}|null|undefined,
          {}|null|undefined>): void;
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      callback: Callback<
          {{ util.toInterface(method.outputInterface) }},
          {{ util.toInterface(method.inputInterface) }}|null|undefined,
          {}|null|undefined>): void;
  {{ method.name.toCamelCase() }}(
      request?: {{ util.toInterface(method.inputInterface) }},
      optionsOrCallback?: CallOptions|Callback<
          {{ util.toInterface(method.outputInterface) }},
          {{ util.toInterface(method.inputInterface) }}|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          {{ util.toInterface(method.outputInterface) }},
          {{ util.toInterface(method.inputInterface) }}|null|undefined,
          {}|null|undefined>):
{%- if method.isDiregapicLRO %}
      Promise<[
        LROperation<{{ util.toInterface(method.outputInterface) }}, null>,
        {{ util.toInterface(method.outputInterface) }}|undefined, {}|undefined
{%- else %}
      Promise<[
        {{ util.toInterface(method.outputInterface) }},
        {{ util.toInterface(method.inputInterface) }}|undefined, {}|undefined
{%- endif %}
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    {{ util.buildHeaderRequestParam(method) }}
    this.{{ id.get("initialize") }}();
    {%- if method.options and method.options.deprecated %}
    this.warn('DEP${{service.name}}-${{method.name}}','{{method.name}} is deprecated and may be removed in a future version.', 'DeprecationWarning');
    {%- endif %}
    {%- if method.isDiregapicLRO %}
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(request, options, callback)
    .then(([response, operation, rawResponse]: [protos.google.cloud.compute.v1.IOperation, protos.google.cloud.compute.v1.IOperation, protos.google.cloud.compute.v1.IOperation]) => {
      return [
          { latestResponse: response, done: false, name: response.id, metadata: null, result: {}},
          operation,
          rawResponse
        ];
    });
    {%- else %}
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(request, options, callback);
    {%- endif %}
  }
{%- endfor %}
{% for method in service.streaming %}
{%- if method.serverStreaming and method.clientStreaming %}
/**
{{- util.printComments(method, service) }}
 {%- if not api.handwrittenLayer %}
 * @example <caption>include:samples/generated/{{api.naming.version}}/{{service.name.toSnakeCase()}}.{{method.name.toSnakeCase()}}.js</caption>
 * region_tag:{{ api.hostName.split(".")[0] }}_{{ api.naming.version }}_generated_{{ service.name }}_{{ method.name }}_async
 {%- endif %}
 {%- if method.options and method.options.deprecated %}
 * @deprecated {{method.name}} is deprecated and may be removed in a future version.
 {%- endif %}
 */
  {{ method.name.toCamelCase() }}(
      options?: CallOptions):
    gax.CancellableStream {
    this.{{ id.get("initialize") }}();
    {%- if method.options and method.options.deprecated %}
    this.warn('DEP${{service.name}}-${{method.name}}','{{method.name}} is deprecated and may be removed in a future version.', 'DeprecationWarning');
    {%- endif %}
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(null, options);
  }
{%- elif method.serverStreaming %}
/**
{{- util.printComments(method, service) }}
 {%- if not api.handwrittenLayer %}
 * @example <caption>include:samples/generated/{{api.naming.version}}/{{service.name.toSnakeCase()}}.{{method.name.toSnakeCase()}}.js</caption>
 * region_tag:{{ api.hostName.split(".")[0] }}_{{ api.naming.version }}_generated_{{ service.name }}_{{ method.name }}_async
 {%- endif %}
 {%- if method.options and method.options.deprecated %}
 * @deprecated {{method.name}} is deprecated and may be removed in a future version.
 {%- endif %}
 */
  {{ method.name.toCamelCase() }}(
      request?: {{ util.toInterface(method.inputInterface) }},
      options?: CallOptions):
    gax.CancellableStream{
    request = request || {};
    {{ util.buildHeaderRequestParam(method) }}
    this.{{ id.get("initialize") }}();
    {%- if method.options and method.options.deprecated %}
    this.warn('DEP${{service.name}}-${{method.name}}','{{method.name}} is deprecated and may be removed in a future version.', 'DeprecationWarning');
    {%- endif %}
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(request, options);
  }
{%- elif method.clientStreaming %}
/**
{{- util.printComments(method, service) }}
 {%- if not api.handwrittenLayer %}
 * @example <caption>include:samples/generated/{{api.naming.version}}/{{service.name.toSnakeCase()}}.{{method.name.toSnakeCase()}}.js</caption>
 * region_tag:{{ api.hostName.split(".")[0] }}_{{ api.naming.version }}_generated_{{ service.name }}_{{ method.name }}_async
 {%- endif %}
 {%- if method.options and method.options.deprecated %}
 * @deprecated {{method.name}} is deprecated and may be removed in a future version.
 {%- endif %}
 */
  {{ method.name.toCamelCase() }}(
      options?: CallOptions,
      callback?: Callback<
        {{ util.toInterface(method.outputInterface) }},
        {{ util.toInterface(method.inputInterface) }}|null|undefined,
        {}|null|undefined>):
    gax.CancellableStream;
  {{ method.name.toCamelCase() }}(
      callback?: Callback<
        {{ util.toInterface(method.outputInterface) }},
        {{ util.toInterface(method.inputInterface) }}|null|undefined,
        {}|null|undefined>):
    gax.CancellableStream;
  {{ method.name.toCamelCase() }}(
      optionsOrCallback?: CallOptions|Callback<
        {{ util.toInterface(method.outputInterface) }},
        {{ util.toInterface(method.inputInterface) }}|null|undefined,
        {}|null|undefined>,
      callback?: Callback<
        {{ util.toInterface(method.outputInterface) }},
        {{ util.toInterface(method.inputInterface) }}|null|undefined,
        {}|null|undefined>):
    gax.CancellableStream {
    if (optionsOrCallback instanceof Function && callback === undefined) {
        callback = optionsOrCallback;
        optionsOrCallback = {};
    }
    const options = optionsOrCallback as CallOptions;
    this.{{ id.get("initialize") }}();
    {%- if method.options and method.options.deprecated %}
    this.warn('DEP${{service.name}}-${{method.name}}','{{method.name}} is deprecated and may be removed in a future version.', 'DeprecationWarning');
    {%- endif %}
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(null, options, callback);
  }
{%- endif %}
{% endfor %}
{%- for method in service.longRunning %}
/**
{{- util.printComments(method, service) }}
 {%- if not api.handwrittenLayer %}
 * @example <caption>include:samples/generated/{{api.naming.version}}/{{service.name.toSnakeCase()}}.{{method.name.toSnakeCase()}}.js</caption>
 * region_tag:{{ api.hostName.split(".")[0] }}_{{ api.naming.version }}_generated_{{ service.name }}_{{ method.name }}_async
 {%- endif %}
 {%- if method.options and method.options.deprecated %}
 * @deprecated {{method.name}} is deprecated and may be removed in a future version.
 {%- endif %}
 */
  {{ method.name.toCamelCase() }}(
      request?: {{ util.toInterface(method.inputInterface) }},
      options?: CallOptions):
      Promise<[
        LROperation<{{ util.toInterface(method.longRunningResponseType, method.inputType) }}, {{ util.toInterface(method.longRunningMetadataType, method.inputType) }}>,
        {{ util.toInterface(method.outputInterface) }}|undefined, {}|undefined
      ]>;
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      options: CallOptions,
      callback: Callback<
          LROperation<{{ util.toInterface(method.longRunningResponseType, method.inputType) }}, {{ util.toInterface(method.longRunningMetadataType, method.inputType)  }}>,
          {{ util.toInterface(method.outputInterface) }}|null|undefined,
          {}|null|undefined>): void;
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      callback: Callback<
          LROperation<{{ util.toInterface(method.longRunningResponseType, method.inputType) }}, {{ util.toInterface(method.longRunningMetadataType, method.inputType)  }}>,
          {{ util.toInterface(method.outputInterface) }}|null|undefined,
          {}|null|undefined>): void;
  {{ method.name.toCamelCase() }}(
      request?: {{ util.toInterface(method.inputInterface) }},
      optionsOrCallback?: CallOptions|Callback<
          LROperation<{{ util.toInterface(method.longRunningResponseType, method.inputType)}}, {{ util.toInterface(method.longRunningMetadataType, method.inputType)  }}>,
          {{ util.toInterface(method.outputInterface) }}|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          LROperation<{{ util.toInterface(method.longRunningResponseType, method.inputType) }}, {{ util.toInterface(method.longRunningMetadataType, method.inputType)  }}>,
          {{ util.toInterface(method.outputInterface) }}|null|undefined,
          {}|null|undefined>):
      Promise<[
        LROperation<{{ util.toInterface(method.longRunningResponseType, method.inputType) }}, {{ util.toInterface(method.longRunningMetadataType, method.inputType)  }}>,
        {{ util.toInterface(method.outputInterface) }}|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    {{ util.buildHeaderRequestParam(method) }}
    this.{{ id.get("initialize") }}();
    {%- if method.options and method.options.deprecated %}
    this.warn('DEP${{service.name}}-${{method.name}}','{{method.name}} is deprecated and may be removed in a future version.', 'DeprecationWarning');
    {%- endif %}
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(request, options, callback);
  }
/**
{%- set decodeMethodName = id.get("check" + method.name.toPascalCase() + "Progress") -%}
{{- util.printDecodeMethodComments(method, decodeMethodName) }}
 {%- if not api.handwrittenLayer %}
 * @example <caption>include:samples/generated/{{api.naming.version}}/{{service.name.toSnakeCase()}}.{{method.name.toSnakeCase()}}.js</caption>
 * region_tag:{{ api.hostName.split(".")[0] }}_{{ api.naming.version }}_generated_{{ service.name }}_{{ method.name }}_async
 {%- endif %}
 {%- if method.options and method.options.deprecated %}
 * @deprecated {{method.name}} is deprecated and may be removed in a future version.
 {%- endif %}
 */
  async {{ decodeMethodName }}(name: string): Promise<LROperation<protos{{ method.longRunningResponseType }}, protos{{ method.longRunningMetadataType }}>>{
    {%- if method.options and method.options.deprecated %}
    this.warn('DEP${{service.name}}-${{decodeMethodName}}','{{decodeMethodName}} is deprecated and may be removed in a future version.', 'DeprecationWarning');
    {%- endif %}
    const request = new operationsProtos.google.longrunning.GetOperationRequest({name});
    const [operation] = await this.operationsClient.getOperation(request);
    const decodeOperation = new gax.Operation(operation, this.descriptors.longrunning.{{ method.name.toCamelCase() }}, gax.createDefaultBackoffSettings());
    return decodeOperation as LROperation<protos{{ method.longRunningResponseType }}, protos{{ method.longRunningMetadataType }}>;
  }
{%- endfor %}
{%- for method in service.paging %}
{%- if not method.ignoreMapPagingMethod %}
{%- if not method.pagingMapResponseType %}
 /**
{{- util.printComments(method, service, id.get(method.name.toCamelCase() + "Async")) }}
 {%- if method.options and method.options.deprecated %}
 * @deprecated {{method.name}} is deprecated and may be removed in a future version.
 {%- endif %}
 */
  {{ method.name.toCamelCase() }}(
      request?: {{ util.toInterface(method.inputInterface) }},
      options?: CallOptions):
      Promise<[
        {{ util.toInterface(method.pagingResponseType) }}[],
        {{ util.toInterface(method.inputInterface) }}|null,
        {{ util.toInterface(method.outputInterface) }}
      ]>;
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      options: CallOptions,
      callback: PaginationCallback<
          {{ util.toInterface(method.inputInterface) }},
          {{ util.toInterface(method.outputInterface) }}|null|undefined,
          {{ util.toInterface(method.pagingResponseType) }}>): void;
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      callback: PaginationCallback<
          {{ util.toInterface(method.inputInterface) }},
          {{ util.toInterface(method.outputInterface) }}|null|undefined,
          {{ util.toInterface(method.pagingResponseType) }}>): void;
  {{ method.name.toCamelCase() }}(
      request?: {{ util.toInterface(method.inputInterface) }},
      optionsOrCallback?: CallOptions|PaginationCallback<
          {{ util.toInterface(method.inputInterface) }},
          {{ util.toInterface(method.outputInterface) }}|null|undefined,
          {{ util.toInterface(method.pagingResponseType) }}>,
      callback?: PaginationCallback<
          {{ util.toInterface(method.inputInterface) }},
          {{ util.toInterface(method.outputInterface) }}|null|undefined,
          {{ util.toInterface(method.pagingResponseType) }}>):
      Promise<[
        {{ util.toInterface(method.pagingResponseType) }}[],
        {{ util.toInterface(method.inputInterface) }}|null,
        {{ util.toInterface(method.outputInterface) }}
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    {{ util.buildHeaderRequestParam(method) }}
    this.{{ id.get("initialize") }}();
    {%- if method.options and method.options.deprecated %}
    this.warn('DEP${{service.name}}-${{method.name}}','{{method.name}} is deprecated and may be removed in a future version.', 'DeprecationWarning');
    {%- endif %}
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(request, options, callback);
  }

/**
{{- util.printCommentsPageStream(method, id.get(method.name.toCamelCase() + "Async")) }}
 {%- if method.options and method.options.deprecated %}
 * @deprecated {{method.name}} is deprecated and may be removed in a future version.
 {%- endif %}
 */
  {{ id.get(method.name.toCamelCase() + "Stream") }}(
      request?: {{ util.toInterface(method.inputInterface) }},
      options?: CallOptions):
    Transform{
    request = request || {};
    {{ util.buildHeaderRequestParam(method) }}
    const defaultCallSettings = this._defaults['{{method.name.toCamelCase()}}'];
    const callSettings = defaultCallSettings.merge(options);
    this.{{ id.get("initialize") }}();
    {%- if method.options and method.options.deprecated %}
    this.warn('DEP${{service.name}}-${{method.name}}','{{method.name}} is deprecated and may be removed in a future version.', 'DeprecationWarning');
    {%- endif %}
    return this.descriptors.page.{{ method.name.toCamelCase() }}.createStream(
      this.innerApiCalls.{{ method.name.toCamelCase() }} as gax.GaxCall,
      request,
      callSettings
    );
  }
{%- endif %}

/**
{{- util.printCommentsPageAsync(method, id.get(method.name.toCamelCase() + "Async")) }}
 {%- if not api.handwrittenLayer %}
 * @example <caption>include:samples/generated/{{api.naming.version}}/{{service.name.toSnakeCase()}}.{{method.name.toSnakeCase()}}.js</caption>
 * region_tag:{{ api.hostName.split(".")[0] }}_{{ api.naming.version }}_generated_{{ service.name }}_{{ method.name }}_async
 {%- endif %}
 {%- if method.options and method.options.deprecated %}
 * @deprecated {{method.name}} is deprecated and may be removed in a future version.
 {%- endif %}
 */
  {{ id.get(method.name.toCamelCase() + "Async") }}(
      request?: {{ util.toInterface(method.inputInterface) }},
      options?: CallOptions):
    {%- if method.pagingMapResponseType %}
    AsyncIterable<[string, {{ util.toInterface(method.pagingMapResponseType) }}]>{
    {%- else %}
    AsyncIterable<{{ util.toInterface(method.pagingResponseType) }}>{
    {%- endif %}
    request = request || {};
    {{ util.buildHeaderRequestParam(method) }}
    const defaultCallSettings = this._defaults['{{method.name.toCamelCase()}}'];
    const callSettings = defaultCallSettings.merge(options);
    this.{{ id.get("initialize") }}();
    {%- if method.options and method.options.deprecated %}
    this.warn('DEP${{service.name}}-${{method.name}}','{{method.name}} is deprecated and may be removed in a future version.', 'DeprecationWarning');
    {%- endif %}
    return this.descriptors.page.{{ method.name.toCamelCase() }}.asyncIterate(
      this.innerApiCalls['{{ method.name.toCamelCase() }}'] as GaxCall,
      request as unknown as RequestType,
      callSettings
    {%- if method.pagingMapResponseType %}
    ) as AsyncIterable<[string, {{ util.toInterface(method.pagingMapResponseType) }}]>;
    {%- else %}
    ) as AsyncIterable<{{ util.toInterface(method.pagingResponseType) }}>;
    {%- endif %}
  }
{%- endif %}
{%- endfor %}
{%- if service.IAMPolicyMixin > 0 %}
{{ iam.iamServiceMethods()}}
{% endif -%}
{%- if service.LocationMixin > 0 %}
{{ location.locationServiceMethods()}}
{% endif -%}
{%- if service.LongRunningOperationsMixin > 0 %}
{{ operations.operationsServiceMethods()}}
{% endif -%}
{%- if service.pathTemplates.length > 0 %}
  // --------------------
  // -- Path templates --
  // --------------------
{%- for template in service.pathTemplates %}

  /**
   * Return a fully-qualified {{ template.name.toCamelCase() }} resource name string.
   *
{%- for param in template.params %}
   * @param {string} {{ id.get(param) | replace(regExp, '{@link $2|$1}') }}
{%- endfor %}
   * @returns {string} Resource name string.
   */
  {{ id.get(template.name.toCamelCase() + "Path") }}(
{%- set paramJoiner = joiner() %}
{%- for param in template.params %}
{{-paramJoiner()-}}{{ id.get(param.toCamelCase()) }}:string
{%- endfor -%}
  ) {
    return this.pathTemplates.{{ template.name.toCamelCase() }}PathTemplate.render({
{%- for param in template.params %}
      {{ param }}: {{ id.get(param.toCamelCase()) }},
{%- endfor %}
    });
  }
{%- for param in template.params %}

  /**
   * Parse the {{ param }} from {{ template.name.toPascalCase() }} resource.
   *
   * @param {string} {{ template.name.toCamelCase() }}Name
   *   A fully-qualified path representing {{ template.name }} resource.
   * @returns {string} A string representing the {{ param }}.
   */
  {{ id.get("match" + param.toPascalCase() + "From" + template.name.toPascalCase() + "Name") }}({{ template.name.toCamelCase() }}Name: string) {
    return this.pathTemplates.{{ template.name.toCamelCase() }}PathTemplate.match({{ template.name.toCamelCase() }}Name).{{ param }};
  }
{%- endfor %}
{%- endfor %}
{%- endif %}

  /**
   * Terminate the gRPC channel and close the client.
   *
   * The client will no longer be usable and all future behavior is undefined.
   * @returns {Promise} A promise that resolves when the client is closed.
   */
  {{ id.get("close") }}(): Promise<void> {
    if (this.{{ service.name.toCamelCase() }}Stub && !this._terminated) {
      return this.{{ service.name.toCamelCase() }}Stub.then(stub => {
        this._terminated = true;
        stub.close();
        {%- if service.IAMPolicyMixin > 0 %}
        this.iamClient.close();
        {%- endif %}
        {%- if service.LocationMixin > 0 %}
        this.locationsClient.close();
        {%- endif %}
        {%- if service.longRunning.length > 0 or service.LongRunningOperationsMixin > 0 %}
        this.operationsClient.close();
        {%- endif %}
      });
    }
    return Promise.resolve();
  }
}
