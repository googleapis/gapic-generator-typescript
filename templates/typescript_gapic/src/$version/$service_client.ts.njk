{#-

Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

-#}
{% import "../../_license.njk" as license -%}
{{license.license(commonParameters.copyrightYear)}}
{% import "../../_util.njk" as util -%}

import * as gax from 'google-gax';
import {APICallback, Callback, CallOptions, Descriptors, ClientOptions
{%- if service.longRunning.length > 0 %}, LROperation{%- endif -%}
{%- if service.paging.length > 0 %}, PaginationCallback{%- endif -%}
} from 'google-gax';
import * as path from 'path';
{% if (service.paging.length > 0) %}
import { Transform } from 'stream';
{%- endif %}
import * as protos from '../../protos/protos';
import * as gapicConfig from './{{ service.name.toSnakeCase() }}_client_config.json';

const version = require('../../../package.json').version;

/**
{{- util.printCommentsForService(service) }}
 * @class
 * @memberof {{ api.naming.version }}
 */
export class {{ service.name }}Client {
  private _terminated = false;
  private _opts: ClientOptions;
  private _gaxModule: typeof gax | typeof gax.fallback;
  private _gaxGrpc: gax.GrpcClient | gax.fallback.GrpcClient;
  private _protos: {};
  private _defaults: {[method: string]: gax.CallSettings};
  auth: gax.GoogleAuth;
  descriptors: Descriptors = {page: {}, stream: {}, longrunning: {}, batching: {}};
  innerApiCalls: {[name: string]: Function};
  {%- if (service.pathTemplates.length > 0) %}
  pathTemplates: {[name: string]: gax.PathTemplate};
  {%- endif %}
{%- if (service.longRunning.length > 0) %}
  operationsClient: gax.OperationsClient;
{%- endif %}
  {{ service.name.toCamelCase() }}Stub?: Promise<{[name: string]: Function}>;

  /**
   * Construct an instance of {{ service.name }}Client.
   *
   * @param {object} [options] - The configuration object. See the subsequent
   *   parameters for more details.
   * @param {object} [options.credentials] - Credentials object.
   * @param {string} [options.credentials.client_email]
   * @param {string} [options.credentials.private_key]
   * @param {string} [options.email] - Account email address. Required when
   *     using a .pem or .p12 keyFilename.
   * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or
   *     .p12 key downloaded from the Google Developers Console. If you provide
   *     a path to a JSON file, the projectId option below is not necessary.
   *     NOTE: .pem and .p12 require you to specify options.email as well.
   * @param {number} [options.port] - The port on which to connect to
   *     the remote host.
   * @param {string} [options.projectId] - The project ID from the Google
   *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check
   *     the environment variable GCLOUD_PROJECT for your project ID. If your
   *     app is running in an environment which supports
   *     {@link https://developers.google.com/identity/protocols/application-default-credentials Application Default Credentials},
   *     your project ID will be detected automatically.
   * @param {string} [options.apiEndpoint] - The domain name of the
   *     API remote host.
   */

  constructor(opts?: ClientOptions) {
    // Ensure that options include the service address and port.
    const staticMembers = this.constructor as typeof {{ service.name }}Client;
    const servicePath = opts && opts.servicePath ?
        opts.servicePath :
        ((opts && opts.apiEndpoint) ? opts.apiEndpoint :
                                      staticMembers.servicePath);
    const port = opts && opts.port ? opts.port : staticMembers.port;

    if (!opts) {
      opts = {servicePath, port};
    }
    opts.servicePath = opts.servicePath || servicePath;
    opts.port = opts.port || port;
    opts.clientConfig = opts.clientConfig || {};

    const isBrowser = (typeof window !== 'undefined');
    if (isBrowser){
      opts.fallback = true;
    }
    // If we are in browser, we are already using fallback because of the
    // "browser" field in package.json.
    // But if we were explicitly requested to use fallback, let's do it now.
    this._gaxModule = !isBrowser && opts.fallback ? gax.fallback : gax;

    // Create a `gaxGrpc` object, with any grpc-specific options
    // sent to the client.
    opts.scopes = (this.constructor as typeof {{ service.name }}Client).scopes;
    this._gaxGrpc = new this._gaxModule.GrpcClient(opts);

    // Save options to use in initialize() method.
    this._opts = opts;

    // Save the auth object to the client, for use by other methods.
    this.auth = (this._gaxGrpc.auth as gax.GoogleAuth);

    // Determine the client header string.
    const clientHeader = [
      `gax/${this._gaxModule.version}`,
      `gapic/${version}`,
    ];
    if (typeof process !== 'undefined' && 'versions' in process) {
      clientHeader.push(`gl-node/${process.versions.node}`);
    } else {
      clientHeader.push(`gl-web/${this._gaxModule.version}`);
    }
    if (!opts.fallback) {
      clientHeader.push(`grpc/${this._gaxGrpc.grpcVersion}`);
    }
    if (opts.libName && opts.libVersion) {
      clientHeader.push(`${opts.libName}/${opts.libVersion}`);
    }
    // Load the applicable protos.
    // For Node.js, pass the path to JSON proto file.
    // For browsers, pass the JSON content.

    const nodejsProtoPath = path.join(__dirname, '..', '..', 'protos', 'protos.json');
    this._protos = this._gaxGrpc.loadProto(
      opts.fallback ?
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        require("../../protos/protos.json") :
        nodejsProtoPath
    );
{%- if (service.pathTemplates.length > 0) %}

    // This API contains "path templates"; forward-slash-separated
    // identifiers to uniquely identify resources within the API.
    // Create useful helper objects for these.
    this.pathTemplates = {
{%- for template in service.pathTemplates %}
      {{ template.name.toCamelCase() }}PathTemplate: new this._gaxModule.PathTemplate(
        '{{ template.pattern }}'
      ),
{%- endfor %}
    };
{%- endif %}

{%- if (service.paging.length > 0) %}

    // Some of the methods on this service return "paged" results,
    // (e.g. 50 results at a time, with tokens to get subsequent
    // pages). Denote the keys used for pagination and results.
    this.descriptors.page = {
{%- set pagingJoiner = joiner() %}
{%- for method in service.paging %}
      {{- pagingJoiner() }}
      {{ method.name.toCamelCase() }}:
          new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', '{{ method.pagingFieldName.toCamelCase() }}')
{%- endfor %}
    };
{%- endif %}

{%- if (service.streaming.length > 0) %}

    // Some of the methods on this service provide streaming responses.
    // Provide descriptors for these.
    this.descriptors.stream = {
{%- set streamingJoiner = joiner() %}
{%- for method in service.streaming %}
      {{- streamingJoiner() }}
      {{ method.name.toCamelCase() }}: new this._gaxModule.StreamDescriptor(gax.StreamType.{{ method.streaming }})
{%- endfor %}
    };
{%- endif %}
{%- if (service.longRunning.length > 0) or (service.bundleConfigs.length > 0) %}

    // This API contains "long-running operations", which return a
    // an Operation object that allows for tracking of the operation,
    // rather than holding a request open.
    const protoFilesRoot = opts.fallback ?
      this._gaxModule.protobuf.Root.fromJSON(
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        require("../../protos/protos.json")) :
      this._gaxModule.protobuf.loadSync(nodejsProtoPath);
{% endif %}
{%- if service.longRunning.length > 0 %}
    this.operationsClient = this._gaxModule.lro({
      auth: this.auth,
      grpc: 'grpc' in this._gaxGrpc ? this._gaxGrpc.grpc : undefined
    }).operationsClient(opts);

{%- for method in service.longRunning %}
    const {{ method.name.toCamelCase() }}Response = protoFilesRoot.lookup(
      '{{ method.longRunningResponseType }}') as gax.protobuf.Type;
    const {{ method.name.toCamelCase() }}Metadata = protoFilesRoot.lookup(
      '{{ method.longRunningMetadataType }}') as gax.protobuf.Type;
{%- endfor %}

    this.descriptors.longrunning = {
{%- set longRunningJoiner = joiner() %}
{%- for method in service.longRunning %}
      {{- longRunningJoiner() }}
      {{ method.name.toCamelCase() }}: new this._gaxModule.LongrunningDescriptor(
        this.operationsClient,
        {{ method.name.toCamelCase() }}Response.decode.bind({{ method.name.toCamelCase() }}Response),
        {{ method.name.toCamelCase() }}Metadata.decode.bind({{ method.name.toCamelCase() }}Metadata))
{%- endfor %}
    };
{%- endif %}

{%- if (service.bundleConfigs.length > 0) %}
    // Some methods on this API support automatically batching
    // requests; denote this.

    this.descriptors.batching = {
{%- for method in service.bundleConfigsMethods %}
      {{ method.name }}: new this._gaxModule.BundleDescriptor(
        '{{ method.bundleConfig.batchDescriptor.batched_field }}',
        [
{%- set pagingJoiner = joiner() -%}
{%- for field in method.bundleConfig.batchDescriptor.discriminator_fields -%}
        {{- pagingJoiner() -}}
        '{{ field }}'
{%- endfor -%}
        ],
{%- if method.bundleConfig.batchDescriptor.subresponse_field === 'null' %}
        null,
{%- else %}
        '{{- method.bundleConfig.batchDescriptor.subresponse_field }}',
{%- endif %}
        gax.createByteLengthFunction(
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          protoFilesRoot.lookupType('{{ method.bundleConfig.repeatedField }}') as any
        )
      ),
    };
{%- endfor %}
{%- endif %}

    // Put together the default options sent with requests.
    this._defaults = this._gaxGrpc.constructSettings(
        '{{ api.naming.protoPackage }}.{{ service.name }}', gapicConfig as gax.ClientConfig,
        opts.clientConfig || {}, {'x-goog-api-client': clientHeader.join(' ')});

    // Set up a dictionary of "inner API calls"; the core implementation
    // of calling the API is handled in `google-gax`, with this code
    // merely providing the destination and request information.
    this.innerApiCalls = {};
  }

  /**
   * Initialize the client.
   * Performs asynchronous operations (such as authentication) and prepares the client.
   * This function will be called automatically when any class method is called for the
   * first time, but if you need to initialize it before calling an actual method,
   * feel free to call initialize() directly.
   *
   * You can await on this method if you want to make sure the client is initialized.
   *
   * @returns {Promise} A promise that resolves to an authenticated service stub.
   */
  initialize() {
    // If the client stub promise is already initialized, return immediately.
    if (this.{{ service.name.toCamelCase() }}Stub) {
      return this.{{ service.name.toCamelCase() }}Stub;
    }

    // Put together the "service stub" for
    // {{api.naming.protoPackage}}.{{ service.name }}.
    this.{{ service.name.toCamelCase() }}Stub = this._gaxGrpc.createStub(
        this._opts.fallback ?
          (this._protos as protobuf.Root).lookupService('{{api.naming.protoPackage}}.{{ service.name }}') :
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (this._protos as any).{{api.naming.protoPackage}}.{{ service.name }},
        this._opts) as Promise<{[method: string]: Function}>;

    // Iterate over each of the methods that the service provides
    // and create an API call method for each.
    const {{ service.name.toCamelCase() }}StubMethods =
        [
{%- set stubMethodsJoiner = joiner(', ') -%}
{%- for method in service.method -%}
      {{- stubMethodsJoiner() -}}
      '{{ method.name.toCamelCase() }}'
{%- endfor -%}
    ];

    for (const methodName of {{ service.name.toCamelCase() }}StubMethods) {
      const innerCallPromise = this.{{ service.name.toCamelCase() }}Stub.then(
        stub => (...args: Array<{}>) => {
          if (this._terminated) {
            return Promise.reject('The client has already been closed.');
          }
          const func = stub[methodName];
          return func.apply(stub, args);
        },
        (err: Error|null|undefined) => () => {
          throw err;
        });

      const apiCall = this._gaxModule.createApiCall(
        innerCallPromise,
        this._defaults[methodName],
        this.descriptors.page[methodName] ||
            this.descriptors.stream[methodName] ||
            this.descriptors.longrunning[methodName]
      );

      this.innerApiCalls[methodName] = (
        argument: {},
        callOptions?: CallOptions,
        callback?: APICallback
      ) => {
        return apiCall(argument, callOptions, callback);
      };
    }

    return this.{{ service.name.toCamelCase() }}Stub;
  }

  /**
   * The DNS address for this API service.
   */
  static get servicePath() {
    return '{{ api.hostName }}';
  }

  /**
   * The DNS address for this API service - same as servicePath(),
   * exists for compatibility reasons.
   */
  static get apiEndpoint() {
    return '{{ api.hostName }}';
  }

  /**
   * The port for this API service.
   */
  static get port() {
    return {{ api.port }};
  }

  /**
   * The scopes needed to make gRPC calls for every method defined
   * in this service.
   */
  static get scopes() {
{%- if (service.oauthScopes.length == 0) %}
    return [];
{%- else %}
    return [
{%- set scopesJoiner = joiner() %}
{%- for scope in service.oauthScopes %}
      {{- scopesJoiner() }}
      '{{ scope }}'
{%- endfor %}
    ];
{%- endif %}
  }

  getProjectId(): Promise<string>;
  getProjectId(callback: Callback<string, undefined, undefined>): void;
  /**
   * Return the project ID used by this class.
   * @param {function(Error, string)} callback - the callback to
   *   be called with the current project Id.
   */
  getProjectId(callback?: Callback<string, undefined, undefined>):
      Promise<string>|void {
    if (callback) {
      this.auth.getProjectId(callback);
      return;
    }
    return this.auth.getProjectId();
  }

  // -------------------
  // -- Service calls --
  // -------------------

{%- for method in service.simpleMethods %}
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      options?: gax.CallOptions):
      Promise<[
        {{ util.toInterface(method.outputInterface) }},
        {{ util.toInterface(method.inputInterface) }}|undefined, {}|undefined
      ]>;
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      options: gax.CallOptions,
      callback: Callback<
          {{ util.toInterface(method.outputInterface) }},
          {{ util.toInterface(method.inputInterface) }}|undefined,
          {}|undefined>): void;
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      callback: Callback<
          {{ util.toInterface(method.outputInterface) }},
          {{ util.toInterface(method.inputInterface) }}|undefined,
          {}|undefined>): void;
/**
{{- util.printComments(method, service) }}
 */
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      optionsOrCallback?: gax.CallOptions|Callback<
          {{ util.toInterface(method.outputInterface) }},
          {{ util.toInterface(method.inputInterface) }}|undefined, {}|undefined>,
      callback?: Callback<
          {{ util.toInterface(method.outputInterface) }},
          {{ util.toInterface(method.inputInterface) }}|undefined,
          {}|undefined>):
      Promise<[
        {{ util.toInterface(method.outputInterface) }},
        {{ util.toInterface(method.inputInterface) }}|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: gax.CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as gax.CallOptions;
    }
    {{ util.buildHeaderRequestParam(method) }}
    this.initialize();
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(request, options, callback);
  }
{%- endfor %}
{% for method in service.streaming %}
{%- if method.serverStreaming and method.clientStreaming %}
/**
{{- util.printComments(method, service) }}
 */
  {{ method.name.toCamelCase() }}(
      options?: gax.CallOptions):
    gax.CancellableStream {
    this.initialize();
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(options);
  }
{%- elif method.serverStreaming %}
/**
{{- util.printComments(method, service) }}
 */
  {{ method.name.toCamelCase() }}(
      request?: {{ util.toInterface(method.inputInterface) }},
      options?: gax.CallOptions):
    gax.CancellableStream{
    request = request || {};
    {{ util.buildHeaderRequestParam(method) }}
    this.initialize();
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(request, options);
  }
{%- elif method.clientStreaming %}
  {{ method.name.toCamelCase() }}(
      options?: gax.CallOptions,
      callback?: Callback<
        {{ util.toInterface(method.outputInterface) }},
        {{ util.toInterface(method.inputInterface) }}|undefined, {}|undefined>):
    gax.CancellableStream;
  {{ method.name.toCamelCase() }}(
      callback?: Callback<
        {{ util.toInterface(method.outputInterface) }},
        {{ util.toInterface(method.inputInterface) }}|undefined, {}|undefined>):
    gax.CancellableStream;
/**
{{- util.printComments(method, service) }}
 */
  {{ method.name.toCamelCase() }}(
      optionsOrCallback?: gax.CallOptions|Callback<
        {{ util.toInterface(method.outputInterface) }},
        {{ util.toInterface(method.inputInterface) }}|undefined, {}|undefined>,
      callback?: Callback<
        {{ util.toInterface(method.outputInterface) }},
        {{ util.toInterface(method.inputInterface) }}|undefined, {}|undefined>):
    gax.CancellableStream {
    if (optionsOrCallback instanceof Function && callback === undefined) {
        callback = optionsOrCallback;
        optionsOrCallback = {};
    }
    const options = optionsOrCallback as gax.CallOptions;
    this.initialize();
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(null, options, callback);
  }
{%- endif %}
{% endfor %}
{%- for method in service.longRunning %}
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      options?: gax.CallOptions):
      Promise<[
        LROperation<{{ util.toInterface(method.longRunningResponseType, method.inputType) }}, {{ util.toInterface(method.longRunningMetadataType, method.inputType) }}>,
        {{ util.toInterface(method.outputInterface) }}|undefined, {}|undefined
      ]>;
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      options: gax.CallOptions,
      callback: Callback<
          LROperation<{{ util.toInterface(method.longRunningResponseType, method.inputType) }}, {{ util.toInterface(method.longRunningMetadataType, method.inputType)  }}>,
          {{ util.toInterface(method.outputInterface) }}|undefined,
          {}|undefined>): void;
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      callback: Callback<
          LROperation<{{ util.toInterface(method.longRunningResponseType, method.inputType) }}, {{ util.toInterface(method.longRunningMetadataType, method.inputType)  }}>,
          {{ util.toInterface(method.outputInterface) }}|undefined,
          {}|undefined>): void;
/**
{{- util.printComments(method, service) }}
 */
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      optionsOrCallback?: gax.CallOptions|Callback<
          LROperation<{{ util.toInterface(method.longRunningResponseType, method.inputType)}}, {{ util.toInterface(method.longRunningMetadataType, method.inputType)  }}>,
          {{ util.toInterface(method.outputInterface) }}|undefined, {}|undefined>,
      callback?: Callback<
          LROperation<{{ util.toInterface(method.longRunningResponseType, method.inputType) }}, {{ util.toInterface(method.longRunningMetadataType, method.inputType)  }}>,
          {{ util.toInterface(method.outputInterface) }}|undefined,
          {}|undefined>):
      Promise<[
        LROperation<{{ util.toInterface(method.longRunningResponseType, method.inputType) }}, {{ util.toInterface(method.longRunningMetadataType, method.inputType)  }}>,
        {{ util.toInterface(method.outputInterface) }}|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: gax.CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as gax.CallOptions;
    }
    {{ util.buildHeaderRequestParam(method) }}
    this.initialize();
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(request, options, callback);
  }
{%- endfor %}
{%- for method in service.paging %}
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      options?: gax.CallOptions):
      Promise<[
        {{ util.toInterface(method.pagingResponseType) }}[],
        {{ util.toInterface(method.inputInterface) }}|null,
        {{ util.toInterface(method.outputInterface) }}
      ]>;
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      options: gax.CallOptions,
      callback: PaginationCallback<
          {{ util.toInterface(method.inputInterface) }},
          {{ util.toInterface(method.outputInterface) }}|null,
          {{ util.toInterface(method.pagingResponseType) }}>): void;
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      callback: PaginationCallback<
          {{ util.toInterface(method.inputInterface) }},
          {{ util.toInterface(method.outputInterface) }}|null,
          {{ util.toInterface(method.pagingResponseType) }}>): void;
/**
{{- util.printComments(method, service) }}
 */
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      optionsOrCallback?: gax.CallOptions|PaginationCallback<
          {{ util.toInterface(method.inputInterface) }},
          {{ util.toInterface(method.outputInterface) }}|null,
          {{ util.toInterface(method.pagingResponseType) }}>,
      callback?: PaginationCallback<
          {{ util.toInterface(method.inputInterface) }},
          {{ util.toInterface(method.outputInterface) }}|null,
          {{ util.toInterface(method.pagingResponseType) }}>):
      Promise<[
        {{ util.toInterface(method.pagingResponseType) }}[],
        {{ util.toInterface(method.inputInterface) }}|null,
        {{ util.toInterface(method.outputInterface) }}
      ]>|void {
    request = request || {};
    let options: gax.CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as gax.CallOptions;
    }
    {{ util.buildHeaderRequestParam(method) }}
    this.initialize();
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(request, options, callback);
  }

/**
{{- util.printCommentsPageStream(method) }}
 */
  {{ method.name.toCamelCase() }}Stream(
      request?: {{ util.toInterface(method.inputInterface) }},
      options?: gax.CallOptions):
    Transform{
    request = request || {};
    {{ util.buildHeaderRequestParam(method) }}
    const callSettings = new gax.CallSettings(options);
    this.initialize();
    return this.descriptors.page.{{ method.name.toCamelCase() }}.createStream(
      this.innerApiCalls.{{ method.name.toCamelCase() }} as gax.GaxCall,
      request,
      callSettings
    );
  }
{%- endfor %}
{%- if (service.pathTemplates.length > 0) %}
  // --------------------
  // -- Path templates --
  // --------------------
{%- for template in service.pathTemplates %}

  /**
   * Return a fully-qualified {{ template.name.toCamelCase() }} resource name string.
   *
{%- for param in template.params %}
   * @param {string} {{ param | replace(regExp, '{@link $2|$1}') }}
{%- endfor %}
   * @returns {string} Resource name string.
   */
  {{ template.name.toCamelCase() }}Path(
{%- set paramJoiner = joiner() %}
{%- for param in template.params %}
{{-paramJoiner()-}}{{ param.toCamelCase() }}:string
{%- endfor -%}
  ) {
    return this.pathTemplates.{{ template.name.toCamelCase() }}PathTemplate.render({
{%- for param in template.params %}
      {{ param }}: {{ param.toCamelCase() }},
{%- endfor %}
    });
  }
{%- for param in template.params %}

  /**
   * Parse the {{ param }} from {{ template.name.toPascalCase() }} resource.
   *
   * @param {string} {{ template.name.toCamelCase() }}Name
   *   A fully-qualified path representing {{ template.name }} resource.
   * @returns {string} A string representing the {{ param }}.
   */
  match{{ param.toPascalCase() }}From{{ template.name.toPascalCase() }}Name({{ template.name.toCamelCase() }}Name: string) {
    return this.pathTemplates.{{ template.name.toCamelCase() }}PathTemplate.match({{ template.name.toCamelCase() }}Name).{{ param }};
  }
{%- endfor %}
{%- endfor %}
{%- endif %}

  /**
   * Terminate the GRPC channel and close the client.
   *
   * The client will no longer be usable and all future behavior is undefined.
   */
  close(): Promise<void> {
    this.initialize();
    if (!this._terminated) {
      return this.{{ service.name.toCamelCase() }}Stub!.then(stub => {
        this._terminated = true;
        stub.close();
      });
    }
    return Promise.resolve();
  }
}
