{#-

Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

-#}
{% import "../../_license.njk" as license -%}
{{license.license(commonParameters.copyrightYear)}}
/* global window */
{% import "../../_util.njk" as util -%}
{% import "../../_iam.njk" as iam -%}
{% import "../../_namer.njk" as namer -%}
{{- namer.initialize(id, service) -}}
import * as gax from 'google-gax';
import {Callback, CallOptions, Descriptors, ClientOptions
{%- if service.longRunning.length > 0 %}, LROperation{%- endif -%}
{%- if service.paging.length > 0 %}, PaginationCallback, GaxCall{%- endif -%}
{%- if service.iamService > 0 %}, IamClient, IamProtos{%- endif -%}
} from 'google-gax';
import * as path from 'path';
{% if (service.paging.length > 0) %}
import { Transform } from 'stream';
import { RequestType } from 'google-gax/build/src/apitypes';
{%- endif %}
import * as protos from '../../protos/protos';
/**
 * Client JSON configuration object, loaded from
 * `src/{{ api.naming.version }}/{{ service.name.toSnakeCase() }}_client_config.json`.
 * This file defines retry strategy and timeouts for all API methods in this library.
 */
import * as gapicConfig from './{{ service.name.toSnakeCase() }}_client_config.json';
{% if service.longRunning.length > 0 -%}
import { operationsProtos } from 'google-gax';
{%- endif %}
const version = require('../../../package.json').version;

/**
{{- util.printCommentsForService(service) }}
 * @class
 * @memberof {{ api.naming.version }}
 */
export class {{ service.name }}Client {
  private _terminated = false;
  private _opts: ClientOptions;
  private _gaxModule: typeof gax | typeof gax.fallback;
  private _gaxGrpc: gax.GrpcClient | gax.fallback.GrpcClient;
  private _protos: {};
  private _defaults: {[method: string]: gax.CallSettings};
  auth: gax.GoogleAuth;
  descriptors: Descriptors = {
    page: {},
    stream: {},
    longrunning: {},
    batching: {},
  };
  innerApiCalls: {[name: string]: Function};
  {%- if service.iamService > 0 %}
  iamClient: IamClient;
  {%- endif %}
  {%- if (service.pathTemplates.length > 0) %}
  pathTemplates: {[name: string]: gax.PathTemplate};
  {%- endif %}
{%- if (service.longRunning.length > 0) %}
  operationsClient: gax.OperationsClient;
{%- endif %}
  {{ service.name.toCamelCase() }}Stub?: Promise<{[name: string]: Function}>;

  /**
   * Construct an instance of {{ service.name }}Client.
   *
   * @param {object} [options] - The configuration object.
   * The options accepted by the constructor are described in detail
   * in [this document](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#creating-the-client-instance).
   * The common options are:
   * @param {object} [options.credentials] - Credentials object.
   * @param {string} [options.credentials.client_email]
   * @param {string} [options.credentials.private_key]
   * @param {string} [options.email] - Account email address. Required when
   *     using a .pem or .p12 keyFilename.
   * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or
   *     .p12 key downloaded from the Google Developers Console. If you provide
   *     a path to a JSON file, the projectId option below is not necessary.
   *     NOTE: .pem and .p12 require you to specify options.email as well.
   * @param {number} [options.port] - The port on which to connect to
   *     the remote host.
   * @param {string} [options.projectId] - The project ID from the Google
   *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check
   *     the environment variable GCLOUD_PROJECT for your project ID. If your
   *     app is running in an environment which supports
   *     {@link https://developers.google.com/identity/protocols/application-default-credentials Application Default Credentials},
   *     your project ID will be detected automatically.
   * @param {string} [options.apiEndpoint] - The domain name of the
   *     API remote host.
   * @param {gax.ClientConfig} [options.clientConfig] - Client configuration override.
   *     Follows the structure of {@link gapicConfig}.
   * @param {boolean} [options.fallback] - Use HTTP fallback mode.
   *     In fallback mode, a special browser-compatible transport implementation is used
   *     instead of gRPC transport. In browser context (if the `window` object is defined)
   *     the fallback mode is enabled automatically; set `options.fallback` to `false`
   *     if you need to override this behavior.
   */
  constructor(opts?: ClientOptions) {
    // Ensure that options include all the required fields.
    const staticMembers = this.constructor as typeof {{ service.name }}Client;
    const servicePath = opts?.servicePath || opts?.apiEndpoint || staticMembers.{{ id.get("servicePath") }};
    const port = opts?.port || staticMembers.{{ id.get("port") }};
    const clientConfig = opts?.clientConfig ?? {};
    const fallback = opts?.fallback ?? (typeof window !== 'undefined' && typeof window?.fetch === 'function');
    opts = Object.assign({servicePath, port, clientConfig, fallback}, opts);

    // If scopes are unset in options and we're connecting to a non-default endpoint, set scopes just in case.
    if (servicePath !== staticMembers.{{ id.get("servicePath") }} && !('scopes' in opts)) {
      opts['scopes'] = staticMembers.{{ id.get("scopes") }};
    }

    // Choose either gRPC or proto-over-HTTP implementation of google-gax.
    this._gaxModule = opts.fallback ? gax.fallback : gax;

    // Create a `gaxGrpc` object, with any grpc-specific options sent to the client.
    this._gaxGrpc = new this._gaxModule.GrpcClient(opts);

    // Save options to use in {{ id.get("initialize") }}() method.
    this._opts = opts;

    // Save the auth object to the client, for use by other methods.
    this.auth = (this._gaxGrpc.auth as gax.GoogleAuth);

    // Set the default scopes in auth client if needed.
    if (servicePath === staticMembers.{{ id.get("servicePath") }}) {
      this.auth.defaultScopes = staticMembers.{{ id.get("scopes") }};
    }
  {%- if service.iamService > 0 %}
    this.iamClient = new IamClient(this._gaxGrpc, opts);
  {% endif %}

    // Determine the client header string.
    const clientHeader = [
      `gax/${this._gaxModule.version}`,
      `gapic/${version}`,
    ];
    if (typeof process !== 'undefined' && 'versions' in process) {
      clientHeader.push(`gl-node/${process.versions.node}`);
    } else {
      clientHeader.push(`gl-web/${this._gaxModule.version}`);
    }
    if (!opts.fallback) {
      clientHeader.push(`grpc/${this._gaxGrpc.grpcVersion}`);
    }
    if (opts.libName && opts.libVersion) {
      clientHeader.push(`${opts.libName}/${opts.libVersion}`);
    }
    // Load the applicable protos.
    // For Node.js, pass the path to JSON proto file.
    // For browsers, pass the JSON content.

    const nodejsProtoPath = path.join(__dirname, '..', '..', 'protos', 'protos.json');
    this._protos = this._gaxGrpc.loadProto(
      opts.fallback ?
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        require("../../protos/protos.json") :
        nodejsProtoPath
    );
{%- if (service.pathTemplates.length > 0) %}

    // This API contains "path templates"; forward-slash-separated
    // identifiers to uniquely identify resources within the API.
    // Create useful helper objects for these.
    this.pathTemplates = {
{%- for template in service.pathTemplates %}
      {{ template.name.toCamelCase() }}PathTemplate: new this._gaxModule.PathTemplate(
        '{{ template.pattern }}'
      ),
{%- endfor %}
    };
{%- endif %}

{%- if (service.paging.length > 0) %}

    // Some of the methods on this service return "paged" results,
    // (e.g. 50 results at a time, with tokens to get subsequent
    // pages). Denote the keys used for pagination and results.
    this.descriptors.page = {
{%- set pagingJoiner = joiner() %}
{%- for method in service.paging %}
      {{- pagingJoiner() }}
      {{ method.name.toCamelCase() }}:
          new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', '{{ method.pagingFieldName.toCamelCase() }}')
{%- endfor %}
    };
{%- endif %}

{%- if (service.streaming.length > 0) %}

    // Some of the methods on this service provide streaming responses.
    // Provide descriptors for these.
    this.descriptors.stream = {
{%- set streamingJoiner = joiner() %}
{%- for method in service.streaming %}
      {{- streamingJoiner() }}
      {{ method.name.toCamelCase() }}: new this._gaxModule.StreamDescriptor(gax.StreamType.{{ method.streaming }})
{%- endfor %}
    };
{%- endif %}
{%- if (service.longRunning.length > 0) or (service.bundleConfigs.length > 0) %}

    // This API contains "long-running operations", which return a
    // an Operation object that allows for tracking of the operation,
    // rather than holding a request open.
    const protoFilesRoot = opts.fallback ?
      this._gaxModule.protobuf.Root.fromJSON(
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        require("../../protos/protos.json")) :
      this._gaxModule.protobuf.loadSync(nodejsProtoPath);
{% endif %}
{%- if service.longRunning.length > 0 %}
    this.operationsClient = this._gaxModule.lro({
      auth: this.auth,
      grpc: 'grpc' in this._gaxGrpc ? this._gaxGrpc.grpc : undefined
    }).operationsClient(opts);

{%- for method in service.longRunning %}
    const {{ method.name.toCamelCase() }}Response = protoFilesRoot.lookup(
      '{{ method.longRunningResponseType }}') as gax.protobuf.Type;
    const {{ method.name.toCamelCase() }}Metadata = protoFilesRoot.lookup(
      '{{ method.longRunningMetadataType }}') as gax.protobuf.Type;
{%- endfor %}

    this.descriptors.longrunning = {
{%- set longRunningJoiner = joiner() %}
{%- for method in service.longRunning %}
      {{- longRunningJoiner() }}
      {{ method.name.toCamelCase() }}: new this._gaxModule.LongrunningDescriptor(
        this.operationsClient,
        {{ method.name.toCamelCase() }}Response.decode.bind({{ method.name.toCamelCase() }}Response),
        {{ method.name.toCamelCase() }}Metadata.decode.bind({{ method.name.toCamelCase() }}Metadata))
{%- endfor %}
    };
{%- endif %}

{%- if (service.bundleConfigs.length > 0) %}
    // Some methods on this API support automatically batching
    // requests; denote this.

    this.descriptors.batching = {
{%- for method in service.bundleConfigsMethods %}
      {{ method.name.toCamelCase() }}: new this._gaxModule.BundleDescriptor(
        '{{ method.bundleConfig.batchDescriptor.batched_field }}',
        [
{%- set pagingJoiner = joiner() -%}
{%- for field in method.bundleConfig.batchDescriptor.discriminator_fields -%}
        {{- pagingJoiner() -}}
        '{{ field }}'
{%- endfor -%}
        ],
{%- if method.bundleConfig.batchDescriptor.subresponse_field === 'null' %}
        null,
{%- else %}
        '{{- method.bundleConfig.batchDescriptor.subresponse_field }}',
{%- endif %}
        gax.createByteLengthFunction(
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          protoFilesRoot.lookupType('{{ method.bundleConfig.repeatedField }}') as any
        )
      ),
    };
{%- endfor %}
{%- endif %}

    // Put together the default options sent with requests.
    this._defaults = this._gaxGrpc.constructSettings(
        '{{ api.naming.protoPackage }}.{{ service.name }}', gapicConfig as gax.ClientConfig,
        opts.clientConfig || {}, {'x-goog-api-client': clientHeader.join(' ')});

    // Set up a dictionary of "inner API calls"; the core implementation
    // of calling the API is handled in `google-gax`, with this code
    // merely providing the destination and request information.
    this.innerApiCalls = {};
  }

  /**
   * Initialize the client.
   * Performs asynchronous operations (such as authentication) and prepares the client.
   * This function will be called automatically when any class method is called for the
   * first time, but if you need to initialize it before calling an actual method,
   * feel free to call {{ id.get("initialize") }}() directly.
   *
   * You can await on this method if you want to make sure the client is initialized.
   *
   * @returns {Promise} A promise that resolves to an authenticated service stub.
   */
  {{ id.get("initialize") }}() {
    // If the client stub promise is already initialized, return immediately.
    if (this.{{ service.name.toCamelCase() }}Stub) {
      return this.{{ service.name.toCamelCase() }}Stub;
    }

    // Put together the "service stub" for
    // {{api.naming.protoPackage}}.{{ service.name }}.
    this.{{ service.name.toCamelCase() }}Stub = this._gaxGrpc.createStub(
        this._opts.fallback ?
          (this._protos as protobuf.Root).lookupService('{{api.naming.protoPackage}}.{{ service.name }}') :
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (this._protos as any).{{api.naming.protoPackage}}.{{ service.name }},
        this._opts) as Promise<{[method: string]: Function}>;

    // Iterate over each of the methods that the service provides
    // and create an API call method for each.
    const {{ service.name.toCamelCase() }}StubMethods =
        [
{%- set stubMethodsJoiner = joiner(', ') -%}
{%- for method in service.method -%}
      {{- stubMethodsJoiner() -}}
      '{{ method.name.toCamelCase() }}'
{%- endfor -%}
    ];
    for (const methodName of {{ service.name.toCamelCase() }}StubMethods) {
      const callPromise = this.{{ service.name.toCamelCase() }}Stub.then(
        stub => (...args: Array<{}>) => {
          if (this._terminated) {
            return Promise.reject('The client has already been closed.');
          }
          const func = stub[methodName];
          return func.apply(stub, args);
        },
        (err: Error|null|undefined) => () => {
          throw err;
        });

      const descriptor =
{%- if service.paging.length > 0 %}
        this.descriptors.page[methodName] ||
{%- endif %}
{%- if service.streaming.length > 0 %}
        this.descriptors.stream[methodName] ||
{%- endif %}
{%- if service.longRunning.length > 0 %}
        this.descriptors.longrunning[methodName] ||
{%- endif %}
{%- if service.bundleConfigs.length > 0 %}
        this.descriptors.batching?.[methodName] ||
{%- endif %}
        undefined;
      const apiCall = this._gaxModule.createApiCall(
        callPromise,
        this._defaults[methodName],
        descriptor
      );

      this.innerApiCalls[methodName] = apiCall;
    }

    return this.{{ service.name.toCamelCase() }}Stub;
  }

  /**
   * The DNS address for this API service.
   * @returns {string} The DNS address for this service.
   */
  static get {{ id.get("servicePath") }}() {
    return '{{ api.hostName }}';
  }

  /**
   * The DNS address for this API service - same as {{ id.get("servicePath") }}(),
   * exists for compatibility reasons.
   * @returns {string} The DNS address for this service.
   */
  static get {{ id.get("apiEndpoint") }}() {
    return '{{ api.hostName }}';
  }

  /**
   * The port for this API service.
   * @returns {number} The default port for this service.
   */
  static get {{ id.get("port") }}() {
    return {{ api.port }};
  }

  /**
   * The scopes needed to make gRPC calls for every method defined
   * in this service.
   * @returns {string[]} List of default scopes.
   */
  static get {{ id.get("scopes") }}() {
{%- if (service.oauthScopes.length == 0) %}
    return [];
{%- else %}
    return [
{%- set scopesJoiner = joiner() %}
{%- for scope in service.oauthScopes %}
      {{- scopesJoiner() }}
      '{{ scope }}'
{%- endfor %}
    ];
{%- endif %}
  }

  {{ id.get("getProjectId") }}(): Promise<string>;
  {{ id.get("getProjectId") }}(callback: Callback<string, undefined, undefined>): void;
  /**
   * Return the project ID used by this class.
   * @returns {Promise} A promise that resolves to string containing the project ID.
   */
  {{ id.get("getProjectId") }}(callback?: Callback<string, undefined, undefined>):
      Promise<string>|void {
    if (callback) {
      this.auth.getProjectId(callback);
      return;
    }
    return this.auth.getProjectId();
  }

  // -------------------
  // -- Service calls --
  // -------------------

{%- for method in service.simpleMethods %}
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      options?: CallOptions):
      Promise<[
        {{ util.toInterface(method.outputInterface) }},
        {{ util.toInterface(method.inputInterface) }}|undefined, {}|undefined
      ]>;
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      options: CallOptions,
      callback: Callback<
          {{ util.toInterface(method.outputInterface) }},
          {{ util.toInterface(method.inputInterface) }}|null|undefined,
          {}|null|undefined>): void;
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      callback: Callback<
          {{ util.toInterface(method.outputInterface) }},
          {{ util.toInterface(method.inputInterface) }}|null|undefined,
          {}|null|undefined>): void;
/**
{{- util.printComments(method, service) }}
 */
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      optionsOrCallback?: CallOptions|Callback<
          {{ util.toInterface(method.outputInterface) }},
          {{ util.toInterface(method.inputInterface) }}|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          {{ util.toInterface(method.outputInterface) }},
          {{ util.toInterface(method.inputInterface) }}|null|undefined,
          {}|null|undefined>):
      Promise<[
        {{ util.toInterface(method.outputInterface) }},
        {{ util.toInterface(method.inputInterface) }}|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    {{ util.buildHeaderRequestParam(method) }}
    this.{{ id.get("initialize") }}();
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(request, options, callback);
  }
{%- endfor %}
{% for method in service.streaming %}
{%- if method.serverStreaming and method.clientStreaming %}
/**
{{- util.printComments(method, service) }}
 */
  {{ method.name.toCamelCase() }}(
      options?: CallOptions):
    gax.CancellableStream {
    this.{{ id.get("initialize") }}();
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(options);
  }
{%- elif method.serverStreaming %}
/**
{{- util.printComments(method, service) }}
 */
  {{ method.name.toCamelCase() }}(
      request?: {{ util.toInterface(method.inputInterface) }},
      options?: CallOptions):
    gax.CancellableStream{
    request = request || {};
    {{ util.buildHeaderRequestParam(method) }}
    this.{{ id.get("initialize") }}();
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(request, options);
  }
{%- elif method.clientStreaming %}
  {{ method.name.toCamelCase() }}(
      options?: CallOptions,
      callback?: Callback<
        {{ util.toInterface(method.outputInterface) }},
        {{ util.toInterface(method.inputInterface) }}|null|undefined,
        {}|null|undefined>):
    gax.CancellableStream;
  {{ method.name.toCamelCase() }}(
      callback?: Callback<
        {{ util.toInterface(method.outputInterface) }},
        {{ util.toInterface(method.inputInterface) }}|null|undefined,
        {}|null|undefined>):
    gax.CancellableStream;
/**
{{- util.printComments(method, service) }}
 */
  {{ method.name.toCamelCase() }}(
      optionsOrCallback?: CallOptions|Callback<
        {{ util.toInterface(method.outputInterface) }},
        {{ util.toInterface(method.inputInterface) }}|null|undefined,
        {}|null|undefined>,
      callback?: Callback<
        {{ util.toInterface(method.outputInterface) }},
        {{ util.toInterface(method.inputInterface) }}|null|undefined,
        {}|null|undefined>):
    gax.CancellableStream {
    if (optionsOrCallback instanceof Function && callback === undefined) {
        callback = optionsOrCallback;
        optionsOrCallback = {};
    }
    const options = optionsOrCallback as CallOptions;
    this.{{ id.get("initialize") }}();
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(null, options, callback);
  }
{%- endif %}
{% endfor %}
{%- for method in service.longRunning %}
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      options?: CallOptions):
      Promise<[
        LROperation<{{ util.toInterface(method.longRunningResponseType, method.inputType) }}, {{ util.toInterface(method.longRunningMetadataType, method.inputType) }}>,
        {{ util.toInterface(method.outputInterface) }}|undefined, {}|undefined
      ]>;
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      options: CallOptions,
      callback: Callback<
          LROperation<{{ util.toInterface(method.longRunningResponseType, method.inputType) }}, {{ util.toInterface(method.longRunningMetadataType, method.inputType)  }}>,
          {{ util.toInterface(method.outputInterface) }}|null|undefined,
          {}|null|undefined>): void;
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      callback: Callback<
          LROperation<{{ util.toInterface(method.longRunningResponseType, method.inputType) }}, {{ util.toInterface(method.longRunningMetadataType, method.inputType)  }}>,
          {{ util.toInterface(method.outputInterface) }}|null|undefined,
          {}|null|undefined>): void;
/**
{{- util.printComments(method, service) }}
 */
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      optionsOrCallback?: CallOptions|Callback<
          LROperation<{{ util.toInterface(method.longRunningResponseType, method.inputType)}}, {{ util.toInterface(method.longRunningMetadataType, method.inputType)  }}>,
          {{ util.toInterface(method.outputInterface) }}|null|undefined,
          {}|null|undefined>,
      callback?: Callback<
          LROperation<{{ util.toInterface(method.longRunningResponseType, method.inputType) }}, {{ util.toInterface(method.longRunningMetadataType, method.inputType)  }}>,
          {{ util.toInterface(method.outputInterface) }}|null|undefined,
          {}|null|undefined>):
      Promise<[
        LROperation<{{ util.toInterface(method.longRunningResponseType, method.inputType) }}, {{ util.toInterface(method.longRunningMetadataType, method.inputType)  }}>,
        {{ util.toInterface(method.outputInterface) }}|undefined, {}|undefined
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    {{ util.buildHeaderRequestParam(method) }}
    this.{{ id.get("initialize") }}();
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(request, options, callback);
  }
/**
{%- set decodeMethodName = id.get("check" + method.name.toPascalCase() + "Progress") -%}
{{- util.printDecodeMethodComments(method, decodeMethodName) }}
 */
  async {{ decodeMethodName }}(name: string): Promise<LROperation<protos{{ method.longRunningResponseType }}, protos{{ method.longRunningMetadataType }}>>{
    const request = new operationsProtos.google.longrunning.GetOperationRequest({name});
    const [operation] = await this.operationsClient.getOperation(request);
    const decodeOperation = new gax.Operation(operation, this.descriptors.longrunning.{{ method.name.toCamelCase() }}, gax.createDefaultBackoffSettings());
    return decodeOperation as LROperation<protos{{ method.longRunningResponseType }}, protos{{ method.longRunningMetadataType }}>;
  }
{%- endfor %}
{%- for method in service.paging %}
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      options?: CallOptions):
      Promise<[
        {{ util.toInterface(method.pagingResponseType) }}[],
        {{ util.toInterface(method.inputInterface) }}|null,
        {{ util.toInterface(method.outputInterface) }}
      ]>;
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      options: CallOptions,
      callback: PaginationCallback<
          {{ util.toInterface(method.inputInterface) }},
          {{ util.toInterface(method.outputInterface) }}|null|undefined,
          {{ util.toInterface(method.pagingResponseType) }}>): void;
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      callback: PaginationCallback<
          {{ util.toInterface(method.inputInterface) }},
          {{ util.toInterface(method.outputInterface) }}|null|undefined,
          {{ util.toInterface(method.pagingResponseType) }}>): void;
/**
{{- util.printComments(method, service, id.get(method.name.toCamelCase() + "Async")) }}
 */
  {{ method.name.toCamelCase() }}(
      request: {{ util.toInterface(method.inputInterface) }},
      optionsOrCallback?: CallOptions|PaginationCallback<
          {{ util.toInterface(method.inputInterface) }},
          {{ util.toInterface(method.outputInterface) }}|null|undefined,
          {{ util.toInterface(method.pagingResponseType) }}>,
      callback?: PaginationCallback<
          {{ util.toInterface(method.inputInterface) }},
          {{ util.toInterface(method.outputInterface) }}|null|undefined,
          {{ util.toInterface(method.pagingResponseType) }}>):
      Promise<[
        {{ util.toInterface(method.pagingResponseType) }}[],
        {{ util.toInterface(method.inputInterface) }}|null,
        {{ util.toInterface(method.outputInterface) }}
      ]>|void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    }
    else {
      options = optionsOrCallback as CallOptions;
    }
    {{ util.buildHeaderRequestParam(method) }}
    this.{{ id.get("initialize") }}();
    return this.innerApiCalls.{{ method.name.toCamelCase() }}(request, options, callback);
  }

/**
{{- util.printCommentsPageStream(method, id.get(method.name.toCamelCase() + "Async")) }}
 */
  {{ id.get(method.name.toCamelCase() + "Stream") }}(
      request?: {{ util.toInterface(method.inputInterface) }},
      options?: CallOptions):
    Transform{
    request = request || {};
    {{ util.buildHeaderRequestParam(method) }}
    const callSettings = new gax.CallSettings(options);
    this.{{ id.get("initialize") }}();
    return this.descriptors.page.{{ method.name.toCamelCase() }}.createStream(
      this.innerApiCalls.{{ method.name.toCamelCase() }} as gax.GaxCall,
      request,
      callSettings
    );
  }

/**
{{- util.printCommentsPageAsync(method, id.get(method.name.toCamelCase() + "Async")) }}
 */
  {{ id.get(method.name.toCamelCase() + "Async") }}(
      request?: {{ util.toInterface(method.inputInterface) }},
      options?: CallOptions):
    AsyncIterable<{{ util.toInterface(method.pagingResponseType) }}>{
    request = request || {};
    {{ util.buildHeaderRequestParam(method) }}
    options = options || {};
    const callSettings = new gax.CallSettings(options);
    this.{{ id.get("initialize") }}();
    return this.descriptors.page.{{ method.name.toCamelCase() }}.asyncIterate(
      this.innerApiCalls['{{ method.name.toCamelCase() }}'] as GaxCall,
      request as unknown as RequestType,
      callSettings
    ) as AsyncIterable<{{ util.toInterface(method.pagingResponseType) }}>;
  }
{%- endfor %}
{%- if service.iamService %}
{{ iam.iamServiceMethods()}}
{% endif -%}
{%- if (service.pathTemplates.length > 0) %}
  // --------------------
  // -- Path templates --
  // --------------------
{%- for template in service.pathTemplates %}

  /**
   * Return a fully-qualified {{ template.name.toCamelCase() }} resource name string.
   *
{%- for param in template.params %}
   * @param {string} {{ param | replace(regExp, '{@link $2|$1}') }}
{%- endfor %}
   * @returns {string} Resource name string.
   */
  {{ id.get(template.name.toCamelCase() + "Path") }}(
{%- set paramJoiner = joiner() %}
{%- for param in template.params %}
{{-paramJoiner()-}}{{ param.toCamelCase() }}:string
{%- endfor -%}
  ) {
    return this.pathTemplates.{{ template.name.toCamelCase() }}PathTemplate.render({
{%- for param in template.params %}
      {{ param }}: {{ param.toCamelCase() }},
{%- endfor %}
    });
  }
{%- for param in template.params %}

  /**
   * Parse the {{ param }} from {{ template.name.toPascalCase() }} resource.
   *
   * @param {string} {{ template.name.toCamelCase() }}Name
   *   A fully-qualified path representing {{ template.name }} resource.
   * @returns {string} A string representing the {{ param }}.
   */
  {{ id.get("match" + param.toPascalCase() + "From" + template.name.toPascalCase() + "Name") }}({{ template.name.toCamelCase() }}Name: string) {
    return this.pathTemplates.{{ template.name.toCamelCase() }}PathTemplate.match({{ template.name.toCamelCase() }}Name).{{ param }};
  }
{%- endfor %}
{%- endfor %}
{%- endif %}

  /**
   * Terminate the gRPC channel and close the client.
   *
   * The client will no longer be usable and all future behavior is undefined.
   * @returns {Promise} A promise that resolves when the client is closed.
   */
  {{ id.get("close") }}(): Promise<void> {
    this.{{ id.get("initialize") }}();
    if (!this._terminated) {
      return this.{{ service.name.toCamelCase() }}Stub!.then(stub => {
        this._terminated = true;
        stub.close();
      });
    }
    return Promise.resolve();
  }
}
